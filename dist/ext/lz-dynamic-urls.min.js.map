{"version":3,"sources":["lz-dynamic-urls.min.js"],"names":["root","factory","define","amd","LocusZoom","module","exports","require","ext","DynamicUrls","this","_parseQueryParams","queryString","query","pairs","substr","split","i","length","pair","decodeURIComponent","_extractValues","data","mapping","reverse","ret","newMapping","Object","keys","forEach","k","asName","hasOwnProperty","_setStateFromUrlHandler","plot","stateData","applyState","_setUrlFromStateHandler","state","paramsFromUrl","window","location","search","plotWatchesUrl","callback","listener","event","addEventListener","plotUpdatesUrl","eventContext","paramsObj","oldParams","serializedPlotData","newParams","assign","some","map","key","encodeURIComponent","join","history","pushState","document","title","replaceState","on"],"mappings":"AAUA,cAKC,SAAUA,EAAMC,GACS,mBAAXC,QAAyBA,OAAOC,IACvCD,OAAO,CAAC,aAAc,SAASE,GAC3B,OAAOH,EAAQG,KAEK,iBAAXC,QAAuBA,OAAOC,QAC3CD,OAAOC,QAAUL,EAAQM,QAAQ,cAEjCP,EAAKI,UAAUI,IAAIC,YAAcR,EAAQD,EAAKI,WARtD,CAUEM,KAAM,SAASN,GAWb,SAASO,EAAkBC,GAIvB,IAAIC,EAAQ,GACZ,GAAID,EAEA,IADA,IAAIE,GAA4B,MAAnBF,EAAY,GAAaA,EAAYG,OAAO,GAAKH,GAAaI,MAAM,KACxEC,EAAI,EAAGA,EAAIH,EAAMI,OAAQD,IAAK,CACnC,IAAIE,EAAOL,EAAMG,GAAGD,MAAM,KAC1BH,EAAMO,mBAAmBD,EAAK,KAAOC,mBAAmBD,EAAK,IAAM,IAG3E,OAAON,EAGX,SAASQ,EAAeC,EAAMC,EAASC,GAMnC,IAAIC,EAAM,GACNC,EAAaH,EAajB,OAhBAC,EAAUA,IAAW,KAKjBE,EAAa,GACbC,OAAOC,KAAKL,GAASM,QAAQ,SAASC,GAAKJ,EAAWH,EAAQO,IAAMA,KAGxEH,OAAOC,KAAKF,GAAYG,QAAQ,SAASC,GACrC,IAAIC,EAASL,EAAWI,GACpBR,EAAKU,eAAeF,KACpBL,EAAIM,GAAUT,EAAKQ,MAIpBL,EAGX,SAASQ,EAAwBC,EAAMC,GAGnCD,EAAKE,WAAWD,GAGpB,SAASE,EAAwBH,EAAMX,GAOnC,OAAOF,EAAea,EAAKI,MAAOf,GAGtC,SAASgB,EAAchB,EAASX,GAI5B,OAAOS,EADWV,EADlBC,EAAcA,GAAe4B,OAAOC,SAASC,QAEVnB,GAAS,GAIhD,MAAO,CAQHgB,cAAeA,EAefI,eAAgB,SAAST,EAAMX,EAASqB,GACpCA,EAAWA,GAAYX,EAEvB,IAAIY,EAAW,SAASC,GACpB,IAAIX,EAAYI,EAAchB,GAE9BqB,EAASV,EAAMC,IAGnB,OADAK,OAAOO,iBAAiB,WAAYF,GAC7BA,GAYXG,eAAgB,SAASd,EAAMX,EAASqB,GACpCA,EAAWA,GAAYP,EAGvB,IAAIQ,EAAW,SAASI,GACpB,IAzHmBC,EAyHfC,EAAYxC,EAAkB6B,OAAOC,SAASC,QAE9CU,EAAqBR,EAASV,EAAMX,EAAS0B,GAC7CI,EAAY1B,OAAO2B,OAAO,GAAIH,EAAWC,GAK7C,GADazB,OAAOC,KAAKyB,GAAWE,KAAK,SAASzB,GAAK,OAAQqB,EAAUrB,IAAMuB,EAAUvB,KAC7E,CACR,IAAIlB,GAlIWsC,EAkIyBG,EA/H7C,IACH1B,OAAOC,KAAKsB,GAAWM,IAAI,SAASC,GAChC,OAAOC,mBAAmBD,GAAO,IAC7BC,mBAAmBR,EAAUO,MAClCE,KAAK,MA6HIhC,OAAOC,KAAKuB,GAAWjC,OACvB0C,QAAQC,UAAU,GAAIC,SAASC,MAAOnD,GAItCgD,QAAQI,aAAa,GAAIF,SAASC,MAAOnD,KAMrD,OADAsB,EAAK+B,GAAG,gBAAiBpB,GAClBA","file":"lz-dynamic-urls.min.js","sourcesContent":["/**\n * Optional LocusZoom extension: must be included separately, and after LocusZoom has been loaded\n *\n * Demonstrates a mechanism by which the plot can be loaded to a specific initial state based on the URL query string\n *  (and, optionally, to update the URL bar when the plot state changes, with back button support)\n *\n * This makes it possible to create \"direct links\" to a particular plot of interest (and go back to a previous state\n *  as the user interacts with the page). Optionally, there is support for custom callbacks to connect the URL to\n *  arbitrarily complex plot behaviors.\n */\n'use strict';\n\n// This is defined as a UMD module, to work with multiple different module systems / bundlers\n/* global define, module, require */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(['locuszoom'], function(LocusZoom) {  // amd\n            return factory(LocusZoom);\n        });\n    } else if(typeof module === 'object' && module.exports) {  // commonJS\n        module.exports = factory(require('locuszoom'));\n    } else {  // globals\n        root.LocusZoom.ext.DynamicUrls = factory(root.LocusZoom);\n    }\n}(this, function(LocusZoom) {\n    function _serializeQueryParams(paramsObj) {\n        // Serialize an object of parameter values into a query string\n        // TODO: Improve support for array values v[]=1&v[]=2\n        return '?' +\n            Object.keys(paramsObj).map(function(key) {\n                return encodeURIComponent(key) + '=' +\n                    encodeURIComponent(paramsObj[key]);\n            }).join('&');\n    }\n\n    function _parseQueryParams(queryString) {\n        // Parse a query string into an object of parameter values.\n        //   Does not attempt any type coercion; all values are, therefore, strings.\n        // TODO future: Support arrays / params that specify more than one value\n        var query = {};\n        if (queryString) {\n            var pairs = (queryString[0] === '?' ? queryString.substr(1) : queryString).split('&');\n            for (var i = 0; i < pairs.length; i++) {\n                var pair = pairs[i].split('=');\n                query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');\n            }\n        }\n        return query;\n    }\n\n    function _extractValues(data, mapping, reverse) {\n        // Use the mapping to convert between {stateField: urlParam} (or the reverse). Any fields not referenced in\n        //  the \"key\" side of the mapping will be omitted from the return value.\n        // Likewise, will omit any requested keys that the source side of the mapping has no information for\n        reverse = reverse || false;\n\n        var ret = {};\n        var newMapping = mapping;\n        if (reverse) {\n            newMapping = {};\n            Object.keys(mapping).forEach(function(k) { newMapping[mapping[k]] = k; });\n        }\n\n        Object.keys(newMapping).forEach(function(k) {\n            var asName = newMapping[k];\n            if (data.hasOwnProperty(k)) {\n                ret[asName] = data[k];\n            }\n\n        });\n        return ret;\n    }\n\n    function _setStateFromUrlHandler(plot, stateData) {\n        // A default way to deal with URL changes: push all the params as state into plot and rerender\n        // More complex handlers are possible- example, URL parameters could be used to add or remove data layers\n        plot.applyState(stateData);\n    }\n\n    function _setUrlFromStateHandler(plot, mapping) {\n        // Serialize and return basic query params based solely on information from plot.state\n        // More complex handlers are possible- the serializer can extract any information desired because it is given\n        //  a direct reference to the plot object\n\n        // This default method does not use the eventContext data, because so many things change plot.state without\n        //  officially triggering an event.\n        return _extractValues(plot.state, mapping);\n    }\n\n    function paramsFromUrl(mapping, queryString) {\n        // Internal helper function: second argument only used for unit testing\n        queryString = queryString || window.location.search;\n        var queryParams = _parseQueryParams(queryString);\n        return _extractValues(queryParams, mapping, true);\n    }\n\n    // Public interface for this extension\n    return {\n        /**\n         * Extract plot parameters from the URL query string. Very useful for setting up the plot on initial page load.\n         * @param {object} mapping How to map elements of plot state to URL param fields. Hash of\n         *      {plotFieldName: urlParamName} entries (both values should be unique)\n         * @param {string} [queryString='window.location.search'] The query string to parse\n         * @returns {object} Plot parameter values\n         */\n        paramsFromUrl: paramsFromUrl,\n\n        /**\n         * Allows the plot to monitor changes in the URL and take action when the URL changes.\n         *\n         * For example, this enables using the browser back button to jump to a previous plot after user interaction.\n         *\n         * @param {LocusZoom.Plot} plot A reference to the LZ plot\n         * @param {object} mapping How to map elements of plot state to URL param fields. Hash of\n         *      {plotFieldName: urlParamName} entries (both values should be unique)\n         * @param {function} [callback] Specify how the plot acts on information read in from query params.\n         *   The default behavior is to push the data into `plot.state`\n         *   Signature is function(plot, plotDataFromQueryString)\n         * @returns {function} The function handle for the new listener (allows cleanup if plot is removed later)\n         */\n        plotWatchesUrl: function(plot, mapping, callback) {\n            callback = callback || _setStateFromUrlHandler;\n\n            var listener = function(event) {\n                var stateData = paramsFromUrl(mapping);\n                // Tell the plot what to do with the params extracted from the URL\n                callback(plot, stateData);\n            };\n            window.addEventListener('popstate', listener);\n            return listener;\n        },\n        /**\n         * Update the URL whenever the plot state changes\n         * @param {LocusZoom.Plot} plot A reference to the LZ plot\n         * @param {object} mapping How to map elements of plot state to URL param fields. Hash of\n         *      {plotFieldName: urlParamName} entries (both values should be unique)\n         * @param {function} [callback] Specify how plot data will be serialized into query params\n         *   The default behavior is to extract all the URL params from plot.state as the only source.\n         *   Signature is function(plot, mapping, eventContext)\n         * @returns {function} The function handle for the new listener (allows cleanup if plot is removed later)\n         */\n        plotUpdatesUrl: function(plot, mapping, callback) {\n            callback = callback || _setUrlFromStateHandler;\n            // Note: this event only fires when applyState receives *new* information that would trigger a rerender.\n            // Plot state is sometimes changed without the event being fired.\n            var listener = function(eventContext) {\n                var oldParams = _parseQueryParams(window.location.search);\n                // Apply custom serialization to convert plot data to URL params\n                var serializedPlotData = callback(plot, mapping, eventContext);\n                var newParams = Object.assign({}, oldParams, serializedPlotData);\n\n                // Not every state change would affect the URL. Allow type coercion since query is a string.\n                // eslint-disable-next-line eqeqeq\n                var update = Object.keys(newParams).some(function(k) { return (oldParams[k] != newParams[k]); });\n                if (update) {\n                    var queryString = _serializeQueryParams(newParams);\n\n                    if (Object.keys(oldParams).length) {\n                        history.pushState({}, document.title, queryString);\n                    } else {\n                        // Prevent broken back behavior on first page load: the first time query params are set,\n                        //  we don't generate a separate history entry\n                        history.replaceState({}, document.title, queryString);\n                    }\n\n                }\n            };\n            plot.on('state_changed', listener);\n            return listener;\n        }\n    };\n}));\n"]}