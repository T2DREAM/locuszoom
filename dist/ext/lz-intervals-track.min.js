/*! Locuszoom 0.13.0-beta.3 */
var LzIntervalsTrack =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./esm/ext/lz-intervals-track.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./esm/ext/lz-intervals-track.js":
/*!***************************************!*\
  !*** ./esm/ext/lz-intervals-track.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/**
Interval annotation track (for chromatin state, etc). Useful for BED file data with non-overlapping intervals.
This is not part of the core LocusZoom library, but can be included as a standalone file.

The page must incorporate and load all libraries before this file can be used, including:
 - Vendor assets
 - LocusZoom
 @module
*/




// Coordinates (start, end) are cached to facilitate rendering
const XCS = Symbol.for('lzXCS');
const YCS = Symbol.for('lzYCS');
const XCE = Symbol.for('lzXCE');
const YCE = Symbol.for('lzYCE');


function install (LocusZoom) {
    const BaseApiAdapter = LocusZoom.Adapters.get('BaseApiAdapter');
    const _Button = LocusZoom.Widgets.get('_Button');
    const _BaseWidget = LocusZoom.Widgets.get('BaseWidget');

    /**
     * Data Source for Interval Annotation Data (e.g. BED Tracks), as fetched from the LocusZoom API server (or compatible)
     * @public
     */
    class IntervalLZ extends BaseApiAdapter {
        getURL(state, chain, fields) {
            const source = chain.header.bedtracksource || this.params.source;
            const query = `?filter=id in ${source} and chromosome eq '${state.chr}' and start le ${state.end} and end ge ${state.start}`;
            return `${this.url}${query}`;
        }
    }

    /**
     * Button to toggle split tracks
     */
    class ToggleSplitTracks extends _BaseWidget {
        constructor(layout) {
            super(...arguments);
            if (!layout.data_layer_id) {
                layout.data_layer_id = 'intervals';
            }
            if (!this.parent_panel.data_layers[layout.data_layer_id]) {
                throw new Error('Toggle split tracks widget specifies an invalid data layer ID');
            }
        }

        update() {
            const data_layer = this.parent_panel.data_layers[this.layout.data_layer_id];
            const html = data_layer.layout.split_tracks ? 'Merge Tracks' : 'Split Tracks';
            if (this.button) {
                this.button.setHtml(html);
                this.button.show();
                this.parent.position();
                return this;
            } else {
                this.button = new _Button(this)
                    .setColor(this.layout.color)
                    .setHtml(html)
                    .setTitle('Toggle whether tracks are split apart or merged together')
                    .setOnclick(() => {
                        data_layer.toggleSplitTracks();
                        // FIXME: the timeout calls to scale and position (below) cause full ~5 additional re-renders
                        //  If we can remove these it will greatly speed up re-rendering.
                        // The key problem here is that the height is apparently not known in advance and is determined after re-render.
                        if (this.scale_timeout) {
                            clearTimeout(this.scale_timeout);
                        }
                        this.scale_timeout = setTimeout(() => {
                            this.parent_panel.scaleHeightToData();
                            this.parent_plot.positionPanels();
                        }, 0);
                        this.update();
                    });
                return this.update();
            }
        }
    }


    /**
     * Convert a value ""rr,gg,bb" (if given) to a css-friendly color string: "rgb(rr,gg,bb)".
     * This is tailored specifically to the color specification format embraced by the BED file standard.
     * @function to_rgb
     * @param {Object} parameters This function has no defined configuration options
     * @param {String|null} value The value to convert to rgb
     */
    function to_rgb(parameters, value) {
        return value ? `rgb(${value})` : null;
    }

    const default_layout = {
        start_field: 'start',
        end_field: 'end',
        track_label_field: 'state_name', // Used to label items on the y-axis
        // Used to uniquely identify tracks for coloring. This tends to lead to more stable coloring/sorting
        //  than using the label field- eg, state_ids allow us to set global colors across the entire dataset,
        //  not just choose unique colors within a particular narrow region. (where changing region might lead to more
        //  categories and different colors)
        track_split_field: 'state_id',
        track_split_order: 'DESC',
        track_split_legend_to_y_axis: 2,
        split_tracks: true,
        track_height: 15,
        track_vertical_spacing: 3,
        bounding_box_padding: 2,
        always_hide_legend: false,
        color: '#B8B8B8',
        fill_opacity: 1,
        tooltip_positioning: 'vertical',
    };


    /**
     * Intervals Data Layer
     * Implements a data layer that will render interval annotation tracks (intervals must provide start and end values)
     */
    const BaseLayer = LocusZoom.DataLayers.get('BaseDataLayer');
    class LzIntervalsTrack extends BaseLayer {
        constructor(layout) {
            LocusZoom.Layouts.merge(layout, default_layout);
            super(...arguments);
            this._previous_categories = [];
            this._categories = [];
        }

        initialize() {
            super.initialize();
            this._statusnodes_group = this.svg.group.append('g')
                .attr('class', 'lz-data-layer-intervals lz-data-layer-intervals-statusnode');
            this._datanodes_group = this.svg.group.append('g')
                .attr('class', 'lz-data_layer-intervals');
        }

        /**
         * Split data into tracks such that anything with a common grouping field is in the same track
         * @param data
         * @return {unknown[]}
         * @private
         */
        _arrangeTrackSplit(data) {
            const {track_split_field} = this.layout;
            const result = {};
            data.forEach((item) => {
                const item_key = item[track_split_field];
                if (!Object.prototype.hasOwnProperty.call(result, item_key)) {
                    result[item_key] = [];
                }
                result[item_key].push(item);
            });
            return result;
        }

        /**
         * Split data into rows using a simple greedy algorithm such that no two items overlap (share same interval)
         * Assumes that the data are sorted so item1.start always <= item2.start.
         *
         * This function can also simply return all data on a single row. This functionality may become configurable
         *  in the future but for now reflects a lack of clarity in the requirements/spec. The code to split
         *  overlapping items is present but may not see direct use.
         */
        _arrangeTracksLinear(data, allow_overlap = true) {
            if (allow_overlap) {
                // If overlap is allowed, then all the data can live on a single row
                return [data];
            }

            // ASSUMPTION: Data is given to us already sorted by start position to facilitate grouping.
            // We do not sort here because JS "sort" is not stable- if there are many intervals that overlap, then we
            //   can get different layouts (number/order of rows) on each call to "render".
            //
            // At present, we decide how to update the y-axis based on whether current and former number of rows are
            //  the same. An unstable sort leads to layout thrashing/too many re-renders. FIXME: don't rely on counts
            const {start_field, end_field} = this.layout;

            const grouped_data = [[]]; // Prevent two items from colliding by rendering them to different rows, like genes
            data.forEach((item, index) => {
                for (let i = 0; i < grouped_data.length; i++) {
                    // Iterate over all rows of the
                    const row_to_test = grouped_data[i];
                    const last_item = row_to_test[row_to_test.length - 1];
                    // Some programs report open intervals, eg 0-1,1-2,2-3; these points are not considered to overlap (hence the test isn't "<=")
                    const has_overlap = last_item && (item[start_field] < last_item[end_field]) && (last_item[start_field] < item[end_field]);
                    if (!has_overlap) {
                        // If there is no overlap, add item to current row, and move on to the next item
                        row_to_test.push(item);
                        return;
                    }
                }
                // If this item would collide on all existing rows, create a new row
                grouped_data.push([item]);
            });
            return grouped_data;
        }

        /**
         * Annotate each item with the track number, and return.
         * @param {Object[]}data
         * @private
         * @return [String[], Object[]] Return the categories and the data array
         */
        _assignTracks(data) {
            // Flatten the grouped data.
            const {x_scale} = this.parent;
            const {start_field, end_field, bounding_box_padding, track_height} = this.layout;

            const grouped_data = this.layout.split_tracks ? this._arrangeTrackSplit(data) : this._arrangeTracksLinear(data, true);
            const categories = Object.keys(grouped_data);
            if (this.layout.track_split_order === 'DESC') {
                categories.reverse();
            }

            categories.forEach((key, row_index) => {
                const row = grouped_data[key];
                row.forEach((item) => {
                    item[XCS] = x_scale(item[start_field]);
                    item[XCE] = x_scale(item[end_field]);
                    item[YCS] = row_index * this.getTrackHeight() + bounding_box_padding;
                    item[YCE] = item[YCS] + track_height;
                    // Store the row ID, so that clicking on a point can find the right status node (big highlight box)
                    item.track = row_index;
                });
            });
            // We're mutating elements of the original data array as a side effect: the return value here is
            //  interchangeable with `this.data` for subsequent usages
            // TODO: Can replace this with array.flat once polyfill support improves
            return [categories, Object.values(grouped_data).reduce((acc, val) => acc.concat(val), [])];
        }

        /**
         * When we are in "split tracks mode", it's convenient to wrap all individual annotations with a shared
         *  highlight box that wraps everything on that row.
         *
         * This is done automatically by the "setElementStatus" code, if this function returns a non-null value
         *
         * To define shared highlighting on the track split field define the status node id override
         * to generate an ID common to the track when we're actively splitting data out to separate tracks
         * @override
         * @returns {String}
         */
        getElementStatusNodeId(element) {
            if (this.layout.split_tracks) {
                // Data nodes are bound to data objects, but the "status_nodes" selection is bound to numeric row IDs
                const track = typeof element === 'object' ? element.track : element;
                const base = `${this.getBaseId()}-statusnode-${track}`;
                return base.replace(/[^\w]/g, '_');
            }
            // In merged tracks mode, there is no separate status node
            return null;
        }

        // Helper function to sum layout values to derive total height for a single interval track
        getTrackHeight() {
            return this.layout.track_height
                + this.layout.track_vertical_spacing
                + (2 * this.layout.bounding_box_padding);
        }

        // Modify the layout as necessary to ensure that appropriate color, label, and legend options are available
        // Even when not displayed, the legend is used to generate the y-axis ticks
        _applyLayoutOptions() {
            const self = this;
            const base_layout = this._base_layout;
            const render_layout = this.layout;
            const base_color_scale = base_layout.color.find(function (item) {
                return item.scale_function && item.scale_function === 'categorical_bin';
            });
            const color_scale = render_layout.color.find(function (item) {
                return item.scale_function && item.scale_function === 'categorical_bin';
            });
            if (!base_color_scale) {
                // This can be a placeholder (empty categories & values), but it needs to be there
                throw new Error('Interval tracks must define a `categorical_bin` color scale');
            }

            const has_colors = base_color_scale.parameters.categories.length && base_color_scale.parameters.values.length;
            const has_legend = base_layout.legend && base_layout.legend.length;

            if (!!has_colors ^ !!has_legend) {
                // Don't allow color OR legend to be set manually. It must be both, or neither.
                throw new Error('To use a manually specified color scheme, both color and legend options must be set.');
            }

            // Harvest any information about an explicit color field that should be considered when generating colors
            const rgb_option = base_layout.color.find(function (item) {
                return item.scale_function && item.scale_function === 'to_rgb';
            });
            const rgb_field = rgb_option && rgb_option.field;

            // Auto-generate legend based on data
            const known_categories = this._generateCategoriesFromData(this.data, rgb_field); // [id, label, itemRgb] items

            if (!has_colors && !has_legend) {
                // If no color scheme pre-defined, then make a color scheme that is appropriate and apply to the plot
                // The legend must match the color scheme. If we generate one, then we must generate both.

                const colors = this._makeColorScheme(known_categories);
                color_scale.parameters.categories = known_categories.map(function (item) {
                    return item[0];
                });
                color_scale.parameters.values = colors;

                this.layout.legend = known_categories.map(function (pair, index) {
                    const id = pair[0];
                    const label = pair[1];
                    const item_color = color_scale.parameters.values[index];
                    const item = { shape: 'rect', width: 9, label: label, color: item_color };
                    item[self.layout.track_split_field] = id;
                    return item;
                });
            }
        }

        // Implement the main render function
        render() {
            //// Autogenerate layout options if not provided
            this._applyLayoutOptions();

            // Determine the appropriate layout for tracks. Store the previous categories (y axis ticks) to decide
            //   whether the axis needs to be re-rendered.
            this._previous_categories = this._categories;
            const [categories, assigned_data] = this._assignTracks(this.data);
            this._categories = categories;
            // Update the legend axis if the number of ticks changed
            const labels_changed = !categories.every( (item, index) => item === this._previous_categories[index]);
            if (labels_changed) {
                this.updateSplitTrackAxis(categories);
                return;
            }

            // Apply filters to only render a specified set of points. Hidden fields will still be given space to render, but not shown.
            const track_data = this._applyFilters(assigned_data);

            // Clear before every render so that, eg, highlighting doesn't persist if we load a region with different
            //  categories (row 2 might be a different category and it's confusing if the row stays highlighted but changes meaning)
            // Highlighting will automatically get added back if it actually makes sense, courtesy of setElementStatus,
            //  if a selected item is still in view after the new region loads.
            this._statusnodes_group.selectAll('rect')
                .remove();

            // Reselect in order to add new data
            const status_nodes = this._statusnodes_group.selectAll('rect')
                .data(d3__WEBPACK_IMPORTED_MODULE_0__["range"](categories.length));

            if (this.layout.split_tracks) {
                // Status nodes: a big highlight box around all items of the same type. Used in split tracks mode,
                //  because everything on the same row is the same category and a group makes sense
                // There are no status nodes in merged mode, because the same row contains many kinds of things

                // Status nodes are 1 per row, so "data" can just be a dummy list of possible row IDs
                // Each status node is a box that runs the length of the panel and receives a special "colored box" css
                //  style when selected
                const height = this.getTrackHeight();
                status_nodes.enter()
                    .append('rect')
                    .attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-shared')
                    .attr('rx', this.layout.bounding_box_padding)
                    .attr('ry', this.layout.bounding_box_padding)
                    .merge(status_nodes)
                    .attr('id', (d) => this.getElementStatusNodeId(d))
                    .attr('x', 0)
                    .attr('y', (d) => (d * height))
                    .attr('width', this.parent.layout.cliparea.width)
                    .attr('height', height - this.layout.track_vertical_spacing);
            }
            status_nodes.exit()
                .remove();

            // Draw rectangles for the data (intervals)
            const data_nodes = this._datanodes_group.selectAll('rect')
                .data(track_data, (d) => d[this.layout.id_field]);

            data_nodes.enter()
                .append('rect')
                .merge(data_nodes)
                .attr('id', (d) => this.getElementId(d))
                .attr('x', (d) => d[XCS])
                .attr('y', (d) => d[YCS])
                .attr('width', (d) => d[XCE] - d[XCS])
                .attr('height', this.layout.track_height)
                .attr('fill', (d, i) => this.resolveScalableParameter(this.layout.color, d, i))
                .attr('fill-opacity', (d, i) => this.resolveScalableParameter(this.layout.fill_opacity, d, i));

            data_nodes.exit()
                .remove();

            this._datanodes_group
                .call(this.applyBehaviors.bind(this));

            // The intervals track allows legends to be dynamically generated, in which case space can only be
            //  allocated after the panel has been rendered.
            if (this.parent && this.parent.legend) {
                this.parent.legend.render();
            }
        }

        _getTooltipPosition(tooltip) {
            return {
                x_min: tooltip.data[XCS],
                x_max: tooltip.data[XCE],
                y_min: tooltip.data[YCS],
                y_max: tooltip.data[YCE],
            };
        }

        // Redraw split track axis or hide it, and show/hide the legend, as determined
        // by current layout parameters and data
        updateSplitTrackAxis(categories) {
            const legend_axis = this.layout.track_split_legend_to_y_axis ? `y${this.layout.track_split_legend_to_y_axis}` : false;
            if (this.layout.split_tracks) {
                const tracks = +categories.length || 0;
                const track_height = +this.layout.track_height || 0;
                const track_spacing = 2 * (+this.layout.bounding_box_padding || 0) + (+this.layout.track_vertical_spacing || 0);
                const target_height = (tracks * track_height) + ((tracks - 1) * track_spacing);
                this.parent.scaleHeightToData(target_height);
                if (legend_axis && this.parent.legend) {
                    this.parent.legend.hide();
                    this.parent.layout.axes[legend_axis] = {
                        render: true,
                        ticks: [],
                        range: {
                            start: (target_height - (this.layout.track_height / 2)),
                            end: (this.layout.track_height / 2),
                        },
                    };
                    // There is a very tight coupling between the display directives: each legend item must identify a key
                    //  field for unique tracks. (Typically this is `state_id`, the same key field used to assign unique colors)
                    // The list of unique keys corresponds to the order along the y-axis
                    this.layout.legend.forEach((element) => {
                        const key = element[this.layout.track_split_field];
                        let track = categories.findIndex((item) => item === key);
                        if (track !== -1) {
                            if (this.layout.track_split_order === 'DESC') {
                                track = Math.abs(track - tracks - 1);
                            }
                            this.parent.layout.axes[legend_axis].ticks.push({
                                y: track - 1,
                                text: element.label,
                            });
                        }
                    });
                    this.layout.y_axis = {
                        axis: this.layout.track_split_legend_to_y_axis,
                        floor: 1,
                        ceiling: tracks,
                    };
                }
                // This will trigger a re-render
                this.parent_plot.positionPanels();
            } else {
                if (legend_axis && this.parent.legend) {
                    if (!this.layout.always_hide_legend) {
                        this.parent.legend.show();
                    }
                    this.parent.layout.axes[legend_axis] = { render: false };
                    this.parent.render();
                }
            }
            return this;
        }

        // Method to not only toggle the split tracks boolean but also update
        // necessary display values to animate a complete merge/split
        toggleSplitTracks() {
            this.layout.split_tracks = !this.layout.split_tracks;
            if (this.parent.legend && !this.layout.always_hide_legend) {
                this.parent.layout.margin.bottom = 5 + (this.layout.split_tracks ? 0 : this.parent.legend.layout.height + 5);
            }
            this.render();
            return this;
        }

        // Choose an appropriate color scheme based on the number of items in the track, and whether or not we are
        //  using explicitly provided itemRgb information
        _makeColorScheme(category_info) {
            // If at least one element has an explicit itemRgb, assume the entire dataset has colors
            const has_explicit_colors = category_info.find((item) => item[2]);
            if (has_explicit_colors) {
                return category_info.map((item) => item[2]);
            }

            // Use a set of color schemes for common 15, 18, or 25 state models, as specified from:
            //  https://egg2.wustl.edu/roadmap/web_portal/chr_state_learning.html
            // These are actually reversed so that dim colors come first, on the premise that usually these are the
            //  most common states
            const n_categories = category_info.length;
            if (n_categories <= 15) {
                return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(233,150,122)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(50,205,50)', 'rgb(255,69,0)', 'rgb(255,0,0)'];
            } else if (n_categories <= 18) {
                return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];
            } else {
                // If there are more than 25 categories, the interval layer will fall back to the 'null value' option
                return ['rgb(212,212,212)', 'rgb(128,128,128)', 'rgb(112,48,160)', 'rgb(230,184,183)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,102)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,150,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];
            }
        }

        /**
         * Find all of the unique tracks (a combination of name and ID information)
         * @param {Object} data
         * @param {String} [rgb_field] A field that contains an RGB value. Aimed at BED files with an itemRgb column
         * @private
         * @returns {Array} All [unique_id, label, color] pairs in data. The unique_id is the thing used to define groupings
         *  most unambiguously.
         */
        _generateCategoriesFromData(data, rgb_field) {
            const self = this;
            // Use the hard-coded legend if available (ignoring any mods on re-render)
            const legend = this._base_layout.legend;
            if (legend && legend.length) {
                return legend.map((item) => [item[this.layout.track_split_field], item.label, item.color]);
            }

            // Generate options from data, if no preset legend exists
            const unique_ids = {}; // make categories unique
            const categories = [];

            data.forEach((item) => {
                const id = item[self.layout.track_split_field];
                if (!Object.prototype.hasOwnProperty.call(unique_ids, id)) {
                    unique_ids[id] = null;
                    // If rgbfield is null, then the last entry is undefined/null as well
                    categories.push([id, item[this.layout.track_label_field], item[rgb_field]]);
                }
            });
            return categories;
        }
    }

    const intervals_tooltip_layout = {
        namespace: { 'intervals': 'intervals' },
        closable: false,
        show: { or: ['highlighted', 'selected'] },
        hide: { and: ['unhighlighted', 'unselected'] },
        html: '{{{{namespace[intervals]}}state_name|htmlescape}}<br>{{{{namespace[intervals]}}start|htmlescape}}-{{{{namespace[intervals]}}end|htmlescape}}',
    };

    const intervals_layer_layout =  {
        namespace: { 'intervals': 'intervals' },
        id: 'intervals',
        type: 'intervals',
        fields: ['{{namespace[intervals]}}start', '{{namespace[intervals]}}end', '{{namespace[intervals]}}state_id', '{{namespace[intervals]}}state_name', '{{namespace[intervals]}}itemRgb'],
        id_field: '{{namespace[intervals]}}start',  // FIXME: This is not a good D3 "are these datums redundant" ID for datasets with multiple intervals heavily overlapping
        start_field: '{{namespace[intervals]}}start',
        end_field: '{{namespace[intervals]}}end',
        track_split_field: '{{namespace[intervals]}}state_name',
        track_label_field: '{{namespace[intervals]}}state_name',
        split_tracks: false,
        always_hide_legend: true,
        color: [
            {
                // If present, an explicit color field will override any other option (and be used to auto-generate legend)
                field: '{{namespace[intervals]}}itemRgb',
                scale_function: 'to_rgb',
            },
            {
                // TODO: Consider changing this to stable_choice in the future, for more stable coloring
                field: '{{namespace[intervals]}}state_name',
                scale_function: 'categorical_bin',
                parameters: {
                    // Placeholder. Empty categories and values will automatically be filled in when new data loads.
                    categories: [],
                    values: [],
                    null_value: '#B8B8B8',
                },
            },
        ],
        legend: [], // Placeholder; auto-filled when data loads.
        behaviors: {
            onmouseover: [
                { action: 'set', status: 'highlighted' },
            ],
            onmouseout: [
                { action: 'unset', status: 'highlighted' },
            ],
            onclick: [
                { action: 'toggle', status: 'selected', exclusive: true },
            ],
            onshiftclick: [
                { action: 'toggle', status: 'selected' },
            ],
        },
        tooltip: intervals_tooltip_layout,
    };

    const intervals_panel_layout = {
        id: 'intervals',
        min_height: 50,
        height: 50,
        margin: { top: 25, right: 150, bottom: 5, left: 50 },
        toolbar: (function () {
            const l = LocusZoom.Layouts.get('toolbar', 'standard_panel', { unnamespaced: true });
            l.widgets.push({
                type: 'toggle_split_tracks',
                data_layer_id: 'intervals',
                position: 'right',
            });
            return l;
        })(),
        axes: {},
        interaction: {
            drag_background_to_pan: true,
            scroll_to_zoom: true,
            x_linked: true,
        },
        legend: {
            hidden: true,
            orientation: 'horizontal',
            origin: { x: 50, y: 0 },
            pad_from_bottom: 5,
        },
        data_layers: [intervals_layer_layout],
    };

    const intervals_plot_layout = {
        state: {},
        width: 800,
        responsive_resize: true,
        min_region_scale: 20000,
        max_region_scale: 1000000,
        toolbar: LocusZoom.Layouts.get('toolbar', 'standard_association', { unnamespaced: true }),
        panels: [
            LocusZoom.Layouts.get('panel', 'association'),
            LocusZoom.Layouts.merge({ unnamespaced: true, min_height: 120, height: 120 }, intervals_panel_layout),
            LocusZoom.Layouts.get('panel', 'genes'),
        ],
    };

    LocusZoom.Adapters.add('IntervalLZ', IntervalLZ);
    LocusZoom.DataLayers.add('intervals', LzIntervalsTrack);

    LocusZoom.Layouts.add('tooltip', 'standard_intervals', intervals_tooltip_layout);
    LocusZoom.Layouts.add('data_layer', 'intervals', intervals_layer_layout);
    LocusZoom.Layouts.add('panel', 'intervals', intervals_panel_layout);
    LocusZoom.Layouts.add('plot', 'interval_association', intervals_plot_layout);

    LocusZoom.ScaleFunctions.add('to_rgb', to_rgb);

    LocusZoom.Widgets.add('toggle_split_tracks', ToggleSplitTracks);
}

if (typeof LocusZoom !== 'undefined') {
    // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()
    // eslint-disable-next-line no-undef
    LocusZoom.use(install);
}


/* harmony default export */ __webpack_exports__["default"] = (install);


/***/ }),

/***/ "d3":
/*!*********************!*\
  !*** external "d3" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = d3;

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2V4dC9sei1pbnRlcnZhbHMtdHJhY2suanMiLCJ3ZWJwYWNrOi8vW25hbWVdL2V4dGVybmFsIFwiZDNcIiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlCOzs7QUFHekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTyxzQkFBc0IsVUFBVSxpQkFBaUIsVUFBVSxjQUFjLFlBQVk7QUFDdkksc0JBQXNCLFNBQVMsRUFBRSxNQUFNO0FBQ3ZDO0FB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MkVBQTJFLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0EscUNBQXFDLG1EQUFtRDtBQUN4RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdlLHNFQUFPLEVBQUM7Ozs7Ozs7Ozs7OztBQzNvQnZCLG9CIiwiZmlsZSI6ImV4dC9sei1pbnRlcnZhbHMtdHJhY2subWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9lc20vZXh0L2x6LWludGVydmFscy10cmFjay5qc1wiKTtcbiIsIi8qKlxuSW50ZXJ2YWwgYW5ub3RhdGlvbiB0cmFjayAoZm9yIGNocm9tYXRpbiBzdGF0ZSwgZXRjKS4gVXNlZnVsIGZvciBCRUQgZmlsZSBkYXRhIHdpdGggbm9uLW92ZXJsYXBwaW5nIGludGVydmFscy5cblRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIGNvcmUgTG9jdXNab29tIGxpYnJhcnksIGJ1dCBjYW4gYmUgaW5jbHVkZWQgYXMgYSBzdGFuZGFsb25lIGZpbGUuXG5cblRoZSBwYWdlIG11c3QgaW5jb3Jwb3JhdGUgYW5kIGxvYWQgYWxsIGxpYnJhcmllcyBiZWZvcmUgdGhpcyBmaWxlIGNhbiBiZSB1c2VkLCBpbmNsdWRpbmc6XG4gLSBWZW5kb3IgYXNzZXRzXG4gLSBMb2N1c1pvb21cbiBAbW9kdWxlXG4qL1xuXG5pbXBvcnQgKiBhcyBkMyBmcm9tICdkMyc7XG5cblxuLy8gQ29vcmRpbmF0ZXMgKHN0YXJ0LCBlbmQpIGFyZSBjYWNoZWQgdG8gZmFjaWxpdGF0ZSByZW5kZXJpbmdcbmNvbnN0IFhDUyA9IFN5bWJvbC5mb3IoJ2x6WENTJyk7XG5jb25zdCBZQ1MgPSBTeW1ib2wuZm9yKCdsellDUycpO1xuY29uc3QgWENFID0gU3ltYm9sLmZvcignbHpYQ0UnKTtcbmNvbnN0IFlDRSA9IFN5bWJvbC5mb3IoJ2x6WUNFJyk7XG5cblxuZnVuY3Rpb24gaW5zdGFsbCAoTG9jdXNab29tKSB7XG4gICAgY29uc3QgQmFzZUFwaUFkYXB0ZXIgPSBMb2N1c1pvb20uQWRhcHRlcnMuZ2V0KCdCYXNlQXBpQWRhcHRlcicpO1xuICAgIGNvbnN0IF9CdXR0b24gPSBMb2N1c1pvb20uV2lkZ2V0cy5nZXQoJ19CdXR0b24nKTtcbiAgICBjb25zdCBfQmFzZVdpZGdldCA9IExvY3VzWm9vbS5XaWRnZXRzLmdldCgnQmFzZVdpZGdldCcpO1xuXG4gICAgLyoqXG4gICAgICogRGF0YSBTb3VyY2UgZm9yIEludGVydmFsIEFubm90YXRpb24gRGF0YSAoZS5nLiBCRUQgVHJhY2tzKSwgYXMgZmV0Y2hlZCBmcm9tIHRoZSBMb2N1c1pvb20gQVBJIHNlcnZlciAob3IgY29tcGF0aWJsZSlcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgSW50ZXJ2YWxMWiBleHRlbmRzIEJhc2VBcGlBZGFwdGVyIHtcbiAgICAgICAgZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBjaGFpbi5oZWFkZXIuYmVkdHJhY2tzb3VyY2UgfHwgdGhpcy5wYXJhbXMuc291cmNlO1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBgP2ZpbHRlcj1pZCBpbiAke3NvdXJjZX0gYW5kIGNocm9tb3NvbWUgZXEgJyR7c3RhdGUuY2hyfScgYW5kIHN0YXJ0IGxlICR7c3RhdGUuZW5kfSBhbmQgZW5kIGdlICR7c3RhdGUuc3RhcnR9YDtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLnVybH0ke3F1ZXJ5fWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdXR0b24gdG8gdG9nZ2xlIHNwbGl0IHRyYWNrc1xuICAgICAqL1xuICAgIGNsYXNzIFRvZ2dsZVNwbGl0VHJhY2tzIGV4dGVuZHMgX0Jhc2VXaWRnZXQge1xuICAgICAgICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICBpZiAoIWxheW91dC5kYXRhX2xheWVyX2lkKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0LmRhdGFfbGF5ZXJfaWQgPSAnaW50ZXJ2YWxzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnRfcGFuZWwuZGF0YV9sYXllcnNbbGF5b3V0LmRhdGFfbGF5ZXJfaWRdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb2dnbGUgc3BsaXQgdHJhY2tzIHdpZGdldCBzcGVjaWZpZXMgYW4gaW52YWxpZCBkYXRhIGxheWVyIElEJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGUoKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhX2xheWVyID0gdGhpcy5wYXJlbnRfcGFuZWwuZGF0YV9sYXllcnNbdGhpcy5sYXlvdXQuZGF0YV9sYXllcl9pZF07XG4gICAgICAgICAgICBjb25zdCBodG1sID0gZGF0YV9sYXllci5sYXlvdXQuc3BsaXRfdHJhY2tzID8gJ01lcmdlIFRyYWNrcycgOiAnU3BsaXQgVHJhY2tzJztcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1dHRvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLnNldEh0bWwoaHRtbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uc2hvdygpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uID0gbmV3IF9CdXR0b24odGhpcylcbiAgICAgICAgICAgICAgICAgICAgLnNldENvbG9yKHRoaXMubGF5b3V0LmNvbG9yKVxuICAgICAgICAgICAgICAgICAgICAuc2V0SHRtbChodG1sKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VGl0bGUoJ1RvZ2dsZSB3aGV0aGVyIHRyYWNrcyBhcmUgc3BsaXQgYXBhcnQgb3IgbWVyZ2VkIHRvZ2V0aGVyJylcbiAgICAgICAgICAgICAgICAgICAgLnNldE9uY2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YV9sYXllci50b2dnbGVTcGxpdFRyYWNrcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IHRoZSB0aW1lb3V0IGNhbGxzIHRvIHNjYWxlIGFuZCBwb3NpdGlvbiAoYmVsb3cpIGNhdXNlIGZ1bGwgfjUgYWRkaXRpb25hbCByZS1yZW5kZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgSWYgd2UgY2FuIHJlbW92ZSB0aGVzZSBpdCB3aWxsIGdyZWF0bHkgc3BlZWQgdXAgcmUtcmVuZGVyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGtleSBwcm9ibGVtIGhlcmUgaXMgdGhhdCB0aGUgaGVpZ2h0IGlzIGFwcGFyZW50bHkgbm90IGtub3duIGluIGFkdmFuY2UgYW5kIGlzIGRldGVybWluZWQgYWZ0ZXIgcmUtcmVuZGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NhbGVfdGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNjYWxlX3RpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FsZV90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGFuZWwuc2NhbGVIZWlnaHRUb0RhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9wbG90LnBvc2l0aW9uUGFuZWxzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgdmFsdWUgXCJcInJyLGdnLGJiXCIgKGlmIGdpdmVuKSB0byBhIGNzcy1mcmllbmRseSBjb2xvciBzdHJpbmc6IFwicmdiKHJyLGdnLGJiKVwiLlxuICAgICAqIFRoaXMgaXMgdGFpbG9yZWQgc3BlY2lmaWNhbGx5IHRvIHRoZSBjb2xvciBzcGVjaWZpY2F0aW9uIGZvcm1hdCBlbWJyYWNlZCBieSB0aGUgQkVEIGZpbGUgc3RhbmRhcmQuXG4gICAgICogQGZ1bmN0aW9uIHRvX3JnYlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbWV0ZXJzIFRoaXMgZnVuY3Rpb24gaGFzIG5vIGRlZmluZWQgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmd8bnVsbH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gcmdiXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9fcmdiKHBhcmFtZXRlcnMsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IGByZ2IoJHt2YWx1ZX0pYCA6IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmYXVsdF9sYXlvdXQgPSB7XG4gICAgICAgIHN0YXJ0X2ZpZWxkOiAnc3RhcnQnLFxuICAgICAgICBlbmRfZmllbGQ6ICdlbmQnLFxuICAgICAgICB0cmFja19sYWJlbF9maWVsZDogJ3N0YXRlX25hbWUnLCAvLyBVc2VkIHRvIGxhYmVsIGl0ZW1zIG9uIHRoZSB5LWF4aXNcbiAgICAgICAgLy8gVXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSB0cmFja3MgZm9yIGNvbG9yaW5nLiBUaGlzIHRlbmRzIHRvIGxlYWQgdG8gbW9yZSBzdGFibGUgY29sb3Jpbmcvc29ydGluZ1xuICAgICAgICAvLyAgdGhhbiB1c2luZyB0aGUgbGFiZWwgZmllbGQtIGVnLCBzdGF0ZV9pZHMgYWxsb3cgdXMgdG8gc2V0IGdsb2JhbCBjb2xvcnMgYWNyb3NzIHRoZSBlbnRpcmUgZGF0YXNldCxcbiAgICAgICAgLy8gIG5vdCBqdXN0IGNob29zZSB1bmlxdWUgY29sb3JzIHdpdGhpbiBhIHBhcnRpY3VsYXIgbmFycm93IHJlZ2lvbi4gKHdoZXJlIGNoYW5naW5nIHJlZ2lvbiBtaWdodCBsZWFkIHRvIG1vcmVcbiAgICAgICAgLy8gIGNhdGVnb3JpZXMgYW5kIGRpZmZlcmVudCBjb2xvcnMpXG4gICAgICAgIHRyYWNrX3NwbGl0X2ZpZWxkOiAnc3RhdGVfaWQnLFxuICAgICAgICB0cmFja19zcGxpdF9vcmRlcjogJ0RFU0MnLFxuICAgICAgICB0cmFja19zcGxpdF9sZWdlbmRfdG9feV9heGlzOiAyLFxuICAgICAgICBzcGxpdF90cmFja3M6IHRydWUsXG4gICAgICAgIHRyYWNrX2hlaWdodDogMTUsXG4gICAgICAgIHRyYWNrX3ZlcnRpY2FsX3NwYWNpbmc6IDMsXG4gICAgICAgIGJvdW5kaW5nX2JveF9wYWRkaW5nOiAyLFxuICAgICAgICBhbHdheXNfaGlkZV9sZWdlbmQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogJyNCOEI4QjgnLFxuICAgICAgICBmaWxsX29wYWNpdHk6IDEsXG4gICAgICAgIHRvb2x0aXBfcG9zaXRpb25pbmc6ICd2ZXJ0aWNhbCcsXG4gICAgfTtcblxuXG4gICAgLyoqXG4gICAgICogSW50ZXJ2YWxzIERhdGEgTGF5ZXJcbiAgICAgKiBJbXBsZW1lbnRzIGEgZGF0YSBsYXllciB0aGF0IHdpbGwgcmVuZGVyIGludGVydmFsIGFubm90YXRpb24gdHJhY2tzIChpbnRlcnZhbHMgbXVzdCBwcm92aWRlIHN0YXJ0IGFuZCBlbmQgdmFsdWVzKVxuICAgICAqL1xuICAgIGNvbnN0IEJhc2VMYXllciA9IExvY3VzWm9vbS5EYXRhTGF5ZXJzLmdldCgnQmFzZURhdGFMYXllcicpO1xuICAgIGNsYXNzIEx6SW50ZXJ2YWxzVHJhY2sgZXh0ZW5kcyBCYXNlTGF5ZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICAgICAgICAgIExvY3VzWm9vbS5MYXlvdXRzLm1lcmdlKGxheW91dCwgZGVmYXVsdF9sYXlvdXQpO1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzX2NhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2NhdGVnb3JpZXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgICAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXNub2Rlc19ncm91cCA9IHRoaXMuc3ZnLmdyb3VwLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LWRhdGEtbGF5ZXItaW50ZXJ2YWxzIGx6LWRhdGEtbGF5ZXItaW50ZXJ2YWxzLXN0YXR1c25vZGUnKTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFub2Rlc19ncm91cCA9IHRoaXMuc3ZnLmdyb3VwLmFwcGVuZCgnZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU3BsaXQgZGF0YSBpbnRvIHRyYWNrcyBzdWNoIHRoYXQgYW55dGhpbmcgd2l0aCBhIGNvbW1vbiBncm91cGluZyBmaWVsZCBpcyBpbiB0aGUgc2FtZSB0cmFja1xuICAgICAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAgICAgKiBAcmV0dXJuIHt1bmtub3duW119XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfYXJyYW5nZVRyYWNrU3BsaXQoZGF0YSkge1xuICAgICAgICAgICAgY29uc3Qge3RyYWNrX3NwbGl0X2ZpZWxkfSA9IHRoaXMubGF5b3V0O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBkYXRhLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtX2tleSA9IGl0ZW1bdHJhY2tfc3BsaXRfZmllbGRdO1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgaXRlbV9rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpdGVtX2tleV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W2l0ZW1fa2V5XS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwbGl0IGRhdGEgaW50byByb3dzIHVzaW5nIGEgc2ltcGxlIGdyZWVkeSBhbGdvcml0aG0gc3VjaCB0aGF0IG5vIHR3byBpdGVtcyBvdmVybGFwIChzaGFyZSBzYW1lIGludGVydmFsKVxuICAgICAgICAgKiBBc3N1bWVzIHRoYXQgdGhlIGRhdGEgYXJlIHNvcnRlZCBzbyBpdGVtMS5zdGFydCBhbHdheXMgPD0gaXRlbTIuc3RhcnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIGFsc28gc2ltcGx5IHJldHVybiBhbGwgZGF0YSBvbiBhIHNpbmdsZSByb3cuIFRoaXMgZnVuY3Rpb25hbGl0eSBtYXkgYmVjb21lIGNvbmZpZ3VyYWJsZVxuICAgICAgICAgKiAgaW4gdGhlIGZ1dHVyZSBidXQgZm9yIG5vdyByZWZsZWN0cyBhIGxhY2sgb2YgY2xhcml0eSBpbiB0aGUgcmVxdWlyZW1lbnRzL3NwZWMuIFRoZSBjb2RlIHRvIHNwbGl0XG4gICAgICAgICAqICBvdmVybGFwcGluZyBpdGVtcyBpcyBwcmVzZW50IGJ1dCBtYXkgbm90IHNlZSBkaXJlY3QgdXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgX2FycmFuZ2VUcmFja3NMaW5lYXIoZGF0YSwgYWxsb3dfb3ZlcmxhcCA9IHRydWUpIHtcbiAgICAgICAgICAgIGlmIChhbGxvd19vdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgb3ZlcmxhcCBpcyBhbGxvd2VkLCB0aGVuIGFsbCB0aGUgZGF0YSBjYW4gbGl2ZSBvbiBhIHNpbmdsZSByb3dcbiAgICAgICAgICAgICAgICByZXR1cm4gW2RhdGFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBU1NVTVBUSU9OOiBEYXRhIGlzIGdpdmVuIHRvIHVzIGFscmVhZHkgc29ydGVkIGJ5IHN0YXJ0IHBvc2l0aW9uIHRvIGZhY2lsaXRhdGUgZ3JvdXBpbmcuXG4gICAgICAgICAgICAvLyBXZSBkbyBub3Qgc29ydCBoZXJlIGJlY2F1c2UgSlMgXCJzb3J0XCIgaXMgbm90IHN0YWJsZS0gaWYgdGhlcmUgYXJlIG1hbnkgaW50ZXJ2YWxzIHRoYXQgb3ZlcmxhcCwgdGhlbiB3ZVxuICAgICAgICAgICAgLy8gICBjYW4gZ2V0IGRpZmZlcmVudCBsYXlvdXRzIChudW1iZXIvb3JkZXIgb2Ygcm93cykgb24gZWFjaCBjYWxsIHRvIFwicmVuZGVyXCIuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gQXQgcHJlc2VudCwgd2UgZGVjaWRlIGhvdyB0byB1cGRhdGUgdGhlIHktYXhpcyBiYXNlZCBvbiB3aGV0aGVyIGN1cnJlbnQgYW5kIGZvcm1lciBudW1iZXIgb2Ygcm93cyBhcmVcbiAgICAgICAgICAgIC8vICB0aGUgc2FtZS4gQW4gdW5zdGFibGUgc29ydCBsZWFkcyB0byBsYXlvdXQgdGhyYXNoaW5nL3RvbyBtYW55IHJlLXJlbmRlcnMuIEZJWE1FOiBkb24ndCByZWx5IG9uIGNvdW50c1xuICAgICAgICAgICAgY29uc3Qge3N0YXJ0X2ZpZWxkLCBlbmRfZmllbGR9ID0gdGhpcy5sYXlvdXQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGdyb3VwZWRfZGF0YSA9IFtbXV07IC8vIFByZXZlbnQgdHdvIGl0ZW1zIGZyb20gY29sbGlkaW5nIGJ5IHJlbmRlcmluZyB0aGVtIHRvIGRpZmZlcmVudCByb3dzLCBsaWtlIGdlbmVzXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cGVkX2RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCByb3dzIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3dfdG9fdGVzdCA9IGdyb3VwZWRfZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdF9pdGVtID0gcm93X3RvX3Rlc3Rbcm93X3RvX3Rlc3QubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIC8vIFNvbWUgcHJvZ3JhbXMgcmVwb3J0IG9wZW4gaW50ZXJ2YWxzLCBlZyAwLTEsMS0yLDItMzsgdGhlc2UgcG9pbnRzIGFyZSBub3QgY29uc2lkZXJlZCB0byBvdmVybGFwIChoZW5jZSB0aGUgdGVzdCBpc24ndCBcIjw9XCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc19vdmVybGFwID0gbGFzdF9pdGVtICYmIChpdGVtW3N0YXJ0X2ZpZWxkXSA8IGxhc3RfaXRlbVtlbmRfZmllbGRdKSAmJiAobGFzdF9pdGVtW3N0YXJ0X2ZpZWxkXSA8IGl0ZW1bZW5kX2ZpZWxkXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzX292ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG92ZXJsYXAsIGFkZCBpdGVtIHRvIGN1cnJlbnQgcm93LCBhbmQgbW92ZSBvbiB0byB0aGUgbmV4dCBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dfdG9fdGVzdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXRlbSB3b3VsZCBjb2xsaWRlIG9uIGFsbCBleGlzdGluZyByb3dzLCBjcmVhdGUgYSBuZXcgcm93XG4gICAgICAgICAgICAgICAgZ3JvdXBlZF9kYXRhLnB1c2goW2l0ZW1dKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwZWRfZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbm5vdGF0ZSBlYWNoIGl0ZW0gd2l0aCB0aGUgdHJhY2sgbnVtYmVyLCBhbmQgcmV0dXJuLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdFtdfWRhdGFcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHJldHVybiBbU3RyaW5nW10sIE9iamVjdFtdXSBSZXR1cm4gdGhlIGNhdGVnb3JpZXMgYW5kIHRoZSBkYXRhIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBfYXNzaWduVHJhY2tzKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIEZsYXR0ZW4gdGhlIGdyb3VwZWQgZGF0YS5cbiAgICAgICAgICAgIGNvbnN0IHt4X3NjYWxlfSA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgY29uc3Qge3N0YXJ0X2ZpZWxkLCBlbmRfZmllbGQsIGJvdW5kaW5nX2JveF9wYWRkaW5nLCB0cmFja19oZWlnaHR9ID0gdGhpcy5sYXlvdXQ7XG5cbiAgICAgICAgICAgIGNvbnN0IGdyb3VwZWRfZGF0YSA9IHRoaXMubGF5b3V0LnNwbGl0X3RyYWNrcyA/IHRoaXMuX2FycmFuZ2VUcmFja1NwbGl0KGRhdGEpIDogdGhpcy5fYXJyYW5nZVRyYWNrc0xpbmVhcihkYXRhLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBPYmplY3Qua2V5cyhncm91cGVkX2RhdGEpO1xuICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LnRyYWNrX3NwbGl0X29yZGVyID09PSAnREVTQycpIHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKChrZXksIHJvd19pbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGdyb3VwZWRfZGF0YVtrZXldO1xuICAgICAgICAgICAgICAgIHJvdy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bWENTXSA9IHhfc2NhbGUoaXRlbVtzdGFydF9maWVsZF0pO1xuICAgICAgICAgICAgICAgICAgICBpdGVtW1hDRV0gPSB4X3NjYWxlKGl0ZW1bZW5kX2ZpZWxkXSk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bWUNTXSA9IHJvd19pbmRleCAqIHRoaXMuZ2V0VHJhY2tIZWlnaHQoKSArIGJvdW5kaW5nX2JveF9wYWRkaW5nO1xuICAgICAgICAgICAgICAgICAgICBpdGVtW1lDRV0gPSBpdGVtW1lDU10gKyB0cmFja19oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSByb3cgSUQsIHNvIHRoYXQgY2xpY2tpbmcgb24gYSBwb2ludCBjYW4gZmluZCB0aGUgcmlnaHQgc3RhdHVzIG5vZGUgKGJpZyBoaWdobGlnaHQgYm94KVxuICAgICAgICAgICAgICAgICAgICBpdGVtLnRyYWNrID0gcm93X2luZGV4O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBXZSdyZSBtdXRhdGluZyBlbGVtZW50cyBvZiB0aGUgb3JpZ2luYWwgZGF0YSBhcnJheSBhcyBhIHNpZGUgZWZmZWN0OiB0aGUgcmV0dXJuIHZhbHVlIGhlcmUgaXNcbiAgICAgICAgICAgIC8vICBpbnRlcmNoYW5nZWFibGUgd2l0aCBgdGhpcy5kYXRhYCBmb3Igc3Vic2VxdWVudCB1c2FnZXNcbiAgICAgICAgICAgIC8vIFRPRE86IENhbiByZXBsYWNlIHRoaXMgd2l0aCBhcnJheS5mbGF0IG9uY2UgcG9seWZpbGwgc3VwcG9ydCBpbXByb3Zlc1xuICAgICAgICAgICAgcmV0dXJuIFtjYXRlZ29yaWVzLCBPYmplY3QudmFsdWVzKGdyb3VwZWRfZGF0YSkucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjLmNvbmNhdCh2YWwpLCBbXSldO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gd2UgYXJlIGluIFwic3BsaXQgdHJhY2tzIG1vZGVcIiwgaXQncyBjb252ZW5pZW50IHRvIHdyYXAgYWxsIGluZGl2aWR1YWwgYW5ub3RhdGlvbnMgd2l0aCBhIHNoYXJlZFxuICAgICAgICAgKiAgaGlnaGxpZ2h0IGJveCB0aGF0IHdyYXBzIGV2ZXJ5dGhpbmcgb24gdGhhdCByb3cuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgZG9uZSBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBcInNldEVsZW1lbnRTdGF0dXNcIiBjb2RlLCBpZiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBub24tbnVsbCB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBUbyBkZWZpbmUgc2hhcmVkIGhpZ2hsaWdodGluZyBvbiB0aGUgdHJhY2sgc3BsaXQgZmllbGQgZGVmaW5lIHRoZSBzdGF0dXMgbm9kZSBpZCBvdmVycmlkZVxuICAgICAgICAgKiB0byBnZW5lcmF0ZSBhbiBJRCBjb21tb24gdG8gdGhlIHRyYWNrIHdoZW4gd2UncmUgYWN0aXZlbHkgc3BsaXR0aW5nIGRhdGEgb3V0IHRvIHNlcGFyYXRlIHRyYWNrc1xuICAgICAgICAgKiBAb3ZlcnJpZGVcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldEVsZW1lbnRTdGF0dXNOb2RlSWQoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LnNwbGl0X3RyYWNrcykge1xuICAgICAgICAgICAgICAgIC8vIERhdGEgbm9kZXMgYXJlIGJvdW5kIHRvIGRhdGEgb2JqZWN0cywgYnV0IHRoZSBcInN0YXR1c19ub2Rlc1wiIHNlbGVjdGlvbiBpcyBib3VuZCB0byBudW1lcmljIHJvdyBJRHNcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjayA9IHR5cGVvZiBlbGVtZW50ID09PSAnb2JqZWN0JyA/IGVsZW1lbnQudHJhY2sgOiBlbGVtZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2UgPSBgJHt0aGlzLmdldEJhc2VJZCgpfS1zdGF0dXNub2RlLSR7dHJhY2t9YDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZS5yZXBsYWNlKC9bXlxcd10vZywgJ18nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEluIG1lcmdlZCB0cmFja3MgbW9kZSwgdGhlcmUgaXMgbm8gc2VwYXJhdGUgc3RhdHVzIG5vZGVcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHN1bSBsYXlvdXQgdmFsdWVzIHRvIGRlcml2ZSB0b3RhbCBoZWlnaHQgZm9yIGEgc2luZ2xlIGludGVydmFsIHRyYWNrXG4gICAgICAgIGdldFRyYWNrSGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LnRyYWNrX2hlaWdodFxuICAgICAgICAgICAgICAgICsgdGhpcy5sYXlvdXQudHJhY2tfdmVydGljYWxfc3BhY2luZ1xuICAgICAgICAgICAgICAgICsgKDIgKiB0aGlzLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb2RpZnkgdGhlIGxheW91dCBhcyBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoYXQgYXBwcm9wcmlhdGUgY29sb3IsIGxhYmVsLCBhbmQgbGVnZW5kIG9wdGlvbnMgYXJlIGF2YWlsYWJsZVxuICAgICAgICAvLyBFdmVuIHdoZW4gbm90IGRpc3BsYXllZCwgdGhlIGxlZ2VuZCBpcyB1c2VkIHRvIGdlbmVyYXRlIHRoZSB5LWF4aXMgdGlja3NcbiAgICAgICAgX2FwcGx5TGF5b3V0T3B0aW9ucygpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgYmFzZV9sYXlvdXQgPSB0aGlzLl9iYXNlX2xheW91dDtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcl9sYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VfY29sb3Jfc2NhbGUgPSBiYXNlX2xheW91dC5jb2xvci5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uc2NhbGVfZnVuY3Rpb24gJiYgaXRlbS5zY2FsZV9mdW5jdGlvbiA9PT0gJ2NhdGVnb3JpY2FsX2Jpbic7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yX3NjYWxlID0gcmVuZGVyX2xheW91dC5jb2xvci5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uc2NhbGVfZnVuY3Rpb24gJiYgaXRlbS5zY2FsZV9mdW5jdGlvbiA9PT0gJ2NhdGVnb3JpY2FsX2Jpbic7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghYmFzZV9jb2xvcl9zY2FsZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGJlIGEgcGxhY2Vob2xkZXIgKGVtcHR5IGNhdGVnb3JpZXMgJiB2YWx1ZXMpLCBidXQgaXQgbmVlZHMgdG8gYmUgdGhlcmVcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVydmFsIHRyYWNrcyBtdXN0IGRlZmluZSBhIGBjYXRlZ29yaWNhbF9iaW5gIGNvbG9yIHNjYWxlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGhhc19jb2xvcnMgPSBiYXNlX2NvbG9yX3NjYWxlLnBhcmFtZXRlcnMuY2F0ZWdvcmllcy5sZW5ndGggJiYgYmFzZV9jb2xvcl9zY2FsZS5wYXJhbWV0ZXJzLnZhbHVlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoYXNfbGVnZW5kID0gYmFzZV9sYXlvdXQubGVnZW5kICYmIGJhc2VfbGF5b3V0LmxlZ2VuZC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmICghIWhhc19jb2xvcnMgXiAhIWhhc19sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBhbGxvdyBjb2xvciBPUiBsZWdlbmQgdG8gYmUgc2V0IG1hbnVhbGx5LiBJdCBtdXN0IGJlIGJvdGgsIG9yIG5laXRoZXIuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUbyB1c2UgYSBtYW51YWxseSBzcGVjaWZpZWQgY29sb3Igc2NoZW1lLCBib3RoIGNvbG9yIGFuZCBsZWdlbmQgb3B0aW9ucyBtdXN0IGJlIHNldC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSGFydmVzdCBhbnkgaW5mb3JtYXRpb24gYWJvdXQgYW4gZXhwbGljaXQgY29sb3IgZmllbGQgdGhhdCBzaG91bGQgYmUgY29uc2lkZXJlZCB3aGVuIGdlbmVyYXRpbmcgY29sb3JzXG4gICAgICAgICAgICBjb25zdCByZ2Jfb3B0aW9uID0gYmFzZV9sYXlvdXQuY29sb3IuZmluZChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnNjYWxlX2Z1bmN0aW9uICYmIGl0ZW0uc2NhbGVfZnVuY3Rpb24gPT09ICd0b19yZ2InO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZ2JfZmllbGQgPSByZ2Jfb3B0aW9uICYmIHJnYl9vcHRpb24uZmllbGQ7XG5cbiAgICAgICAgICAgIC8vIEF1dG8tZ2VuZXJhdGUgbGVnZW5kIGJhc2VkIG9uIGRhdGFcbiAgICAgICAgICAgIGNvbnN0IGtub3duX2NhdGVnb3JpZXMgPSB0aGlzLl9nZW5lcmF0ZUNhdGVnb3JpZXNGcm9tRGF0YSh0aGlzLmRhdGEsIHJnYl9maWVsZCk7IC8vIFtpZCwgbGFiZWwsIGl0ZW1SZ2JdIGl0ZW1zXG5cbiAgICAgICAgICAgIGlmICghaGFzX2NvbG9ycyAmJiAhaGFzX2xlZ2VuZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIG5vIGNvbG9yIHNjaGVtZSBwcmUtZGVmaW5lZCwgdGhlbiBtYWtlIGEgY29sb3Igc2NoZW1lIHRoYXQgaXMgYXBwcm9wcmlhdGUgYW5kIGFwcGx5IHRvIHRoZSBwbG90XG4gICAgICAgICAgICAgICAgLy8gVGhlIGxlZ2VuZCBtdXN0IG1hdGNoIHRoZSBjb2xvciBzY2hlbWUuIElmIHdlIGdlbmVyYXRlIG9uZSwgdGhlbiB3ZSBtdXN0IGdlbmVyYXRlIGJvdGguXG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb2xvcnMgPSB0aGlzLl9tYWtlQ29sb3JTY2hlbWUoa25vd25fY2F0ZWdvcmllcyk7XG4gICAgICAgICAgICAgICAgY29sb3Jfc2NhbGUucGFyYW1ldGVycy5jYXRlZ29yaWVzID0ga25vd25fY2F0ZWdvcmllcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1bMF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29sb3Jfc2NhbGUucGFyYW1ldGVycy52YWx1ZXMgPSBjb2xvcnM7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dC5sZWdlbmQgPSBrbm93bl9jYXRlZ29yaWVzLm1hcChmdW5jdGlvbiAocGFpciwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWQgPSBwYWlyWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYWJlbCA9IHBhaXJbMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1fY29sb3IgPSBjb2xvcl9zY2FsZS5wYXJhbWV0ZXJzLnZhbHVlc1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB7IHNoYXBlOiAncmVjdCcsIHdpZHRoOiA5LCBsYWJlbDogbGFiZWwsIGNvbG9yOiBpdGVtX2NvbG9yIH07XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bc2VsZi5sYXlvdXQudHJhY2tfc3BsaXRfZmllbGRdID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW1wbGVtZW50IHRoZSBtYWluIHJlbmRlciBmdW5jdGlvblxuICAgICAgICByZW5kZXIoKSB7XG4gICAgICAgICAgICAvLy8vIEF1dG9nZW5lcmF0ZSBsYXlvdXQgb3B0aW9ucyBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5TGF5b3V0T3B0aW9ucygpO1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGFwcHJvcHJpYXRlIGxheW91dCBmb3IgdHJhY2tzLiBTdG9yZSB0aGUgcHJldmlvdXMgY2F0ZWdvcmllcyAoeSBheGlzIHRpY2tzKSB0byBkZWNpZGVcbiAgICAgICAgICAgIC8vICAgd2hldGhlciB0aGUgYXhpcyBuZWVkcyB0byBiZSByZS1yZW5kZXJlZC5cbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzX2NhdGVnb3JpZXMgPSB0aGlzLl9jYXRlZ29yaWVzO1xuICAgICAgICAgICAgY29uc3QgW2NhdGVnb3JpZXMsIGFzc2lnbmVkX2RhdGFdID0gdGhpcy5fYXNzaWduVHJhY2tzKHRoaXMuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9jYXRlZ29yaWVzID0gY2F0ZWdvcmllcztcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGVnZW5kIGF4aXMgaWYgdGhlIG51bWJlciBvZiB0aWNrcyBjaGFuZ2VkXG4gICAgICAgICAgICBjb25zdCBsYWJlbHNfY2hhbmdlZCA9ICFjYXRlZ29yaWVzLmV2ZXJ5KCAoaXRlbSwgaW5kZXgpID0+IGl0ZW0gPT09IHRoaXMuX3ByZXZpb3VzX2NhdGVnb3JpZXNbaW5kZXhdKTtcbiAgICAgICAgICAgIGlmIChsYWJlbHNfY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3BsaXRUcmFja0F4aXMoY2F0ZWdvcmllcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSBmaWx0ZXJzIHRvIG9ubHkgcmVuZGVyIGEgc3BlY2lmaWVkIHNldCBvZiBwb2ludHMuIEhpZGRlbiBmaWVsZHMgd2lsbCBzdGlsbCBiZSBnaXZlbiBzcGFjZSB0byByZW5kZXIsIGJ1dCBub3Qgc2hvd24uXG4gICAgICAgICAgICBjb25zdCB0cmFja19kYXRhID0gdGhpcy5fYXBwbHlGaWx0ZXJzKGFzc2lnbmVkX2RhdGEpO1xuXG4gICAgICAgICAgICAvLyBDbGVhciBiZWZvcmUgZXZlcnkgcmVuZGVyIHNvIHRoYXQsIGVnLCBoaWdobGlnaHRpbmcgZG9lc24ndCBwZXJzaXN0IGlmIHdlIGxvYWQgYSByZWdpb24gd2l0aCBkaWZmZXJlbnRcbiAgICAgICAgICAgIC8vICBjYXRlZ29yaWVzIChyb3cgMiBtaWdodCBiZSBhIGRpZmZlcmVudCBjYXRlZ29yeSBhbmQgaXQncyBjb25mdXNpbmcgaWYgdGhlIHJvdyBzdGF5cyBoaWdobGlnaHRlZCBidXQgY2hhbmdlcyBtZWFuaW5nKVxuICAgICAgICAgICAgLy8gSGlnaGxpZ2h0aW5nIHdpbGwgYXV0b21hdGljYWxseSBnZXQgYWRkZWQgYmFjayBpZiBpdCBhY3R1YWxseSBtYWtlcyBzZW5zZSwgY291cnRlc3kgb2Ygc2V0RWxlbWVudFN0YXR1cyxcbiAgICAgICAgICAgIC8vICBpZiBhIHNlbGVjdGVkIGl0ZW0gaXMgc3RpbGwgaW4gdmlldyBhZnRlciB0aGUgbmV3IHJlZ2lvbiBsb2Fkcy5cbiAgICAgICAgICAgIHRoaXMuX3N0YXR1c25vZGVzX2dyb3VwLnNlbGVjdEFsbCgncmVjdCcpXG4gICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAvLyBSZXNlbGVjdCBpbiBvcmRlciB0byBhZGQgbmV3IGRhdGFcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c19ub2RlcyA9IHRoaXMuX3N0YXR1c25vZGVzX2dyb3VwLnNlbGVjdEFsbCgncmVjdCcpXG4gICAgICAgICAgICAgICAgLmRhdGEoZDMucmFuZ2UoY2F0ZWdvcmllcy5sZW5ndGgpKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LnNwbGl0X3RyYWNrcykge1xuICAgICAgICAgICAgICAgIC8vIFN0YXR1cyBub2RlczogYSBiaWcgaGlnaGxpZ2h0IGJveCBhcm91bmQgYWxsIGl0ZW1zIG9mIHRoZSBzYW1lIHR5cGUuIFVzZWQgaW4gc3BsaXQgdHJhY2tzIG1vZGUsXG4gICAgICAgICAgICAgICAgLy8gIGJlY2F1c2UgZXZlcnl0aGluZyBvbiB0aGUgc2FtZSByb3cgaXMgdGhlIHNhbWUgY2F0ZWdvcnkgYW5kIGEgZ3JvdXAgbWFrZXMgc2Vuc2VcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgbm8gc3RhdHVzIG5vZGVzIGluIG1lcmdlZCBtb2RlLCBiZWNhdXNlIHRoZSBzYW1lIHJvdyBjb250YWlucyBtYW55IGtpbmRzIG9mIHRoaW5nc1xuXG4gICAgICAgICAgICAgICAgLy8gU3RhdHVzIG5vZGVzIGFyZSAxIHBlciByb3csIHNvIFwiZGF0YVwiIGNhbiBqdXN0IGJlIGEgZHVtbXkgbGlzdCBvZiBwb3NzaWJsZSByb3cgSURzXG4gICAgICAgICAgICAgICAgLy8gRWFjaCBzdGF0dXMgbm9kZSBpcyBhIGJveCB0aGF0IHJ1bnMgdGhlIGxlbmd0aCBvZiB0aGUgcGFuZWwgYW5kIHJlY2VpdmVzIGEgc3BlY2lhbCBcImNvbG9yZWQgYm94XCIgY3NzXG4gICAgICAgICAgICAgICAgLy8gIHN0eWxlIHdoZW4gc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldFRyYWNrSGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgc3RhdHVzX25vZGVzLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1kYXRhX2xheWVyLWludGVydmFscyBsei1kYXRhX2xheWVyLWludGVydmFscy1zdGF0dXNub2RlIGx6LWRhdGFfbGF5ZXItaW50ZXJ2YWxzLXNoYXJlZCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyeCcsIHRoaXMubGF5b3V0LmJvdW5kaW5nX2JveF9wYWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigncnknLCB0aGlzLmxheW91dC5ib3VuZGluZ19ib3hfcGFkZGluZylcbiAgICAgICAgICAgICAgICAgICAgLm1lcmdlKHN0YXR1c19ub2RlcylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2lkJywgKGQpID0+IHRoaXMuZ2V0RWxlbWVudFN0YXR1c05vZGVJZChkKSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gnLCAwKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigneScsIChkKSA9PiAoZCAqIGhlaWdodCkpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHRoaXMucGFyZW50LmxheW91dC5jbGlwYXJlYS53aWR0aClcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIGhlaWdodCAtIHRoaXMubGF5b3V0LnRyYWNrX3ZlcnRpY2FsX3NwYWNpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdHVzX25vZGVzLmV4aXQoKVxuICAgICAgICAgICAgICAgIC5yZW1vdmUoKTtcblxuICAgICAgICAgICAgLy8gRHJhdyByZWN0YW5nbGVzIGZvciB0aGUgZGF0YSAoaW50ZXJ2YWxzKVxuICAgICAgICAgICAgY29uc3QgZGF0YV9ub2RlcyA9IHRoaXMuX2RhdGFub2Rlc19ncm91cC5zZWxlY3RBbGwoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5kYXRhKHRyYWNrX2RhdGEsIChkKSA9PiBkW3RoaXMubGF5b3V0LmlkX2ZpZWxkXSk7XG5cbiAgICAgICAgICAgIGRhdGFfbm9kZXMuZW50ZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgIC5tZXJnZShkYXRhX25vZGVzKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiB0aGlzLmdldEVsZW1lbnRJZChkKSlcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIChkKSA9PiBkW1hDU10pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCAoZCkgPT4gZFtZQ1NdKVxuICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIChkKSA9PiBkW1hDRV0gLSBkW1hDU10pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2hlaWdodCcsIHRoaXMubGF5b3V0LnRyYWNrX2hlaWdodClcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIChkLCBpKSA9PiB0aGlzLnJlc29sdmVTY2FsYWJsZVBhcmFtZXRlcih0aGlzLmxheW91dC5jb2xvciwgZCwgaSkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIChkLCBpKSA9PiB0aGlzLnJlc29sdmVTY2FsYWJsZVBhcmFtZXRlcih0aGlzLmxheW91dC5maWxsX29wYWNpdHksIGQsIGkpKTtcblxuICAgICAgICAgICAgZGF0YV9ub2Rlcy5leGl0KClcbiAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2RhdGFub2Rlc19ncm91cFxuICAgICAgICAgICAgICAgIC5jYWxsKHRoaXMuYXBwbHlCZWhhdmlvcnMuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIC8vIFRoZSBpbnRlcnZhbHMgdHJhY2sgYWxsb3dzIGxlZ2VuZHMgdG8gYmUgZHluYW1pY2FsbHkgZ2VuZXJhdGVkLCBpbiB3aGljaCBjYXNlIHNwYWNlIGNhbiBvbmx5IGJlXG4gICAgICAgICAgICAvLyAgYWxsb2NhdGVkIGFmdGVyIHRoZSBwYW5lbCBoYXMgYmVlbiByZW5kZXJlZC5cbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sZWdlbmQucmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBfZ2V0VG9vbHRpcFBvc2l0aW9uKHRvb2x0aXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeF9taW46IHRvb2x0aXAuZGF0YVtYQ1NdLFxuICAgICAgICAgICAgICAgIHhfbWF4OiB0b29sdGlwLmRhdGFbWENFXSxcbiAgICAgICAgICAgICAgICB5X21pbjogdG9vbHRpcC5kYXRhW1lDU10sXG4gICAgICAgICAgICAgICAgeV9tYXg6IHRvb2x0aXAuZGF0YVtZQ0VdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlZHJhdyBzcGxpdCB0cmFjayBheGlzIG9yIGhpZGUgaXQsIGFuZCBzaG93L2hpZGUgdGhlIGxlZ2VuZCwgYXMgZGV0ZXJtaW5lZFxuICAgICAgICAvLyBieSBjdXJyZW50IGxheW91dCBwYXJhbWV0ZXJzIGFuZCBkYXRhXG4gICAgICAgIHVwZGF0ZVNwbGl0VHJhY2tBeGlzKGNhdGVnb3JpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZ2VuZF9heGlzID0gdGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfbGVnZW5kX3RvX3lfYXhpcyA/IGB5JHt0aGlzLmxheW91dC50cmFja19zcGxpdF9sZWdlbmRfdG9feV9heGlzfWAgOiBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxheW91dC5zcGxpdF90cmFja3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja3MgPSArY2F0ZWdvcmllcy5sZW5ndGggfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFja19oZWlnaHQgPSArdGhpcy5sYXlvdXQudHJhY2tfaGVpZ2h0IHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tfc3BhY2luZyA9IDIgKiAoK3RoaXMubGF5b3V0LmJvdW5kaW5nX2JveF9wYWRkaW5nIHx8IDApICsgKCt0aGlzLmxheW91dC50cmFja192ZXJ0aWNhbF9zcGFjaW5nIHx8IDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldF9oZWlnaHQgPSAodHJhY2tzICogdHJhY2tfaGVpZ2h0KSArICgodHJhY2tzIC0gMSkgKiB0cmFja19zcGFjaW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5zY2FsZUhlaWdodFRvRGF0YSh0YXJnZXRfaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBpZiAobGVnZW5kX2F4aXMgJiYgdGhpcy5wYXJlbnQubGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxlZ2VuZC5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxheW91dC5heGVzW2xlZ2VuZF9heGlzXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6ICh0YXJnZXRfaGVpZ2h0IC0gKHRoaXMubGF5b3V0LnRyYWNrX2hlaWdodCAvIDIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6ICh0aGlzLmxheW91dC50cmFja19oZWlnaHQgLyAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgdmVyeSB0aWdodCBjb3VwbGluZyBiZXR3ZWVuIHRoZSBkaXNwbGF5IGRpcmVjdGl2ZXM6IGVhY2ggbGVnZW5kIGl0ZW0gbXVzdCBpZGVudGlmeSBhIGtleVxuICAgICAgICAgICAgICAgICAgICAvLyAgZmllbGQgZm9yIHVuaXF1ZSB0cmFja3MuIChUeXBpY2FsbHkgdGhpcyBpcyBgc3RhdGVfaWRgLCB0aGUgc2FtZSBrZXkgZmllbGQgdXNlZCB0byBhc3NpZ24gdW5pcXVlIGNvbG9ycylcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGxpc3Qgb2YgdW5pcXVlIGtleXMgY29ycmVzcG9uZHMgdG8gdGhlIG9yZGVyIGFsb25nIHRoZSB5LWF4aXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQubGVnZW5kLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGVsZW1lbnRbdGhpcy5sYXlvdXQudHJhY2tfc3BsaXRfZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRyYWNrID0gY2F0ZWdvcmllcy5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0gPT09IGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2sgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LnRyYWNrX3NwbGl0X29yZGVyID09PSAnREVTQycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2sgPSBNYXRoLmFicyh0cmFjayAtIHRyYWNrcyAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sYXlvdXQuYXhlc1tsZWdlbmRfYXhpc10udGlja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRyYWNrIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZWxlbWVudC5sYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0LnlfYXhpcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXM6IHRoaXMubGF5b3V0LnRyYWNrX3NwbGl0X2xlZ2VuZF90b195X2F4aXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9vcjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlaWxpbmc6IHRyYWNrcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHRyaWdnZXIgYSByZS1yZW5kZXJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudF9wbG90LnBvc2l0aW9uUGFuZWxzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsZWdlbmRfYXhpcyAmJiB0aGlzLnBhcmVudC5sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmxheW91dC5hbHdheXNfaGlkZV9sZWdlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmxlZ2VuZC5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGF5b3V0LmF4ZXNbbGVnZW5kX2F4aXNdID0geyByZW5kZXI6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWV0aG9kIHRvIG5vdCBvbmx5IHRvZ2dsZSB0aGUgc3BsaXQgdHJhY2tzIGJvb2xlYW4gYnV0IGFsc28gdXBkYXRlXG4gICAgICAgIC8vIG5lY2Vzc2FyeSBkaXNwbGF5IHZhbHVlcyB0byBhbmltYXRlIGEgY29tcGxldGUgbWVyZ2Uvc3BsaXRcbiAgICAgICAgdG9nZ2xlU3BsaXRUcmFja3MoKSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5zcGxpdF90cmFja3MgPSAhdGhpcy5sYXlvdXQuc3BsaXRfdHJhY2tzO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50LmxlZ2VuZCAmJiAhdGhpcy5sYXlvdXQuYWx3YXlzX2hpZGVfbGVnZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQubGF5b3V0Lm1hcmdpbi5ib3R0b20gPSA1ICsgKHRoaXMubGF5b3V0LnNwbGl0X3RyYWNrcyA/IDAgOiB0aGlzLnBhcmVudC5sZWdlbmQubGF5b3V0LmhlaWdodCArIDUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hvb3NlIGFuIGFwcHJvcHJpYXRlIGNvbG9yIHNjaGVtZSBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSB0cmFjaywgYW5kIHdoZXRoZXIgb3Igbm90IHdlIGFyZVxuICAgICAgICAvLyAgdXNpbmcgZXhwbGljaXRseSBwcm92aWRlZCBpdGVtUmdiIGluZm9ybWF0aW9uXG4gICAgICAgIF9tYWtlQ29sb3JTY2hlbWUoY2F0ZWdvcnlfaW5mbykge1xuICAgICAgICAgICAgLy8gSWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaGFzIGFuIGV4cGxpY2l0IGl0ZW1SZ2IsIGFzc3VtZSB0aGUgZW50aXJlIGRhdGFzZXQgaGFzIGNvbG9yc1xuICAgICAgICAgICAgY29uc3QgaGFzX2V4cGxpY2l0X2NvbG9ycyA9IGNhdGVnb3J5X2luZm8uZmluZCgoaXRlbSkgPT4gaXRlbVsyXSk7XG4gICAgICAgICAgICBpZiAoaGFzX2V4cGxpY2l0X2NvbG9ycykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXRlZ29yeV9pbmZvLm1hcCgoaXRlbSkgPT4gaXRlbVsyXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBhIHNldCBvZiBjb2xvciBzY2hlbWVzIGZvciBjb21tb24gMTUsIDE4LCBvciAyNSBzdGF0ZSBtb2RlbHMsIGFzIHNwZWNpZmllZCBmcm9tOlxuICAgICAgICAgICAgLy8gIGh0dHBzOi8vZWdnMi53dXN0bC5lZHUvcm9hZG1hcC93ZWJfcG9ydGFsL2Nocl9zdGF0ZV9sZWFybmluZy5odG1sXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgYWN0dWFsbHkgcmV2ZXJzZWQgc28gdGhhdCBkaW0gY29sb3JzIGNvbWUgZmlyc3QsIG9uIHRoZSBwcmVtaXNlIHRoYXQgdXN1YWxseSB0aGVzZSBhcmUgdGhlXG4gICAgICAgICAgICAvLyAgbW9zdCBjb21tb24gc3RhdGVzXG4gICAgICAgICAgICBjb25zdCBuX2NhdGVnb3JpZXMgPSBjYXRlZ29yeV9pbmZvLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChuX2NhdGVnb3JpZXMgPD0gMTUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydyZ2IoMjEyLDIxMiwyMTIpJywgJ3JnYigxOTIsMTkyLDE5MiknLCAncmdiKDEyOCwxMjgsMTI4KScsICdyZ2IoMTg5LDE4MywxMDcpJywgJ3JnYigyMzMsMTUwLDEyMiknLCAncmdiKDIwNSw5Miw5MiknLCAncmdiKDEzOCwxNDUsMjA4KScsICdyZ2IoMTAyLDIwNSwxNzApJywgJ3JnYigyNTUsMjU1LDApJywgJ3JnYigxOTQsMjI1LDUpJywgJ3JnYigwLDEwMCwwKScsICdyZ2IoMCwxMjgsMCknLCAncmdiKDUwLDIwNSw1MCknLCAncmdiKDI1NSw2OSwwKScsICdyZ2IoMjU1LDAsMCknXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobl9jYXRlZ29yaWVzIDw9IDE4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsncmdiKDIxMiwyMTIsMjEyKScsICdyZ2IoMTkyLDE5MiwxOTIpJywgJ3JnYigxMjgsMTI4LDEyOCknLCAncmdiKDE4OSwxODMsMTA3KScsICdyZ2IoMjA1LDkyLDkyKScsICdyZ2IoMTM4LDE0NSwyMDgpJywgJ3JnYigxMDIsMjA1LDE3MCknLCAncmdiKDI1NSwyNTUsMCknLCAncmdiKDI1NSwxOTUsNzcpJywgJ3JnYigyNTUsMTk1LDc3KScsICdyZ2IoMTk0LDIyNSw1KScsICdyZ2IoMTk0LDIyNSw1KScsICdyZ2IoMCwxMDAsMCknLCAncmdiKDAsMTI4LDApJywgJ3JnYigyNTUsNjksMCknLCAncmdiKDI1NSw2OSwwKScsICdyZ2IoMjU1LDY5LDApJywgJ3JnYigyNTUsMCwwKSddO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDI1IGNhdGVnb3JpZXMsIHRoZSBpbnRlcnZhbCBsYXllciB3aWxsIGZhbGwgYmFjayB0byB0aGUgJ251bGwgdmFsdWUnIG9wdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiBbJ3JnYigyMTIsMjEyLDIxMiknLCAncmdiKDEyOCwxMjgsMTI4KScsICdyZ2IoMTEyLDQ4LDE2MCknLCAncmdiKDIzMCwxODQsMTgzKScsICdyZ2IoMTM4LDE0NSwyMDgpJywgJ3JnYigxMDIsMjA1LDE3MCknLCAncmdiKDI1NSwyNTUsMTAyKScsICdyZ2IoMjU1LDI1NSwwKScsICdyZ2IoMjU1LDI1NSwwKScsICdyZ2IoMjU1LDI1NSwwKScsICdyZ2IoMjU1LDE5NSw3NyknLCAncmdiKDI1NSwxOTUsNzcpJywgJ3JnYigyNTUsMTk1LDc3KScsICdyZ2IoMTk0LDIyNSw1KScsICdyZ2IoMTk0LDIyNSw1KScsICdyZ2IoMTk0LDIyNSw1KScsICdyZ2IoMTk0LDIyNSw1KScsICdyZ2IoMCwxNTAsMCknLCAncmdiKDAsMTI4LDApJywgJ3JnYigwLDEyOCwwKScsICdyZ2IoMCwxMjgsMCknLCAncmdiKDI1NSw2OSwwKScsICdyZ2IoMjU1LDY5LDApJywgJ3JnYigyNTUsNjksMCknLCAncmdiKDI1NSwwLDApJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCBhbGwgb2YgdGhlIHVuaXF1ZSB0cmFja3MgKGEgY29tYmluYXRpb24gb2YgbmFtZSBhbmQgSUQgaW5mb3JtYXRpb24pXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcmdiX2ZpZWxkXSBBIGZpZWxkIHRoYXQgY29udGFpbnMgYW4gUkdCIHZhbHVlLiBBaW1lZCBhdCBCRUQgZmlsZXMgd2l0aCBhbiBpdGVtUmdiIGNvbHVtblxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFsbCBbdW5pcXVlX2lkLCBsYWJlbCwgY29sb3JdIHBhaXJzIGluIGRhdGEuIFRoZSB1bmlxdWVfaWQgaXMgdGhlIHRoaW5nIHVzZWQgdG8gZGVmaW5lIGdyb3VwaW5nc1xuICAgICAgICAgKiAgbW9zdCB1bmFtYmlndW91c2x5LlxuICAgICAgICAgKi9cbiAgICAgICAgX2dlbmVyYXRlQ2F0ZWdvcmllc0Zyb21EYXRhKGRhdGEsIHJnYl9maWVsZCkge1xuICAgICAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGhhcmQtY29kZWQgbGVnZW5kIGlmIGF2YWlsYWJsZSAoaWdub3JpbmcgYW55IG1vZHMgb24gcmUtcmVuZGVyKVxuICAgICAgICAgICAgY29uc3QgbGVnZW5kID0gdGhpcy5fYmFzZV9sYXlvdXQubGVnZW5kO1xuICAgICAgICAgICAgaWYgKGxlZ2VuZCAmJiBsZWdlbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZ2VuZC5tYXAoKGl0ZW0pID0+IFtpdGVtW3RoaXMubGF5b3V0LnRyYWNrX3NwbGl0X2ZpZWxkXSwgaXRlbS5sYWJlbCwgaXRlbS5jb2xvcl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBvcHRpb25zIGZyb20gZGF0YSwgaWYgbm8gcHJlc2V0IGxlZ2VuZCBleGlzdHNcbiAgICAgICAgICAgIGNvbnN0IHVuaXF1ZV9pZHMgPSB7fTsgLy8gbWFrZSBjYXRlZ29yaWVzIHVuaXF1ZVxuICAgICAgICAgICAgY29uc3QgY2F0ZWdvcmllcyA9IFtdO1xuXG4gICAgICAgICAgICBkYXRhLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGl0ZW1bc2VsZi5sYXlvdXQudHJhY2tfc3BsaXRfZmllbGRdO1xuICAgICAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHVuaXF1ZV9pZHMsIGlkKSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVfaWRzW2lkXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHJnYmZpZWxkIGlzIG51bGwsIHRoZW4gdGhlIGxhc3QgZW50cnkgaXMgdW5kZWZpbmVkL251bGwgYXMgd2VsbFxuICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLnB1c2goW2lkLCBpdGVtW3RoaXMubGF5b3V0LnRyYWNrX2xhYmVsX2ZpZWxkXSwgaXRlbVtyZ2JfZmllbGRdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2F0ZWdvcmllcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGludGVydmFsc190b29sdGlwX2xheW91dCA9IHtcbiAgICAgICAgbmFtZXNwYWNlOiB7ICdpbnRlcnZhbHMnOiAnaW50ZXJ2YWxzJyB9LFxuICAgICAgICBjbG9zYWJsZTogZmFsc2UsXG4gICAgICAgIHNob3c6IHsgb3I6IFsnaGlnaGxpZ2h0ZWQnLCAnc2VsZWN0ZWQnXSB9LFxuICAgICAgICBoaWRlOiB7IGFuZDogWyd1bmhpZ2hsaWdodGVkJywgJ3Vuc2VsZWN0ZWQnXSB9LFxuICAgICAgICBodG1sOiAne3t7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1zdGF0ZV9uYW1lfGh0bWxlc2NhcGV9fTxicj57e3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXJ0fGh0bWxlc2NhcGV9fS17e3t7bmFtZXNwYWNlW2ludGVydmFsc119fWVuZHxodG1sZXNjYXBlfX0nLFxuICAgIH07XG5cbiAgICBjb25zdCBpbnRlcnZhbHNfbGF5ZXJfbGF5b3V0ID0gIHtcbiAgICAgICAgbmFtZXNwYWNlOiB7ICdpbnRlcnZhbHMnOiAnaW50ZXJ2YWxzJyB9LFxuICAgICAgICBpZDogJ2ludGVydmFscycsXG4gICAgICAgIHR5cGU6ICdpbnRlcnZhbHMnLFxuICAgICAgICBmaWVsZHM6IFsne3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19c3RhcnQnLCAne3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19ZW5kJywgJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXRlX2lkJywgJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXRlX25hbWUnLCAne3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19aXRlbVJnYiddLFxuICAgICAgICBpZF9maWVsZDogJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXJ0JywgIC8vIEZJWE1FOiBUaGlzIGlzIG5vdCBhIGdvb2QgRDMgXCJhcmUgdGhlc2UgZGF0dW1zIHJlZHVuZGFudFwiIElEIGZvciBkYXRhc2V0cyB3aXRoIG11bHRpcGxlIGludGVydmFscyBoZWF2aWx5IG92ZXJsYXBwaW5nXG4gICAgICAgIHN0YXJ0X2ZpZWxkOiAne3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19c3RhcnQnLFxuICAgICAgICBlbmRfZmllbGQ6ICd7e25hbWVzcGFjZVtpbnRlcnZhbHNdfX1lbmQnLFxuICAgICAgICB0cmFja19zcGxpdF9maWVsZDogJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXRlX25hbWUnLFxuICAgICAgICB0cmFja19sYWJlbF9maWVsZDogJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fXN0YXRlX25hbWUnLFxuICAgICAgICBzcGxpdF90cmFja3M6IGZhbHNlLFxuICAgICAgICBhbHdheXNfaGlkZV9sZWdlbmQ6IHRydWUsXG4gICAgICAgIGNvbG9yOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gSWYgcHJlc2VudCwgYW4gZXhwbGljaXQgY29sb3IgZmllbGQgd2lsbCBvdmVycmlkZSBhbnkgb3RoZXIgb3B0aW9uIChhbmQgYmUgdXNlZCB0byBhdXRvLWdlbmVyYXRlIGxlZ2VuZClcbiAgICAgICAgICAgICAgICBmaWVsZDogJ3t7bmFtZXNwYWNlW2ludGVydmFsc119fWl0ZW1SZ2InLFxuICAgICAgICAgICAgICAgIHNjYWxlX2Z1bmN0aW9uOiAndG9fcmdiJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgY2hhbmdpbmcgdGhpcyB0byBzdGFibGVfY2hvaWNlIGluIHRoZSBmdXR1cmUsIGZvciBtb3JlIHN0YWJsZSBjb2xvcmluZ1xuICAgICAgICAgICAgICAgIGZpZWxkOiAne3tuYW1lc3BhY2VbaW50ZXJ2YWxzXX19c3RhdGVfbmFtZScsXG4gICAgICAgICAgICAgICAgc2NhbGVfZnVuY3Rpb246ICdjYXRlZ29yaWNhbF9iaW4nLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2Vob2xkZXIuIEVtcHR5IGNhdGVnb3JpZXMgYW5kIHZhbHVlcyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZmlsbGVkIGluIHdoZW4gbmV3IGRhdGEgbG9hZHMuXG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBudWxsX3ZhbHVlOiAnI0I4QjhCOCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGxlZ2VuZDogW10sIC8vIFBsYWNlaG9sZGVyOyBhdXRvLWZpbGxlZCB3aGVuIGRhdGEgbG9hZHMuXG4gICAgICAgIGJlaGF2aW9yczoge1xuICAgICAgICAgICAgb25tb3VzZW92ZXI6IFtcbiAgICAgICAgICAgICAgICB7IGFjdGlvbjogJ3NldCcsIHN0YXR1czogJ2hpZ2hsaWdodGVkJyB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG9ubW91c2VvdXQ6IFtcbiAgICAgICAgICAgICAgICB7IGFjdGlvbjogJ3Vuc2V0Jywgc3RhdHVzOiAnaGlnaGxpZ2h0ZWQnIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgb25jbGljazogW1xuICAgICAgICAgICAgICAgIHsgYWN0aW9uOiAndG9nZ2xlJywgc3RhdHVzOiAnc2VsZWN0ZWQnLCBleGNsdXNpdmU6IHRydWUgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBvbnNoaWZ0Y2xpY2s6IFtcbiAgICAgICAgICAgICAgICB7IGFjdGlvbjogJ3RvZ2dsZScsIHN0YXR1czogJ3NlbGVjdGVkJyB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDogaW50ZXJ2YWxzX3Rvb2x0aXBfbGF5b3V0LFxuICAgIH07XG5cbiAgICBjb25zdCBpbnRlcnZhbHNfcGFuZWxfbGF5b3V0ID0ge1xuICAgICAgICBpZDogJ2ludGVydmFscycsXG4gICAgICAgIG1pbl9oZWlnaHQ6IDUwLFxuICAgICAgICBoZWlnaHQ6IDUwLFxuICAgICAgICBtYXJnaW46IHsgdG9wOiAyNSwgcmlnaHQ6IDE1MCwgYm90dG9tOiA1LCBsZWZ0OiA1MCB9LFxuICAgICAgICB0b29sYmFyOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IExvY3VzWm9vbS5MYXlvdXRzLmdldCgndG9vbGJhcicsICdzdGFuZGFyZF9wYW5lbCcsIHsgdW5uYW1lc3BhY2VkOiB0cnVlIH0pO1xuICAgICAgICAgICAgbC53aWRnZXRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0b2dnbGVfc3BsaXRfdHJhY2tzJyxcbiAgICAgICAgICAgICAgICBkYXRhX2xheWVyX2lkOiAnaW50ZXJ2YWxzJyxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGw7XG4gICAgICAgIH0pKCksXG4gICAgICAgIGF4ZXM6IHt9LFxuICAgICAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgICAgICAgZHJhZ19iYWNrZ3JvdW5kX3RvX3BhbjogdHJ1ZSxcbiAgICAgICAgICAgIHNjcm9sbF90b196b29tOiB0cnVlLFxuICAgICAgICAgICAgeF9saW5rZWQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgICAgaGlkZGVuOiB0cnVlLFxuICAgICAgICAgICAgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgIG9yaWdpbjogeyB4OiA1MCwgeTogMCB9LFxuICAgICAgICAgICAgcGFkX2Zyb21fYm90dG9tOiA1LFxuICAgICAgICB9LFxuICAgICAgICBkYXRhX2xheWVyczogW2ludGVydmFsc19sYXllcl9sYXlvdXRdLFxuICAgIH07XG5cbiAgICBjb25zdCBpbnRlcnZhbHNfcGxvdF9sYXlvdXQgPSB7XG4gICAgICAgIHN0YXRlOiB7fSxcbiAgICAgICAgd2lkdGg6IDgwMCxcbiAgICAgICAgcmVzcG9uc2l2ZV9yZXNpemU6IHRydWUsXG4gICAgICAgIG1pbl9yZWdpb25fc2NhbGU6IDIwMDAwLFxuICAgICAgICBtYXhfcmVnaW9uX3NjYWxlOiAxMDAwMDAwLFxuICAgICAgICB0b29sYmFyOiBMb2N1c1pvb20uTGF5b3V0cy5nZXQoJ3Rvb2xiYXInLCAnc3RhbmRhcmRfYXNzb2NpYXRpb24nLCB7IHVubmFtZXNwYWNlZDogdHJ1ZSB9KSxcbiAgICAgICAgcGFuZWxzOiBbXG4gICAgICAgICAgICBMb2N1c1pvb20uTGF5b3V0cy5nZXQoJ3BhbmVsJywgJ2Fzc29jaWF0aW9uJyksXG4gICAgICAgICAgICBMb2N1c1pvb20uTGF5b3V0cy5tZXJnZSh7IHVubmFtZXNwYWNlZDogdHJ1ZSwgbWluX2hlaWdodDogMTIwLCBoZWlnaHQ6IDEyMCB9LCBpbnRlcnZhbHNfcGFuZWxfbGF5b3V0KSxcbiAgICAgICAgICAgIExvY3VzWm9vbS5MYXlvdXRzLmdldCgncGFuZWwnLCAnZ2VuZXMnKSxcbiAgICAgICAgXSxcbiAgICB9O1xuXG4gICAgTG9jdXNab29tLkFkYXB0ZXJzLmFkZCgnSW50ZXJ2YWxMWicsIEludGVydmFsTFopO1xuICAgIExvY3VzWm9vbS5EYXRhTGF5ZXJzLmFkZCgnaW50ZXJ2YWxzJywgTHpJbnRlcnZhbHNUcmFjayk7XG5cbiAgICBMb2N1c1pvb20uTGF5b3V0cy5hZGQoJ3Rvb2x0aXAnLCAnc3RhbmRhcmRfaW50ZXJ2YWxzJywgaW50ZXJ2YWxzX3Rvb2x0aXBfbGF5b3V0KTtcbiAgICBMb2N1c1pvb20uTGF5b3V0cy5hZGQoJ2RhdGFfbGF5ZXInLCAnaW50ZXJ2YWxzJywgaW50ZXJ2YWxzX2xheWVyX2xheW91dCk7XG4gICAgTG9jdXNab29tLkxheW91dHMuYWRkKCdwYW5lbCcsICdpbnRlcnZhbHMnLCBpbnRlcnZhbHNfcGFuZWxfbGF5b3V0KTtcbiAgICBMb2N1c1pvb20uTGF5b3V0cy5hZGQoJ3Bsb3QnLCAnaW50ZXJ2YWxfYXNzb2NpYXRpb24nLCBpbnRlcnZhbHNfcGxvdF9sYXlvdXQpO1xuXG4gICAgTG9jdXNab29tLlNjYWxlRnVuY3Rpb25zLmFkZCgndG9fcmdiJywgdG9fcmdiKTtcblxuICAgIExvY3VzWm9vbS5XaWRnZXRzLmFkZCgndG9nZ2xlX3NwbGl0X3RyYWNrcycsIFRvZ2dsZVNwbGl0VHJhY2tzKTtcbn1cblxuaWYgKHR5cGVvZiBMb2N1c1pvb20gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gQXV0by1yZWdpc3RlciB0aGUgcGx1Z2luIHdoZW4gaW5jbHVkZWQgYXMgYSBzY3JpcHQgdGFnLiBFUzYgbW9kdWxlIHVzZXJzIG11c3QgcmVnaXN0ZXIgdmlhIExvY3VzWm9vbS51c2UoKVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIExvY3VzWm9vbS51c2UoaW5zdGFsbCk7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgaW5zdGFsbDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZDM7Il0sInNvdXJjZVJvb3QiOiIifQ==