{"version":3,"sources":["lz-tabix-source.min.js"],"names":["root","factory","define","amd","LocusZoom","tabix","module","exports","require","ext","Data","TabixUrlSource","this","Source","extend","init","parseInit","enableCache","prototype","parser_func","url_data","Error","parser","url_tbi","params","_overfetch","overfetch","_reader_promise","urlReader","catch","getCacheKey","state","chr","start","end","join","fetchRequest","self","Promise","resolve","reject","region_start","region_end","extra_amount","then","reader","fetch","data","err","normalizeResponse","map"],"mappings":"AASA,cAOC,SAAUA,EAAMC,GACS,mBAAXC,QAAyBA,OAAOC,IACvCD,OAAO,CAAC,YAAa,gBAAkB,SAASE,EAAWC,GACvD,OAAOJ,EAAQG,EAAWC,KAEN,iBAAXC,QAAuBA,OAAOC,QAC3CD,OAAOC,QAAUN,EAAQO,QAAQ,aAAcA,QAAQ,kBAElDR,EAAKI,UAAUK,IAAIC,OACpBV,EAAKI,UAAUK,IAAIC,KAAO,IAE9BV,EAAKI,UAAUK,IAAIC,KAAKC,eAAiBV,EAAQD,EAAKI,UAAWJ,EAAKK,QAX9E,CAaEO,KAAM,SAASR,EAAWC,GASxB,IAAIM,EAAiBP,EAAUM,KAAKG,OAAOC,OAAO,SAASC,GACvDH,KAAKI,UAAUD,GACfH,KAAKK,aAAc,GACpB,kBA0EH,OA7DAN,EAAeO,UAAUF,UAAY,SAAUD,GAC3C,IAAKA,EAAKI,cAAgBJ,EAAKK,SAC3B,MAAM,IAAIC,MAAM,0DAEpBT,KAAKU,OAASP,EAAKI,YAGnBP,KAAKQ,SAAWL,EAAKK,SACrBR,KAAKW,QAAUR,EAAKQ,SAAWX,KAAKQ,SAAW,OAK/C,IAAII,EAAST,EAAKS,QAAU,GAI5B,GAHAZ,KAAKY,OAASA,EACdZ,KAAKa,WAAaD,EAAOE,WAAa,EAElCd,KAAKa,WAAa,GAAuB,EAAlBb,KAAKa,WAC5B,MAAM,IAAIJ,MAAM,gFAKpBT,KAAKe,gBAAkBtB,EAAMuB,UAAUhB,KAAKQ,SAAUR,KAAKW,SAASM,MAAM,WACtE,MAAM,IAAIR,MAAM,4DAIxBV,EAAeO,UAAUY,YAAc,SAAUC,GAG7C,MAAO,CAACA,EAAMC,IAAKD,EAAME,MAAOF,EAAMG,IAAKtB,KAAKa,YAAYU,KAAK,MAGrExB,EAAeO,UAAUkB,aAAe,SAAUL,GAC9C,IAAIM,EAAOzB,KACX,OAAO,IAAI0B,QAAQ,SAAUC,EAASC,GAElC,IAAIC,EAAeV,EAAME,MACrBS,EAAaX,EAAMG,IACnBS,EAAeN,EAAKZ,YAAciB,EAAaD,GAE/CR,EAAQF,EAAME,MAAQU,EACtBT,EAAMH,EAAMG,IAAMS,EACtBN,EAAKV,gBAAgBiB,KAAK,SAAUC,GAChCA,EAAOC,MAAMf,EAAMC,IAAKC,EAAOC,EAAK,SAAUa,EAAMC,GAC5CA,GACAR,EAAO,IAAInB,MAAM,qFAErBkB,EAAQQ,UAMxBpC,EAAeO,UAAU+B,kBAAoB,SAAUF,GAEnD,OAAOA,EAAKG,IAAItC,KAAKU,SAIlB,CAAEX,eAAgBA","file":"lz-tabix-source.min.js","sourcesContent":["/*\n    A datasource that fetches data from a remote Tabix file, instead of a RESTful API.\n    Requires a generic user-specified parser.\n\n    The page must incorporate and load all libraries before this file can be used, including:\n     - Vendor assets\n     - LocusZoom\n     - tabix-reader (available via NPM or a related CDN)\n*/\n'use strict';\n\n// This is defined as a UMD module, to work with multiple different module systems / bundlers\n// Arcane build note: everything defined here gets registered globally. This is not a \"pure\" module, and some build\n//  systems may require being told that this file has side effects.\n/* global define, module, require, Promise */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(['locuszoom', 'tabix-reader'] , function(LocusZoom, tabix) {  // amd\n            return factory(LocusZoom, tabix);\n        });\n    } else if(typeof module === 'object' && module.exports) {  // commonJS\n        module.exports = factory(require('locuszoom'), require('tabix-reader'));\n    } else {  // globals\n        if (!root.LocusZoom.ext.Data) {\n            root.LocusZoom.ext.Data = {};\n        }\n        root.LocusZoom.ext.Data.TabixUrlSource = factory(root.LocusZoom, root.tabix);\n    }\n}(this, function(LocusZoom, tabix) {\n    /**\n     * Custom data source that loads data from a remote Tabix file (if the file host has been configured with proper\n     *  CORS and Range header support- most hosts do not do that by default).\n     *\n     * @class\n     * @public\n     * @augments LocusZoom.Data.Source\n     */\n    var TabixUrlSource = LocusZoom.Data.Source.extend(function(init) {\n        this.parseInit(init);\n        this.enableCache = true;\n    }, 'TabixUrlSource');\n\n    /**\n     * @param {Object} init\n     * @param {function} init.parser_func A function that parses a single line of text and returns (usually) a\n     *  structured object of data fields\n     * @param {string} init.url_data The URL for the bgzipped and tabix-indexed file\n     * @param {string} [init.url_tbi] The URL for the tabix index. Defaults to `url_data` + '.tbi'\n     * @param {Object} [init.params]\n     * @param {number} [init.params.overfetch = 0] Optionally fetch more data than is required to satisfy the\n     *  region query. (specified as a fraction of the region size, 0-1)\n     *  Useful for sources where interesting features might lie near the edges of the plot.\n     */\n    TabixUrlSource.prototype.parseInit = function (init) {\n        if (!init.parser_func || !init.url_data) {\n            throw new Error('Tabix source is missing required configuration options');\n        }\n        this.parser = init.parser_func;\n        // TODO: In the future, accept a pre-configured reader instance (as an alternative to the URL). Most useful\n        //   for UIs that want to validate the tabix file before adding it to the plot, like LocalZoom.\n        this.url_data = init.url_data;\n        this.url_tbi = init.url_tbi || this.url_data + '.tbi';\n\n        // In tabix mode, sometimes we want to fetch a slightly larger region than is displayed, in case a\n        //    feature is on the edge of what the tabix query would return.\n        //    Specify overfetch in units of % of total region size. (\"fetch 10% extra before and after\")\n        var params = init.params || {};\n        this.params = params;\n        this._overfetch = params.overfetch || 0;\n\n        if (this._overfetch < 0 || this._overfetch > 1) {\n            throw new Error('Overfetch must be specified as a fraction (0-1) of the requested region size');\n        }\n\n        // Assuming that the `tabix-reader` library has been loaded via a CDN, this will create the reader\n        // Since fetching the index is a remote operation, all reader usages will be via an async interface.\n        this._reader_promise = tabix.urlReader(this.url_data, this.url_tbi).catch(function() {\n            throw new Error('Failed to create a tabix reader from the provided URL');\n        });\n    };\n\n    TabixUrlSource.prototype.getCacheKey = function (state /*, chain, fields*/) {\n        // In generic form, Tabix queries are based on chr, start, and end. The cache is thus controlled by the query,\n        //  not the URL\n        return [state.chr, state.start, state.end, this._overfetch].join('_');\n    };\n\n    TabixUrlSource.prototype.fetchRequest = function (state /*, chain, fields */) {\n        var self = this;\n        return new Promise(function (resolve, reject) {\n            // Ensure that the reader is fully created (and index available), then make a query\n            var region_start = state.start;\n            var region_end = state.end;\n            var extra_amount = self._overfetch * (region_end - region_start);\n\n            var start = state.start - extra_amount;\n            var end = state.end + extra_amount;\n            self._reader_promise.then(function (reader) {\n                reader.fetch(state.chr, start, end, function (data, err) {\n                    if (err) {\n                        reject(new Error('Could not read requested region. This may indicate an error with the .tbi index.'));\n                    }\n                    resolve(data);\n                });\n            });\n        });\n    };\n\n    TabixUrlSource.prototype.normalizeResponse = function (data) {\n        // Parse the data from lines of text to objects\n        return data.map(this.parser);\n    };\n\n    // Public interface for this extension; since everything is registered w/LocusZoom, this is rarely used directly.\n    return { TabixUrlSource: TabixUrlSource };\n}));\n\n"]}