/*! Locuszoom 0.13.0-beta.4 */
var LzAggregationTests=function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=12)}({12:function(e,t,r){"use strict";r.r(t);var n=r(4),o=r(2);function s(e){const t=e.Adapters.get("BaseAdapter"),r=e.Adapters.get("ConnectorSource");class s extends o.BaseApiAdapter{getURL(e,t,r){const n=e.aggregation_tests||{};t.header||(t.header={}),t.header.aggregation_genoset_id=n.genoset_id||null,t.header.aggregation_genoset_build=n.genoset_build||null,t.header.aggregation_phenoset_id=n.phenoset_id||null,t.header.aggregation_pheno=n.pheno||null,t.header.aggregation_calcs=n.calcs||{};const o=n.masks||[];return t.header.aggregation_masks=o,t.header.aggregation_mask_ids=o.map((function(e){return e.name})),this.url}getCacheKey(e,t,r){return this.getURL(e,t,r),JSON.stringify({chrom:e.chr,start:e.start,stop:e.end,genotypeDataset:t.header.aggregation_genoset_id,phenotypeDataset:t.header.aggregation_phenoset_id,phenotype:t.header.aggregation_pheno,samples:"ALL",genomeBuild:t.header.aggregation_genoset_build,masks:t.header.aggregation_mask_ids})}fetchRequest(e,t,r){const n=this.getURL(e,t,r),o=this.getCacheKey(e,t,r);return fetch(n,{method:"POST",body:o,headers:{"Content-Type":"application/json"}}).then(e=>{if(!e.ok)throw new Error(e.statusText);return e.text()}).then((function(e){const t="string"==typeof e?JSON.parse(e):e;if(t.error)throw new Error(t.error);return t}))}annotateData(e,t){if(!e.groups)return{groups:[],variants:[]};e.groups=e.groups.filter((function(e){return"GENE"===e.groupType}));const r=n.helpers.parsePortalJSON(e);let o=r[0];const s=r[1];o=o.byMask(t.header.aggregation_mask_ids);const i=t.header.aggregation_calcs;if(!i||0===Object.keys(i).length)return{variants:[],groups:[],results:[]};return new n.helpers.PortalTestRunner(o,s,i).toJSON().then((function(e){const r=t.header.aggregation_masks.reduce((function(e,t){return e[t.name]=t.description,e}),{});return e.data.groups.forEach((function(e){e.mask_name=r[e.mask]})),e.data})).catch((function(e){throw console.error(e),new Error("Failed to calculate aggregation test results")}))}normalizeResponse(e){return e}combineChainBody(e,t){return t.body}}e.Adapters.add("AggregationTestSourceLZ",s),e.Adapters.add("AssocFromAggregationLZ",class extends t{constructor(e){if(!e||!e.from)throw"Must specify the name of the source that contains association data";super(...arguments)}parseInit(e){super.parseInit(e),this._from=e.from}getRequest(e,t,r){if(t.discrete&&!t.discrete[this._from])throw`${this.constructor.SOURCE_NAME} cannot be used before loading required data for: ${this._from}`;return Promise.resolve(JSON.parse(JSON.stringify(t.discrete[this._from].variants)))}normalizeResponse(e){const t=new RegExp("(?:chr)?(.+):(\\d+)_?(\\w+)?/?([^_]+)?_?(.*)?");return e.map(e=>{const r=e.variant.match(t);return{variant:e.variant,chromosome:r[1],position:+r[2],ref_allele:r[3],ref_allele_freq:1-e.altFreq,log_pvalue:-Math.log10(e.pvalue)}}).sort((e,t)=>(e=e.variant)<(t=t.variant)?-1:e>t?1:0)}}),e.Adapters.add("GeneAggregationConnectorLZ",class extends r{_getRequiredSources(){return["gene_ns","aggregation_ns"]}combineChainBody(e,t){const r=this._source_name_mapping.aggregation_ns,n=this._source_name_mapping.gene_ns,o=t.discrete[r],s=t.discrete[n],i={};return o.groups.forEach((function(e){Object.prototype.hasOwnProperty.call(i,e.group)||(i[e.group]=[]),i[e.group].push(e.pvalue)})),s.forEach((function(e){const t=e.gene_name,r=i[t];r&&(e.aggregation_best_pvalue=Math.min.apply(null,r))})),s}})}"undefined"!=typeof LocusZoom&&LocusZoom.use(s),t.default=s},2:function(e,t,r){"use strict";function n(e,t,r){if(t&&r||!t&&!r)throw new Error(e+' must provide a parameter specifying either "build" or "source". It should not specify both.');if(t&&!["GRCh37","GRCh38"].includes(t))throw new Error(e+" must specify a valid genome build number")}r.r(t),r.d(t,"BaseAdapter",(function(){return o})),r.d(t,"BaseApiAdapter",(function(){return s})),r.d(t,"AssociationLZ",(function(){return i})),r.d(t,"ConnectorSource",(function(){return f})),r.d(t,"GeneConstraintLZ",(function(){return d})),r.d(t,"GeneLZ",(function(){return c})),r.d(t,"GwasCatalogLZ",(function(){return u})),r.d(t,"LDServer",(function(){return a})),r.d(t,"PheWASLZ",(function(){return p})),r.d(t,"RecombLZ",(function(){return l})),r.d(t,"StaticSource",(function(){return h}));class o{constructor(e){this._enableCache=!0,this._cachedKey=null,this._cache_pos_start=null,this._cache_pos_end=null,this.__dependentSource=!1,this.parseInit(e)}parseInit(e){this.params=e.params||{}}getCacheKey(e,t,r){this.getURL(e,t,r);const n=e.chr,{_cache_pos_start:o,_cache_pos_end:s}=this;return o&&e.start>=o&&s&&e.end<=s?`${n}_${o}_${s}`:`${e.chr}_${e.start}_${e.end}`}getURL(e,t,r){return this.url}fetchRequest(e,t,r){const n=this.getURL(e,t,r);return fetch(n).then(e=>{if(!e.ok)throw new Error(e.statusText);return e.text()})}getRequest(e,t,r){let n;const o=this.getCacheKey(e,t,r);return this._enableCache&&void 0!==o&&o===this._cachedKey?n=Promise.resolve(this._cachedResponse):(n=this.fetchRequest(e,t,r),this._enableCache&&(this._cachedKey=o,this._cache_pos_start=e.start,this._cache_pos_end=e.end,this._cachedResponse=n)),n}normalizeResponse(e){if(Array.isArray(e))return e;const t=Object.keys(e),r=e[t[0]].length;if(!t.every((function(t){return e[t].length===r})))throw new Error(this.constructor.name+" expects a response in which all arrays of data are the same length");const n=[],o=Object.keys(e);for(let t=0;t<r;t++){const r={};for(let n=0;n<o.length;n++)r[o[n]]=e[o[n]][t];n.push(r)}return n}annotateData(e,t){return e}extractFields(e,t,r,n){if(!Array.isArray(e))return e;if(!e.length)return e;const o=[];for(let e=0;e<t.length;e++)o[e]=0;const s=e.map((function(e){const s={};for(let i=0;i<t.length;i++){let a=e[t[i]];void 0!==a&&(o[i]=1),n&&n[i]&&(a=n[i](a)),s[r[i]]=a}return s}));return o.forEach((function(e,n){if(!e)throw new Error(`field ${t[n]} not found in response for ${r[n]}`)})),s}combineChainBody(e,t,r,n,o){return e}parseResponse(e,t,r,n,o){const s=this.source_id||this.constructor.name;t.discrete||(t.discrete={});const i="string"==typeof e?JSON.parse(e):e;return Promise.resolve(this.normalizeResponse(i.data||i)).then(e=>Promise.resolve(this.annotateData(e,t))).then(e=>Promise.resolve(this.extractFields(e,r,n,o))).then(e=>(t.discrete[s]=e,Promise.resolve(this.combineChainBody(e,t,r,n,o)))).then(e=>({header:t.header||{},discrete:t.discrete,body:e}))}getData(e,t,r,n){if(this.preGetData){const o=this.preGetData(e,t,r,n);this.pre&&(e=o.state||e,t=o.fields||t,r=o.outnames||r,n=o.trans||n)}return o=>this.__dependentSource&&o&&o.body&&!o.body.length?Promise.resolve(o):this.getRequest(e,o,t).then(e=>this.parseResponse(e,o,t,r,n))}}class s extends o{parseInit(e){if(super.parseInit(e),this.url=e.url,!this.url)throw new Error("Source not initialized with required URL")}}class i extends s{preGetData(e,t,r,n){return[this.params.id_field||"id","position"].forEach((function(e){t.includes(e)||(t.unshift(e),r.unshift(e),n.unshift(null))})),{fields:t,outnames:r,trans:n}}getURL(e,t,r){const n=t.header.analysis||this.params.source||this.params.analysis;if(void 0===n)throw new Error("Association source must specify an analysis ID to plot");return`${this.url}results/?filter=analysis in ${n} and chromosome in  '${e.chr}' and position ge ${e.start} and position le ${e.end}`}normalizeResponse(e){return e=super.normalizeResponse(e),this.params&&this.params.sort&&e.length&&e[0].position&&e.sort((function(e,t){return e.position-t.position})),e}}class a extends s{constructor(e){super(e),this.__dependentSource=!0}preGetData(e,t){if(t.length>1&&(2!==t.length||!t.includes("isrefvar")))throw new Error("LD does not know how to get all fields: "+t.join(", "))}findMergeFields(e){let t={id:this.params.id_field,position:this.params.position_field,pvalue:this.params.pvalue_field,_names_:null};if(e&&e.body&&e.body.length>0){const n=Object.keys(e.body[0]),o=(r=n,function(){const e=arguments;for(let t=0;t<e.length;t++){const n=e[t],o=r.filter((function(e){return e.match(n)}));if(o.length)return o[0]}return null}),s=t.id&&o(new RegExp(t.id+"\\b"));t.id=s||o(/\bvariant\b/)||o(/\bid\b/),t.position=t.position||o(/\bposition\b/i,/\bpos\b/i),t.pvalue=t.pvalue||o(/\bpvalue\b/i,/\blog_pvalue\b/i),t._names_=n}var r;return t}findRequestedFields(e,t){let r={};for(let n=0;n<e.length;n++)"isrefvar"===e[n]?(r.isrefvarin=e[n],r.isrefvarout=t&&t[n]):(r.ldin=e[n],r.ldout=t&&t[n]);return r}normalizeResponse(e){return e}getRefvar(e,t,r){let n=this.findRequestedFields(r).ldin;if("state"===n&&(n=e.ldrefvar||t.header.ldrefvar||"best"),"best"===n){if(!t.body)throw new Error("No association data found to find best pvalue");let e=this.findMergeFields(t);if(!e.pvalue||!e.id){let t="";throw e.id||(t+=(t.length?", ":"")+"id"),e.pvalue||(t+=(t.length?", ":"")+"pvalue"),new Error(`Unable to find necessary column(s) for merge: ${t} (available: ${e._names_})`)}n=t.body[function(e,t){let r;r=/log/.test(t=t||"log_pvalue")?function(e,t){return e>t}:function(e,t){return e<t};let n=e[0][t],o=0;for(let s=1;s<e.length;s++)r(e[s][t],n)&&(n=e[s][t],o=s);return o}(t.body,e.pvalue)][e.id]}const o=n&&n.match(/^(?:chr)?([a-zA-Z0-9]+?)[_:-](\d+)[_:|-]?(\w+)?[/_:|-]?([^_]+)?_?(.*)?/);if(!o)throw new Error("Could not request LD for a missing or incomplete marker format");const[s,i,a,u,c]=o;let d=`${i}:${a}`;return u&&c&&(d+=`_${u}/${c}`),[d,s]}getURL(e,t,r){const o=e.genome_build||this.params.build||"GRCh37";let s=e.ld_source||this.params.source||"1000G";const i=e.ld_pop||this.params.population||"ALL",a=this.params.method||"rsquare";"1000G"===s&&"GRCh38"===o&&(s="1000G-FRZ09"),n(this.constructor.name,o,null);const[u,c]=this.getRefvar(e,t,r);return t.header.ldrefvar=c,[this.url,"genome_builds/",o,"/references/",s,"/populations/",i,"/variants","?correlation=",a,"&variant=",encodeURIComponent(u),"&chrom=",encodeURIComponent(e.chr),"&start=",encodeURIComponent(e.start),"&stop=",encodeURIComponent(e.end)].join("")}getCacheKey(e,t,r){const n=super.getCacheKey(e,t,r);let o=e.ld_source||this.params.source||"1000G";const s=e.ld_pop||this.params.population||"ALL",[i,a]=this.getRefvar(e,t,r);return`${n}_${i}_${o}_${s}`}combineChainBody(e,t,r,n,o){let s=this.findMergeFields(t),i=this.findRequestedFields(r,n);if(!s.position)throw new Error("Unable to find position field for merge: "+s._names_);let a=e.rsquare?"rsquare":"correlation";return function(e,t,r,n){let o=0,i=0;for(;o<e.length&&i<t.position2.length;)e[o][s.position]===t.position2[i]?(e[o][r]=t[n][i],o++,i++):e[o][s.position]<t.position2[i]?o++:i++}(t.body,e,i.ldout,a),i.isrefvarin&&t.header.ldrefvar&&function(e,t,r,n,o){for(let s=0;s<e.length;s++)e[s][r]&&e[s][r]===t?(e[s][n]=1,e[s][o]=1):e[s][n]=0}(t.body,t.header.ldrefvar,s.id,i.isrefvarout,i.ldout),t.body}fetchRequest(e,t,r){let n=this.getURL(e,t,r),o={data:{}},s=function(e){return fetch(e).then().then(e=>{if(!e.ok)throw new Error(e.statusText);return e.text()}).then((function(e){return e=JSON.parse(e),Object.keys(e.data).forEach((function(t){o.data[t]=(o.data[t]||[]).concat(e.data[t])})),e.next?s(e.next):o}))};return s(n)}}class u extends s{constructor(e){super(e),this.__dependentSource=!0}getURL(e,t,r){const o=e.genome_build||this.params.build;n(this.constructor.name,o,null);const s="GRCh38"===o?5:6,i=this.params.source||s;return`${this.url}?format=objects&sort=pos&filter=id eq ${i} and chrom eq '${e.chr}' and pos ge ${e.start} and pos le ${e.end}`}findMergeFields(e){const t=Object.keys(e).find((function(e){return e.match(/\b(position|pos)\b/i)}));if(!t)throw new Error("Could not find data to align with GWAS catalog results");return{pos:t}}extractFields(e,t,r,n){return e}combineChainBody(e,t,r,n,o){if(!e.length)return t.body;const s=n[r.indexOf("log_pvalue")];function i(e,t,r,n,o){const i=e.n_catalog_matches||0;if(e.n_catalog_matches=i+1,!(e[s]&&e[s]>t.log_pvalue))for(let s=0;s<r.length;s++){const i=r[s],a=n[s];let u=t[i];o&&o[s]&&(u=o[s](u)),e[a]=u}}const a=this.findMergeFields(t.body[0]),u=this.findMergeFields(e[0]);for(var c=0,d=0;c<t.body.length&&d<e.length;){var l=t.body[c],h=e[d];l[a.pos]===h[u.pos]?(i(l,h,r,n,o),d+=1):l[a.pos]<h[u.pos]?c+=1:d+=1}return t.body}}class c extends s{getURL(e,t,r){const o=e.genome_build||this.params.build;let s=this.params.source;return n(this.constructor.name,o,s),o&&(s="GRCh38"===o?4:5),`${this.url}?filter=source in ${s} and chrom eq '${e.chr}' and start le ${e.end} and end ge ${e.start}`}normalizeResponse(e){return e}extractFields(e,t,r,n){return e}}class d extends s{constructor(e){super(e),this.__dependentSource=!0}getURL(){return this.url}normalizeResponse(e){return e}fetchRequest(e,t,r){const n=e.genome_build||this.params.build;if(!n)throw new Error(`Data source ${this.constructor.name} must specify a 'genome_build' option`);const o=t.body.reduce((function(e,t){return e[t.gene_name]=null,e}),{});let s=Object.keys(o).map((function(e){return`${"_"+e.replace(/[^A-Za-z0-9_]/g,"_")}: gene(gene_symbol: "${e}", reference_genome: ${n}) { gnomad_constraint { exp_syn obs_syn syn_z oe_syn oe_syn_lower oe_syn_upper exp_mis obs_mis mis_z oe_mis oe_mis_lower oe_mis_upper exp_lof obs_lof pLI oe_lof oe_lof_lower oe_lof_upper } } `}));if(!s.length)return Promise.resolve({data:null});s=`{${s.join(" ")} }`;const i=this.getURL(e,t,r),a=JSON.stringify({query:s});return fetch(i,{method:"POST",body:a,headers:{"Content-Type":"application/json"}}).then(e=>e.ok?e.text():[]).catch(e=>[])}combineChainBody(e,t,r,n,o){return e?(t.body.forEach((function(t){const r="_"+t.gene_name.replace(/[^A-Za-z0-9_]/g,"_"),n=e[r]&&e[r].gnomad_constraint;n&&Object.keys(n).forEach((function(e){let r=n[e];void 0===t[e]&&("number"==typeof r&&r.toString().includes(".")&&(r=parseFloat(r.toFixed(2))),t[e]=r)}))})),t.body):t}}class l extends s{getURL(e,t,r){const o=e.genome_build||this.params.build;let s=this.params.source;return n(this.constructor.SOURCE_NAME,o,s),o&&(s="GRCh38"===o?16:15),`${this.url}?filter=id in ${s} and chromosome eq '${e.chr}' and position le ${e.end} and position ge ${e.start}`}}class h extends o{parseInit(e){this._data=e}getRequest(e,t,r){return Promise.resolve(this._data)}}class p extends s{getURL(e,t,r){const n=(e.genome_build?[e.genome_build]:null)||this.params.build;if(!n||!Array.isArray(n)||!n.length)throw new Error(["Data source",this.constructor.SOURCE_NAME,"requires that you specify array of one or more desired genome build names"].join(" "));return[this.url,"?filter=variant eq '",encodeURIComponent(e.variant),"'&format=objects&",n.map((function(e){return"build="+encodeURIComponent(e)})).join("&")].join("")}getCacheKey(e,t,r){return this.getURL(e,t,r)}}class f extends o{constructor(e){if(super(e),!e||!e.sources)throw new Error("Connectors must specify the data they require as init.sources = {internal_name: chain_source_id}} pairs");this._source_name_mapping=e.sources;const t=Object.keys(e.sources);this._getRequiredSources().forEach(e=>{if(!t.includes(e))throw new Error(`Configuration for ${this.constructor.name} must specify a source ID corresponding to ${e}`)})}parseInit(){}getRequest(e,t,r){return Object.keys(this._source_name_mapping).forEach(e=>{const r=this._source_name_mapping[e];if(t.discrete&&!t.discrete[r])throw new Error(`${this.constructor.name} cannot be used before loading required data for: ${r}`)}),Promise.resolve(t.body||[])}parseResponse(e,t,r,n,o){return Promise.resolve(this.combineChainBody(e,t,r,n,o)).then((function(e){return{header:t.header||{},discrete:t.discrete||{},body:e}}))}combineChainBody(e,t){throw new Error("This method must be implemented in a subclass")}_getRequiredSources(){throw new Error("Must specify an array that identifes the kind of data required by this source")}}},4:function(e,t){e.exports=raremetal}}).default;
//# sourceMappingURL=lz-aggregation-tests.min.js.map