/*! Locuszoom 0.13.0-beta.3 */
var LzAggregationTests =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./esm/ext/lz-aggregation-tests.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./esm/data/adapters.js":
/*!******************************!*\
  !*** ./esm/data/adapters.js ***!
  \******************************/
/*! exports provided: BaseAdapter, BaseApiAdapter, AssociationLZ, ConnectorSource, GeneConstraintLZ, GeneLZ, GwasCatalogLZ, LDServer, PheWASLZ, RecombLZ, StaticSource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseAdapter", function() { return BaseAdapter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseApiAdapter", function() { return BaseApiAdapter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssociationLZ", function() { return AssociationLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConnectorSource", function() { return ConnectorSource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeneConstraintLZ", function() { return GeneConstraintLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeneLZ", function() { return GeneLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GwasCatalogLZ", function() { return GwasCatalogLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LDServer", function() { return LDServer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PheWASLZ", function() { return PheWASLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RecombLZ", function() { return RecombLZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticSource", function() { return StaticSource; });
/**
 * Define standard data adapters used to retrieve data (usually from REST APIs)
 * @module
 */

function validateBuildSource(class_name, build, source) {
    // Build OR Source, not both
    if ((build && source) || !(build || source)) {
        throw new Error(`${class_name} must provide a parameter specifying either "build" or "source". It should not specify both.`);
    }
    // If the build isn't recognized, our APIs can't transparently select a source to match
    if (build && !['GRCh37', 'GRCh38'].includes(build)) {
        throw new Error(`${class_name} must specify a valid genome build number`);
    }
}


/**
 * Base class for LocusZoom data sources (any). See also: BaseApiAdapter
 * @public
 */
class BaseAdapter {
    constructor(config) {
        /**
         * Whether this source should enable caching
         * @member {Boolean}
         */
        this._enableCache = true;
        this._cachedKey = null;

        // Almost all LZ sources are "region based". Cache the region requested and use it to determine whether
        //   the cache would satisfy the request.
        this._cache_pos_start = null;
        this._cache_pos_end = null;

        /**
         * Whether this data source type is dependent on previous requests- for example, the LD source cannot annotate
         *  association data if no data was found for that region.
         * @member {boolean}
         */
        this.__dependentSource = false;

        // Parse configuration options
        this.parseInit(config);
    }

    /**
     * Parse configuration used to create the data source. Many custom sources will override this method to suit their
     *  needs (eg specific config options, or for sources that do not retrieve data from a URL)
     * @protected
     * @param {String|Object} config Basic configuration- either a url, or a config object
     * @param {String} [config.url] The datasource URL
     * @param {String} [config.params] Initial config params for the datasource
     */
    parseInit(config) {
        /** @member {Object} */
        this.params = config.params || {};
    }

    /**
     * A unique identifier that indicates whether cached data is valid for this request. For most sources using GET
     *  requests to a REST API, this is usually the region requested. Some sources will append additional params to define the request.
     *
     *  This means that to change caching behavior, both the URL and the cache key may need to be updated. However,
     *      it allows most datasources to skip an extra network request when zooming in.
     * @protected
     * @param {Object} state Information available in plot.state (chr, start, end). Sometimes used to inject globally
     *  available information that influences the request being made.
     * @param {Object} chain The data chain from previous requests made in a sequence.
     * @param fields
     * @returns {String}
     */
    getCacheKey(state, chain, fields) {
        // Most region sources, by default, will cache the largest region that satisfies the request: zooming in
        //  should be satisfied via the cache, but pan or region change operations will cause a network request

        // Some data source rely on values set in chain.header during the getURL call. (eg, the LD source uses
        //  this to find the LD refvar) Calling this method is a backwards-compatible way of ensuring that value is set,
        //  even on a cache hit in which getURL otherwise wouldn't be called.
        // Some of the data sources that rely on this behavior are user-defined, hence compatibility hack
        this.getURL(state, chain, fields);

        const cache_pos_chr = state.chr;
        const {_cache_pos_start, _cache_pos_end} = this;
        if (_cache_pos_start && state.start >= _cache_pos_start && _cache_pos_end && state.end <= _cache_pos_end ) {
            return `${cache_pos_chr}_${_cache_pos_start}_${_cache_pos_end}`;
        } else {
            return `${state.chr}_${state.start}_${state.end}`;
        }
    }

    /**
     * Stub: build the URL for any requests made by this source.
     * @protected
     */
    getURL(state, chain, fields) {
        return this.url;
    }

    /**
     * Perform a network request to fetch data for this source. This is usually the method that is used to override
     *  when defining how to retrieve data.
     * @protected
     * @param {Object} state The state of the parent plot
     * @param chain
     * @param fields
     * @returns {Promise}
     */
    fetchRequest(state, chain, fields) {
        const url = this.getURL(state, chain, fields);
        return fetch(url).then((response) => {
            if (!response.ok) {
                throw new Error(response.statusText);
            }
            return response.text();
        });
    }

    /**
     * Gets the data for just this source, typically via a network request (but using cache where possible)
     *
     * For most use cases, it is better to override `fetchRequest` instead, to avoid bypassing the cache mechanism
     * by accident.
     * @protected
     * @return {Promise}
     */
    getRequest(state, chain, fields) {
        let req;
        const cacheKey = this.getCacheKey(state, chain, fields);

        if (this._enableCache && typeof(cacheKey) !== 'undefined' && cacheKey === this._cachedKey) {
            req = Promise.resolve(this._cachedResponse);  // Resolve to the value of the current promise
        } else {
            req = this.fetchRequest(state, chain, fields);
            if (this._enableCache) {
                this._cachedKey = cacheKey;
                this._cache_pos_start = state.start;
                this._cache_pos_end = state.end;
                this._cachedResponse = req;
            }
        }
        return req;
    }

    /**
     * Ensure the server response is in a canonical form, an array of one object per record. [ {field: oneval} ].
     * If the server response contains columns, reformats the response from {column1: [], column2: []} to the above.
     *
     * Does not apply namespacing, transformations, or field extraction.
     *
     * May be overridden by data sources that inherently return more complex payloads, or that exist to annotate other
     *  sources (eg, if the payload provides extra data rather than a series of records).
     * @protected
     * @param {Object[]|Object} data The original parsed server response
     */
    normalizeResponse(data) {
        if (Array.isArray(data)) {
            // Already in the desired form
            return data;
        }
        // Otherwise, assume the server response is an object representing columns of data.
        // Each array should have the same length (verify), and a given array index corresponds to a single row.
        const keys = Object.keys(data);
        const N = data[keys[0]].length;
        const sameLength = keys.every(function (key) {
            const item = data[key];
            return item.length === N;
        });
        if (!sameLength) {
            throw new Error(`${this.constructor.name} expects a response in which all arrays of data are the same length`);
        }

        // Go down the rows, and create an object for each record
        const records = [];
        const fields = Object.keys(data);
        for (let i = 0; i < N; i++) {
            const record = {};
            for (let j = 0; j < fields.length; j++) {
                record[fields[j]] = data[fields[j]][i];
            }
            records.push(record);
        }
        return records;
    }

    /**
     * Hook to post-process the data returned by this source with new, additional behavior.
     *   (eg cleaning up API values or performing complex calculations on the returned data)
     *
     * @protected
     * @param {Object[]} records The parsed data from the source (eg standardized api response)
     * @param {Object} chain The data chain object. For example, chain.headers may provide useful annotation metadata
     * @returns {Object[]|Promise} The modified set of records
     */
    annotateData(records, chain) {
        // Default behavior: no transformations
        return records;
    }

    /**
     * Clean up the server records for use by datalayers: extract only certain fields, with the specified names.
     *   Apply per-field transformations as appropriate.
     *
     * This hook can be overridden, eg to create a source that always returns all records and ignores the "fields" array.
     *  This is particularly common for sources at the end of a chain- many "dependent" sources do not allow
     *  cherry-picking individual fields, in which case by **convention** the fields array specifies "last_source_name:all"
     *
     * @protected
     * @param {Object[]} data One record object per element
     * @param {String[]} fields The names of fields to extract (as named in the source data). Eg "afield"
     * @param {String[]} outnames How to represent the source fields in the output. Eg "namespace:afield|atransform"
     * @param {function[]} trans An array of transformation functions (if any). One function per data element, or null.
     * @protected
     */
    extractFields (data, fields, outnames, trans) {
        //intended for an array of objects
        //  [ {"id":1, "val":5}, {"id":2, "val":10}]
        // Since a number of sources exist that do not obey this format, we will provide a convenient pass-through
        if (!Array.isArray(data)) {
            return data;
        }

        if (!data.length) {
            // Sometimes there are regions that just don't have data- this should not trigger a missing field error message!
            return data;
        }

        const fieldFound = [];
        for (let k = 0; k < fields.length; k++) {
            fieldFound[k] = 0;
        }

        const records = data.map(function (item) {
            const output_record = {};
            for (let j = 0; j < fields.length; j++) {
                let val = item[fields[j]];
                if (typeof val != 'undefined') {
                    fieldFound[j] = 1;
                }
                if (trans && trans[j]) {
                    val = trans[j](val);
                }
                output_record[outnames[j]] = val;
            }
            return output_record;
        });
        fieldFound.forEach(function(v, i) {
            if (!v) {
                throw new Error(`field ${fields[i]} not found in response for ${outnames[i]}`);
            }
        });
        return records;
    }

    /**
     * Combine records from this source with others in the chain to yield final chain body.
     *   Handles merging this data with other sources (if applicable).
     *
     * @protected
     * @param {Object[]} data The data That would be returned from this source alone
     * @param {Object} chain The data chain built up during previous requests
     * @param {String[]} fields
     * @param {String[]} outnames
     * @param {String[]} trans
     * @return {Promise|Object[]} The new chain body
     */
    combineChainBody(data, chain, fields, outnames, trans) {
        return data;
    }

    /**
     * Coordinates the work of parsing a response and returning records. This is broken into 4 steps, which may be
     *  overridden separately for fine-grained control. Each step can return either raw data or a promise.
     *
     * @protected
     *
     * @param {String|Object} resp The raw data associated with the response
     * @param {Object} chain The combined parsed response data from this and all other requests made in the chain
     * @param {String[]} fields Array of requested field names (as they would appear in the response payload)
     * @param {String[]} outnames  Array of field names as they will be represented in the data returned by this source,
     *  including the namespace. This must be an array with the same length as `fields`
     * @param {Function[]} trans The collection of transformation functions to be run on selected fields.
     *     This must be an array with the same length as `fields`
     * @returns {Promise} A promise that resolves to an object containing
     *   request metadata (`headers: {}`), the consolidated data for plotting (`body: []`), and the individual responses that would be
     *   returned by each source in the chain in isolation (`discrete: {}`)
     */
    parseResponse (resp, chain, fields, outnames, trans) {
        const source_id = this.source_id || this.constructor.name;
        if (!chain.discrete) {
            chain.discrete = {};
        }

        const json = typeof resp == 'string' ? JSON.parse(resp) : resp;

        // Perform the 4 steps of parsing the payload and return a combined chain object
        return Promise.resolve(this.normalizeResponse(json.data || json))
            .then((standardized) => {
                // Perform calculations on the data from just this source
                return Promise.resolve(this.annotateData(standardized, chain));
            }).then((data) => {
                return Promise.resolve(this.extractFields(data, fields, outnames, trans));
            }).then((one_source_body) => {
                // Store a copy of the data that would be returned by parsing this source in isolation (and taking the
                //   fields array into account). This is useful when we want to re-use the source output in many ways.
                chain.discrete[source_id] = one_source_body;
                return Promise.resolve(this.combineChainBody(one_source_body, chain, fields, outnames, trans));
            }).then((new_body) => {
                return { header: chain.header || {}, discrete: chain.discrete, body: new_body };
            });
    }

    /**
     * Fetch the data from the specified data source, and apply transformations requested by an external consumer.
     * This is the public-facing datasource method that will most be called by the plot, but custom data sources will
     *  almost never want to override this method directly- more specific hooks are provided to control individual pieces
     *  of the request lifecycle.
     *
     * @private
     * @param {Object} state The current "state" of the plot, such as chromosome and start/end positions
     * @param {String[]} fields Array of field names that the plot has requested from this data source. (without the "namespace" prefix)
     * @param {String[]} outnames  Array describing how the output data should refer to this field. This represents the
     *     originally requested field name, including the namespace. This must be an array with the same length as `fields`
     * @param {Function[]} trans The collection of transformation functions to be run on selected fields.
     *     This must be an array with the same length as `fields`
     * @returns {function} A callable operation that can be used as part of the data chain
     */
    getData(state, fields, outnames, trans) {
        if (this.preGetData) { // TODO try to remove this method if at all possible
            const pre = this.preGetData(state, fields, outnames, trans);
            if (this.pre) {
                state = pre.state || state;
                fields = pre.fields || fields;
                outnames = pre.outnames || outnames;
                trans = pre.trans || trans;
            }
        }

        return (chain) => {
            if (this.__dependentSource && chain && chain.body && !chain.body.length) {
                // A "dependent" source should not attempt to fire a request if there is no data for it to act on.
                // Therefore, it should simply return the previous data chain.
                return Promise.resolve(chain);
            }

            return this.getRequest(state, chain, fields).then((resp) => {
                return this.parseResponse(resp, chain, fields, outnames, trans);
            });
        };
    }
}

/**
 * Base source for LocusZoom data sources that receive their data over the web. Adds default config parameters
 *  (and potentially other behavior) that are relevant to URL-based requests.
 */
class BaseApiAdapter extends BaseAdapter {
    parseInit(config) {
        super.parseInit(config);

        /** @member {String} */
        this.url = config.url;
        if (!this.url) {
            throw new Error('Source not initialized with required URL');
        }
    }
}

/**
 * Data Source for Association Data from the LocusZoom/ Portaldev API (or compatible). Defines how to make a requesr
 * @public
 */
class AssociationLZ extends BaseApiAdapter {
    preGetData (state, fields, outnames, trans) {
        // TODO: Modify internals to see if we can go without this method
        const id_field = this.params.id_field || 'id';
        [id_field, 'position'].forEach(function(x) {
            if (!fields.includes(x)) {
                fields.unshift(x);
                outnames.unshift(x);
                trans.unshift(null);
            }
        });
        return {fields: fields, outnames:outnames, trans:trans};
    }

    getURL (state, chain, fields) {
        const analysis = chain.header.analysis || this.params.source || this.params.analysis;  // Old usages called this param "analysis"
        if (typeof analysis == 'undefined') {
            throw new Error('Association source must specify an analysis ID to plot');
        }
        return `${this.url}results/?filter=analysis in ${analysis} and chromosome in  '${state.chr}' and position ge ${state.start} and position le ${state.end}`;
    }

    normalizeResponse (data) {
        // Some association sources do not sort their data in a predictable order, which makes it hard to reliably
        //  align with other sources (such as LD). For performance reasons, sorting is an opt-in argument.
        // TODO: Consider more fine grained sorting control in the future. This was added as a very specific
        //   workaround for the original T2D portal.
        data = super.normalizeResponse(data);
        if (this.params && this.params.sort && data.length && data[0]['position']) {
            data.sort(function (a, b) {
                return a['position'] - b['position'];
            });
        }
        return data;
    }
}

/**
 * Fetch linkage disequilibrium information from a UMich LDServer-compatible API
 *
 * This source is designed to connect its results to association data, and therefore depends on association data having
 *  been loaded by a previous request in the data chain.
 *
 * In older versions of LocusZoom, this was known as "LDServer". A prior source (targeted at older APIs) has been removed.
 */
class LDServer extends BaseApiAdapter {
    constructor(config) {
        super(config);
        this.__dependentSource = true;
    }

    preGetData(state, fields) {
        if (fields.length > 1) {
            if (fields.length !== 2 || !fields.includes('isrefvar')) {
                throw new Error(`LD does not know how to get all fields: ${fields.join(', ')}`);
            }
        }
    }

    findMergeFields(chain) {
        // Find the fields (as provided by a previous step in the chain, like an association source) that will be needed to
        //  combine LD data with existing information

        // Since LD information may be shared across multiple assoc sources with different namespaces,
        //   we use regex to find columns to join on, rather than requiring exact matches
        const exactMatch = function (arr) {
            return function () {
                const regexes = arguments;
                for (let i = 0; i < regexes.length; i++) {
                    const regex = regexes[i];
                    const m = arr.filter(function (x) {
                        return x.match(regex);
                    });
                    if (m.length) {
                        return m[0];
                    }
                }
                return null;
            };
        };
        let dataFields = {
            id: this.params.id_field,
            position: this.params.position_field,
            pvalue: this.params.pvalue_field,
            _names_:null,
        };
        if (chain && chain.body && chain.body.length > 0) {
            const names = Object.keys(chain.body[0]);
            const nameMatch = exactMatch(names);
            // Internally, fields are generally prefixed with the name of the source they come from.
            // If the user provides an id_field (like `variant`), it should work across data sources( `assoc1:variant`,
            //  assoc2:variant), but not match fragments of other field names (assoc1:variant_thing)
            // Note: these lookups hard-code a couple of common fields that will work based on known APIs in the wild
            const id_match = dataFields.id && nameMatch(new RegExp(`${dataFields.id}\\b`));
            dataFields.id = id_match || nameMatch(/\bvariant\b/) || nameMatch(/\bid\b/);
            dataFields.position = dataFields.position || nameMatch(/\bposition\b/i, /\bpos\b/i);
            dataFields.pvalue = dataFields.pvalue || nameMatch(/\bpvalue\b/i, /\blog_pvalue\b/i);
            dataFields._names_ = names;
        }
        return dataFields;
    }

    findRequestedFields (fields, outnames) {
        // Assumption: all usages of this source will only ever ask for "isrefvar" or "state". This maps to output names.
        let obj = {};
        for (let i = 0; i < fields.length; i++) {
            if (fields[i] === 'isrefvar') {
                obj.isrefvarin = fields[i];
                obj.isrefvarout = outnames && outnames[i];
            } else {
                obj.ldin = fields[i];
                obj.ldout = outnames && outnames[i];
            }
        }
        return obj;
    }

    normalizeResponse (data) {
        // The LD API payload does not obey standard format conventions; do not try to transform it.
        return data;
    }

    /**
     * Get the LD reference variant, which by default will be the most significant hit in the assoc results
     *   This will be used in making the original query to the LD server for pairwise LD information
     * @returns String[] Two strings: 1) the marker id (expected to be in `chr:pos_ref/alt` format) of the reference
     *  variant, and 2) the marker ID as it appears in the original dataset that we are joining to, so that the exact
     *  refvar can be marked when plotting the data..
     */
    getRefvar(state, chain, fields) {
        let findExtremeValue = function(records, pval_field) {
            // Finds the most significant hit (smallest pvalue, or largest -log10p). Will try to auto-detect the appropriate comparison.
            pval_field = pval_field || 'log_pvalue';  // The official LZ API returns log_pvalue
            const is_log = /log/.test(pval_field);
            let cmp;
            if (is_log) {
                cmp = function(a, b) {
                    return a > b;
                };
            } else {
                cmp = function(a, b) {
                    return a < b;
                };
            }
            let extremeVal = records[0][pval_field], extremeIdx = 0;
            for (let i = 1; i < records.length; i++) {
                if (cmp(records[i][pval_field], extremeVal)) {
                    extremeVal = records[i][pval_field];
                    extremeIdx = i;
                }
            }
            return extremeIdx;
        };

        let reqFields = this.findRequestedFields(fields);
        let refVar = reqFields.ldin;
        if (refVar === 'state') {
            refVar = state.ldrefvar || chain.header.ldrefvar || 'best';
        }
        if (refVar === 'best') {
            if (!chain.body) {
                throw new Error('No association data found to find best pvalue');
            }
            let keys = this.findMergeFields(chain);
            if (!keys.pvalue || !keys.id) {
                let columns = '';
                if (!keys.id) {
                    columns += `${columns.length ? ', ' : ''}id`;
                }
                if (!keys.pvalue) {
                    columns += `${columns.length ? ', ' : ''}pvalue`;
                }
                throw new Error(`Unable to find necessary column(s) for merge: ${columns} (available: ${keys._names_})`);
            }
            refVar = chain.body[findExtremeValue(chain.body, keys.pvalue)][keys.id];
        }
        // Some datasets, notably the Portal, use a different marker format.
        //  Coerce it into one that will work with the LDServer API. (CHROM:POS_REF/ALT)
        const REGEX_MARKER = /^(?:chr)?([a-zA-Z0-9]+?)[_:-](\d+)[_:|-]?(\w+)?[/_:|-]?([^_]+)?_?(.*)?/;
        const match = refVar && refVar.match(REGEX_MARKER);

        if (!match) {
            throw new Error('Could not request LD for a missing or incomplete marker format');
        }
        const [original, chrom, pos, ref, alt] = match;
        // Currently, the LD server only accepts full variant specs; it won't return LD w/o ref+alt. Allowing
        //  a partial match at most leaves room for potential future features.
        let refVar_formatted = `${chrom}:${pos}`;
        if (ref && alt) {
            refVar_formatted += `_${ref}/${alt}`;
        }

        return [refVar_formatted, original];
    }

    getURL(state, chain, fields) {
        // Accept the following params in this.params:
        // - method (r, rsquare, cov)
        // - source (aka panel)
        // - population (ALL, AFR, EUR, etc)
        // - build
        // The LD source/pop can be overridden from plot.state for dynamic layouts
        const build = state.genome_build || this.params.build || 'GRCh37'; // This isn't expected to change after the data is plotted.
        let source = state.ld_source || this.params.source || '1000G';
        const population = state.ld_pop || this.params.population || 'ALL';  // LDServer panels will always have an ALL
        const method = this.params.method || 'rsquare';

        if (source === '1000G' && build === 'GRCh38') {
            // For build 38 (only), there is a newer/improved 1000G LD panel available that uses WGS data. Auto upgrade by default.
            source = '1000G-FRZ09';
        }

        validateBuildSource(this.constructor.name, build, null);  // LD doesn't need to validate `source` option

        const [refVar_formatted, refVar_raw] = this.getRefvar(state, chain, fields);

        // Preserve the user-provided variant spec for use when matching to assoc data
        chain.header.ldrefvar = refVar_raw;

        return  [
            this.url, 'genome_builds/', build, '/references/', source, '/populations/', population, '/variants',
            '?correlation=', method,
            '&variant=', encodeURIComponent(refVar_formatted),
            '&chrom=', encodeURIComponent(state.chr),
            '&start=', encodeURIComponent(state.start),
            '&stop=', encodeURIComponent(state.end),
        ].join('');
    }

    getCacheKey(state, chain, fields) {
        const base = super.getCacheKey(state, chain, fields);
        let source = state.ld_source || this.params.source || '1000G';
        const population = state.ld_pop || this.params.population || 'ALL';  // LDServer panels will always have an ALL
        const [refVar, _] = this.getRefvar(state, chain, fields);
        return `${base}_${refVar}_${source}_${population}`;
    }

    combineChainBody(data, chain, fields, outnames, trans) {
        let keys = this.findMergeFields(chain);
        let reqFields = this.findRequestedFields(fields, outnames);
        if (!keys.position) {
            throw new Error(`Unable to find position field for merge: ${keys._names_}`);
        }
        const leftJoin = function (left, right, lfield, rfield) {
            let i = 0, j = 0;
            while (i < left.length && j < right.position2.length) {
                if (left[i][keys.position] === right.position2[j]) {
                    left[i][lfield] = right[rfield][j];
                    i++;
                    j++;
                } else if (left[i][keys.position] < right.position2[j]) {
                    i++;
                } else {
                    j++;
                }
            }
        };
        const tagRefVariant = function (data, refvar, idfield, outrefname, outldname) {
            for (let i = 0; i < data.length; i++) {
                if (data[i][idfield] && data[i][idfield] === refvar) {
                    data[i][outrefname] = 1;
                    data[i][outldname] = 1; // For label/filter purposes, implicitly mark the ref var as LD=1 to itself
                } else {
                    data[i][outrefname] = 0;
                }
            }
        };

        // LD servers vary slightly. Some report corr as "rsquare", others as "correlation"
        let corrField = data.rsquare ? 'rsquare' : 'correlation';
        leftJoin(chain.body, data, reqFields.ldout, corrField);
        if (reqFields.isrefvarin && chain.header.ldrefvar) {
            tagRefVariant(chain.body, chain.header.ldrefvar, keys.id, reqFields.isrefvarout, reqFields.ldout);
        }
        return chain.body;
    }

    fetchRequest(state, chain, fields) {
        // The API is paginated, but we need all of the data to render a plot. Depaginate and combine where appropriate.
        let url = this.getURL(state, chain, fields);
        let combined = { data: {} };
        let chainRequests = function (url) {
            return fetch(url).then().then((response) => {
                if (!response.ok) {
                    throw new Error(response.statusText);
                }
                return response.text();
            }).then(function(payload) {
                payload = JSON.parse(payload);
                Object.keys(payload.data).forEach(function (key) {
                    combined.data[key] = (combined.data[key] || []).concat(payload.data[key]);
                });
                if (payload.next) {
                    return chainRequests(payload.next);
                }
                return combined;
            });
        };
        return chainRequests(url);
    }
}

/**
 * Data source for GWAS catalogs of known variants
 * @public
 * @class
 * @param {Object|String} init Configuration (URL or object)
 * @param {Object} [init.params] Optional configuration parameters
 * @param {Number} [init.params.source=2] The ID of the chosen catalog. Defaults to EBI GWAS catalog, GRCh37
 * @param {('strict'|'loose')} [init.params.match_type='strict'] Whether to match on exact variant, or just position.
 */
class GwasCatalogLZ extends BaseApiAdapter {
    constructor(config) {
        super(config);
        this.__dependentSource = true;
    }

    getURL(state, chain, fields) {
        // This is intended to be aligned with another source- we will assume they are always ordered by position, asc
        //  (regardless of the actual match field)
        const build_option = state.genome_build || this.params.build;
        validateBuildSource(this.constructor.name, build_option, null); // Source can override build- not mutually exclusive

        // Most of our annotations will respect genome build before any other option.
        //   But there can be more than one GWAS catalog version available in the same API, for the same build- an
        //   explicit config option will always take
        //   precedence.
        // See: http://portaldev.sph.umich.edu/api/v1/annotation/gwascatalog/?format=objects
        const default_source = (build_option === 'GRCh38') ? 5 : 6;  // EBI GWAS catalog
        const source = this.params.source || default_source;
        return `${this.url  }?format=objects&sort=pos&filter=id eq ${source} and chrom eq '${state.chr}' and pos ge ${state.start} and pos le ${state.end}`;
    }

    findMergeFields(records) {
        // Data from previous sources is already namespaced. Find the alignment field by matching.
        const knownFields = Object.keys(records);
        // Note: All API endoints involved only give results for 1 chromosome at a time; match is implied
        const posMatch = knownFields.find(function (item) {
            return item.match(/\b(position|pos)\b/i);
        });

        if (!posMatch) {
            throw new Error('Could not find data to align with GWAS catalog results');
        }
        return { 'pos': posMatch };
    }

    extractFields (data, fields, outnames, trans) {
        // Skip the "individual field extraction" step; extraction will be handled when building chain body instead
        return data;
    }

    combineChainBody(data, chain, fields, outnames, trans) {
        if (!data.length) {
            return chain.body;
        }

        //  TODO: Better reuse options in the future. This source is very specifically tied to the UM PortalDev API, where
        //   the field name is always "log_pvalue". Relatively few sites will write their own gwas-catalog endpoint.
        const decider = 'log_pvalue';
        const decider_out = outnames[fields.indexOf(decider)];

        function leftJoin(left, right, fields, outnames, trans) { // Add `fields` from `right` to `left`
            // Add a synthetic, un-namespaced field to all matching records
            const n_matches = left['n_catalog_matches'] || 0;
            left['n_catalog_matches'] = n_matches + 1;
            if (decider && left[decider_out] && left[decider_out] > right[decider]) {
                // There may be more than one GWAS catalog entry for the same SNP. This source is intended for a 1:1
                //  annotation scenario, so for now it only joins the catalog entry that has the best -log10 pvalue
                return;
            }

            for (let j = 0; j < fields.length; j++) {
                const fn = fields[j];
                const outn = outnames[j];

                let val = right[fn];
                if (trans && trans[j]) {
                    val = trans[j](val);
                }
                left[outn] = val;
            }
        }

        const chainNames = this.findMergeFields(chain.body[0]);
        const catNames = this.findMergeFields(data[0]);

        var i = 0, j = 0;
        while (i < chain.body.length && j < data.length) {
            var left = chain.body[i];
            var right = data[j];

            if (left[chainNames.pos] === right[catNames.pos]) {
                // There may be multiple catalog entries for each matching SNP; evaluate match one at a time
                leftJoin(left, right, fields, outnames, trans);
                j += 1;
            } else if (left[chainNames.pos] < right[catNames.pos]) {
                i += 1;
            } else {
                j += 1;
            }
        }
        return chain.body;
    }
}

/**
 * Data Source for Gene Data, as fetched from the LocusZoom/Portaldev API server (or compatible format)
 * @public
 */
class GeneLZ extends BaseApiAdapter {
    getURL(state, chain, fields) {
        const build = state.genome_build || this.params.build;
        let source = this.params.source;
        validateBuildSource(this.constructor.name, build, source);

        if (build) {
            // If build specified, we auto-select the best current portaldev API dataset for that build
            // If build is not specified, we use the exact source ID provided by the user.
            // See: https://portaldev.sph.umich.edu/api/v1/annotation/genes/sources/?format=objects
            source = (build === 'GRCh38') ? 4 : 5;
        }
        return `${this.url}?filter=source in ${source} and chrom eq '${state.chr}' and start le ${state.end} and end ge ${state.start}`;
    }

    normalizeResponse(data) {
        // Genes have a very complex internal data format. Bypass any record parsing, and provide the data layer with
        // the exact information returned by the API. (ignoring the fields array in the layout)
        return data;
    }

    extractFields(data, fields, outnames, trans) {
        return data;
    }
}

/**
 * Data Source for Gene Constraint Data, as fetched from the gnomAD server (or compatible)
 *
 * This is intended to be the second request in a chain, with special logic that connects it to Genes data
 *  already fetched.
 *
 * @public
*/
class GeneConstraintLZ extends BaseApiAdapter {
    constructor(config) {
        super(config);
        this.__dependentSource = true;
    }
    getURL() {
        // GraphQL API: request details are encoded in the body, not the URL
        return this.url;
    }

    normalizeResponse(data) {
        return data;
    }

    fetchRequest(state, chain, fields) {
        const build = state.genome_build || this.params.build;
        if (!build) {
            throw new Error(`Data source ${this.constructor.name} must specify a 'genome_build' option`);
        }

        const unique_gene_names = chain.body.reduce(
            // In rare cases, the same gene symbol may appear at multiple positions. (issue #179) We de-duplicate the
            //  gene names to avoid issuing a malformed GraphQL query.
            function (acc, gene) {
                acc[gene.gene_name] = null;
                return acc;
            },
            {}
        );
        let query = Object.keys(unique_gene_names).map(function (gene_name) {
            // GraphQL alias names must match a specific set of allowed characters: https://stackoverflow.com/a/45757065/1422268
            const alias = `_${gene_name.replace(/[^A-Za-z0-9_]/g, '_')}`;
            // Each gene symbol is a separate graphQL query, grouped into one request using aliases
            return `${alias}: gene(gene_symbol: "${gene_name}", reference_genome: ${build}) { gnomad_constraint { exp_syn obs_syn syn_z oe_syn oe_syn_lower oe_syn_upper exp_mis obs_mis mis_z oe_mis oe_mis_lower oe_mis_upper exp_lof obs_lof pLI oe_lof oe_lof_lower oe_lof_upper } } `;
        });

        if (!query.length) {
            // If there are no genes, skip the network request
            return Promise.resolve({ data: null });
        }

        query = `{${query.join(' ')} }`; // GraphQL isn't quite JSON; items are separated by spaces but not commas
        const url = this.getURL(state, chain, fields);
        // See: https://graphql.org/learn/serving-over-http/
        const body = JSON.stringify({ query: query });
        const headers = { 'Content-Type': 'application/json' };

        // Note: The gnomAD API sometimes fails randomly.
        // If request blocked, return  a fake "no data" signal so the genes track can still render w/o constraint info
        return fetch(url, { method: 'POST', body, headers }).then((response) => {
            if (!response.ok) {
                return [];
            }
            return response.text();
        }).catch((err) => []);
    }

    combineChainBody(data, chain, fields, outnames, trans) {
        if (!data) {
            return chain;
        }

        chain.body.forEach(function(gene) {
            // Find payload keys that match gene names in this response
            const alias = `_${gene.gene_name.replace(/[^A-Za-z0-9_]/g, '_')}`;  // aliases are modified gene names
            const constraint = data[alias] && data[alias]['gnomad_constraint']; // gnomad API has two ways of specifying missing data for a requested gene
            if (constraint) {
                // Add all fields from constraint data- do not override fields present in the gene source
                Object.keys(constraint).forEach(function (key) {
                    let val = constraint[key];
                    if (typeof gene[key] === 'undefined') {
                        if (typeof val == 'number' && val.toString().includes('.')) {
                            val = parseFloat(val.toFixed(2));
                        }
                        gene[key] = val;   // These two sources are both designed to bypass namespacing
                    }
                });
            }
        });
        return chain.body;
    }
}

/**
 * Data Source for Recombination Rate Data, as fetched from the LocusZoom API server (or compatible)
 * @public
 */
class RecombLZ extends BaseApiAdapter {
    getURL(state, chain, fields) {
        const build = state.genome_build || this.params.build;
        let source = this.params.source;
        validateBuildSource(this.constructor.SOURCE_NAME, build, source);

        if (build) { // If build specified, choose a known Portal API dataset IDs (build 37/38)
            source = (build === 'GRCh38') ? 16 : 15;
        }
        return `${this.url}?filter=id in ${source} and chromosome eq '${state.chr}' and position le ${state.end} and position ge ${state.start}`;
    }
}

/**
 * Data Source for static blobs of data as raw JS objects. This does not perform additional parsing, which is required
 *  for some sources (eg when joining together LD and association data).
 *
 * Therefore it is the responsibility of the user to pass information in a format that can be read and
 * understood by the chosen plot- a StaticJSON source is rarely a drop-in replacement.
 *
 * This source is largely here for legacy reasons. More often, a convenient way to serve static data is as separate
 *  JSON files to an existing source (with the JSON url in place of an API).
 * @public
 */
class StaticSource extends BaseAdapter {
    parseInit(data) {
        // Does not receive any config; the only argument is the raw data, embedded when source is created
        this._data = data;
    }
    getRequest(state, chain, fields) {
        return Promise.resolve(this._data);
    }
}


/**
 * Data source for PheWAS data retrieved from a LocusZoom/PortalDev compatible API
 * @public
 * @param {String[]} init.params.build This datasource expects to be provided the name of the genome build that will
 *   be used to provide pheWAS results for this position. Note positions may not translate between builds.
 */
class PheWASLZ extends BaseApiAdapter {
    getURL(state, chain, fields) {
        const build = (state.genome_build ? [state.genome_build] : null) || this.params.build;
        if (!build || !Array.isArray(build) || !build.length) {
            throw new Error(['Data source', this.constructor.SOURCE_NAME, 'requires that you specify array of one or more desired genome build names'].join(' '));
        }
        const url = [
            this.url,
            "?filter=variant eq '", encodeURIComponent(state.variant), "'&format=objects&",
            build.map(function (item) {
                return `build=${encodeURIComponent(item)}`;
            }).join('&'),
        ];
        return url.join('');
    }

    getCacheKey(state, chain, fields) {
        // This is not a region-based source; it doesn't make sense to cache by a region
        return this.getURL(state, chain, fields);
    }
}


/**
 * Base class for "connectors"- this is meant to be subclassed, rather than used directly.
 *
 * A connector is a source that makes no server requests and caches no data of its own. Instead, it decides how to
 *  combine data from other sources in the chain. Connectors are useful when we want to request (or calculate) some
 *  useful piece of information once, but apply it to many different kinds of record types.
 *
 * Typically, a subclass will implement the field merging logic in `combineChainBody`.
 *
 * @public
 * @param {Object} init Configuration for this source
 * @param {Object} init.sources Specify how the hard-coded logic should find the data it relies on in the chain,
 *  as {internal_name: chain_source_id} pairs. This allows writing a reusable connector that does not need to make
 *  assumptions about what namespaces a source is using.
 * @type {*|Function}
 */
class ConnectorSource extends BaseAdapter {
    constructor(config) {
        super(config);

        if (!config || !config.sources) {
            throw new Error('Connectors must specify the data they require as init.sources = {internal_name: chain_source_id}} pairs');
        }

        /**
         * Tells the connector how to find the data it relies on
         *
         * For example, a connector that applies burden test information to the genes layer might specify:
         *  {gene_ns: "gene", aggregation_ns: "aggregation"}
         *
         * @member {Object}
         */
        this._source_name_mapping = config.sources;

        // Validate that this source has been told how to find the required information
        const specified_ids = Object.keys(config.sources);
        /** @property {String[]} Specifies the sources that must be provided in the original config object */

        this._getRequiredSources().forEach((k) => {
            if (!specified_ids.includes(k)) {
                // TODO: Fix constructor.name usage in minified bundles
                throw new Error(`Configuration for ${this.constructor.name} must specify a source ID corresponding to ${k}`);
            }
        });
    }

    // Stub- connectors don't have their own url or data, so the defaults don't make sense
    parseInit() {}

    getRequest(state, chain, fields) {
        // Connectors do not request their own data by definition, but they *do* depend on other sources having been loaded
        //  first. This method performs basic validation, and preserves the accumulated body from the chain so far.
        Object.keys(this._source_name_mapping).forEach((ns) => {
            const chain_source_id = this._source_name_mapping[ns];
            if (chain.discrete && !chain.discrete[chain_source_id]) {
                throw new Error(`${this.constructor.name} cannot be used before loading required data for: ${chain_source_id}`);
            }
        });
        return Promise.resolve(chain.body || []);
    }

    parseResponse(data, chain, fields, outnames, trans) {
        // A connector source does not update chain.discrete, but it may use it. It bypasses data formatting
        //  and field selection (both are assumed to have been done already, by the previous sources this draws from)

        // Because of how the chain works, connectors are not very good at applying new transformations or namespacing.
        // Typically connectors are called with `connector_name:all` in the fields array.
        return Promise.resolve(this.combineChainBody(data, chain, fields, outnames, trans))
            .then(function(new_body) {
                return {header: chain.header || {}, discrete: chain.discrete || {}, body: new_body};
            });
    }

    combineChainBody(records, chain) {
        // Stub method: specifies how to combine the data
        throw new Error('This method must be implemented in a subclass');
    }

    /**
     * Helper method since ES6 doesn't support class fields
     * @private
     */
    _getRequiredSources() {
        throw new Error('Must specify an array that identifes the kind of data required by this source');
    }
}






/***/ }),

/***/ "./esm/ext/lz-aggregation-tests.js":
/*!*****************************************!*\
  !*** ./esm/ext/lz-aggregation-tests.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var raremetal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! raremetal.js */ "raremetal.js");
/* harmony import */ var raremetal_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(raremetal_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _data_adapters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../data/adapters */ "./esm/data/adapters.js");
/** @module */
/*
 * LocusZoom extensions used to calculate and render aggregation test results. Because these calculations depend on an
 *   external library, the special data sources are defined here, rather than in LocusZoom core code.
 *
 *     The page must incorporate and load all libraries before this file can be used, including:
 *    - Vendor assets
 *    - LocusZoom
 *    - raremetal.js (available via NPM or a related CDN)
 */
// This is defined as a UMD module, to work with multiple different module systems / bundlers
// Arcane build note: everything defined here gets registered globally. This is not a "pure" module, and some build
//  systems may require being told that this file has side effects.





function install (LocusZoom) {
    /**
     * Data Source that calculates gene or region-based tests based on provided data
     *   It will rarely be used by itself, but rather using a connector that attaches the results to data from
     *   another source (like genes). Using a separate connector allows us to add caching and run this front-end
     *   calculation only once, while using it in many different places
     * @public
     */
    const BaseAdapter = LocusZoom.Adapters.get('BaseAdapter');
    const ConnectorSource = LocusZoom.Adapters.get('ConnectorSource');

    class AggregationTestSource extends _data_adapters__WEBPACK_IMPORTED_MODULE_1__["BaseApiAdapter"] {
        getURL(state, chain, fields) {
            // Unlike most sources, calculations may require access to plot state data even after the initial request
            // This example source REQUIRES that the external UI widget would store the needed test definitions in a plot state
            //  field called `aggregation_tests` (an object {masks: [], calcs: {})
            const required_info = state.aggregation_tests || {};

            if (!chain.header) {
                chain.header = {};
            }
            // All of these fields are required in order to use this datasource. TODO: Add validation?
            chain.header.aggregation_genoset_id = required_info.genoset_id || null; // Number
            chain.header.aggregation_genoset_build = required_info.genoset_build || null; // String
            chain.header.aggregation_phenoset_id = required_info.phenoset_id || null;  // Number
            chain.header.aggregation_pheno = required_info.pheno || null; // String
            chain.header.aggregation_calcs = required_info.calcs || {};  // String[]
            const mask_data = required_info.masks || [];
            chain.header.aggregation_masks = mask_data;  // {name:desc}[]
            chain.header.aggregation_mask_ids = mask_data.map(function (item) {
                return item.name;
            }); // Number[]
            return this.url;
        }

        getCacheKey(state, chain, fields) {
            this.getURL(state, chain, fields);  // TODO: This just sets the chain.header fields
            return JSON.stringify({
                chrom: state.chr,
                start: state.start,
                stop: state.end,
                genotypeDataset: chain.header.aggregation_genoset_id,
                phenotypeDataset: chain.header.aggregation_phenoset_id,
                phenotype: chain.header.aggregation_pheno,
                samples: 'ALL',
                genomeBuild: chain.header.aggregation_genoset_build,
                masks: chain.header.aggregation_mask_ids,
            });
        }

        fetchRequest(state, chain, fields) {
            const url = this.getURL(state, chain, fields);
            const body = this.getCacheKey(state, chain, fields);
            const headers = {
                'Content-Type': 'application/json',
            };

            return fetch(url, {method: 'POST', body: body, headers: headers}).then((response) => {
                if (!response.ok) {
                    throw new Error(response.statusText);
                }
                return response.text();
            }).then(function (resp) {
                const json = typeof resp == 'string' ? JSON.parse(resp) : resp;
                if (json.error) {
                    // RAREMETAL-server quirk: The API sometimes returns a 200 status code for failed requests,
                    //    with a human-readable error description as a key
                    // For now, this should be treated strictly as an error
                    throw new Error(json.error);
                }
                return json;
            });
        }

        annotateData(records, chain) {
            // Operate on the calculated results. The result of this method will be added to chain.discrete

            // In a page using live API data, the UI would only request the masks it needs from the API.
            // But in our demos, sometimes boilerplate JSON has more masks than the UI asked for. Limit what calcs we run (by
            //  type, and to the set of groups requested by the user)

            // The Raremetal-server API has a quirk: it returns a different payload structure if no groups are defined
            //  for the request region. Detect when that happens and end the calculation immediately in that case
            if (!records.groups) {
                return { groups: [], variants: [] };
            }

            records.groups = records.groups.filter(function (item) {
                return item.groupType === 'GENE';
            });

            const parsed = raremetal_js__WEBPACK_IMPORTED_MODULE_0__["helpers"].parsePortalJSON(records);
            let groups = parsed[0];
            const variants = parsed[1];
            // Some APIs may return more data than we want (eg simple sites that are just serving up premade scorecov json files).
            //  Filter the response to just what the user has chosen to analyze.
            groups = groups.byMask(chain.header.aggregation_mask_ids);

            // Determine what calculations to run
            const calcs = chain.header.aggregation_calcs;
            if (!calcs || Object.keys(calcs).length === 0) {
                // If no calcs have been requested, then return a dummy placeholder immediately
                return { variants: [], groups: [], results: [] };
            }
            const runner = new raremetal_js__WEBPACK_IMPORTED_MODULE_0__["helpers"].PortalTestRunner(groups, variants, calcs);

            return runner.toJSON()
                .then(function (res) {
                    // Internally, raremetal helpers track how the calculation is done, but not any display-friendly values
                    // We will annotate each mask name (id) with a human-friendly description for later use
                    const mask_id_to_desc = chain.header.aggregation_masks.reduce(function (acc, val) {
                        acc[val.name] = val.description;
                        return acc;
                    }, {});
                    res.data.groups.forEach(function (group) {
                        group.mask_name = mask_id_to_desc[group.mask];
                    });
                    return res.data;
                })
                .catch(function (e) {
                    console.error(e);
                    throw new Error('Failed to calculate aggregation test results');
                });
        }

        normalizeResponse(data) {
            return data;
        }

        combineChainBody(records, chain) {
            // aggregation tests are a bit unique, in that the data is rarely used directly- instead it is used to annotate many
            //  other layers in different ways. The calculated result has been added to `chain.discrete`, but will not be returned
            //  as part of the response body built up by the chain
            return chain.body;
        }

    }

    class AssocFromAggregationLZ extends BaseAdapter {
        constructor(config) {
            if (!config || !config.from) {
                throw 'Must specify the name of the source that contains association data';
            }
            super(...arguments);
        }
        parseInit(config) {
            super.parseInit(config);
            this._from = config.from;
        }

        getRequest(state, chain, fields) {
            // Does not actually make a request. Just pick off the specific bundle of data from a known payload structure.
            if (chain.discrete && !chain.discrete[this._from]) {
                throw `${this.constructor.SOURCE_NAME} cannot be used before loading required data for: ${this._from}`;
            }
            // Copy the data so that mutations (like sorting) don't affect the original
            return Promise.resolve(JSON.parse(JSON.stringify(chain.discrete[this._from]['variants'])));
        }

        normalizeResponse(data) {
            // The payload structure of the association source is slightly different than the one required by association
            //   plots. For example, we need to parse variant names and convert to log_pvalue
            const REGEX_EPACTS = new RegExp('(?:chr)?(.+):(\\d+)_?(\\w+)?/?([^_]+)?_?(.*)?');  // match API variant strings
            return data.map((one_variant) => {
                const match = one_variant.variant.match(REGEX_EPACTS);
                return {
                    variant: one_variant.variant,
                    chromosome: match[1],
                    position: +match[2],
                    ref_allele: match[3],
                    ref_allele_freq: 1 - one_variant.altFreq,
                    log_pvalue: -Math.log10(one_variant.pvalue),
                };
            }).sort((a, b) => {
                a = a.variant;
                b = b.variant;
                if (a < b) {
                    return -1;
                } else if (a > b) {
                    return 1;
                } else {
                    // names must be equal
                    return 0;
                }
            });
        }
    }

    /**
     * A sample connector that aligns calculated aggregation test data with corresponding gene information. Returns a body
     *   suitable for use with the genes datalayer.
     *
     *  To use this source, one must specify a fields array that calls first the genes source, then a dummy field from
     *      this source. The output will be to transparently add several new fields to the genes data.
     * @public
     */
    class GeneAggregationConnectorLZ extends ConnectorSource {
        _getRequiredSources() {
            return ['gene_ns', 'aggregation_ns'];
        }

        combineChainBody(data, chain) {
            // The genes layer receives all results, and displays only the best pvalue for each gene

            // Tie the calculated group-test results to genes with a matching name
            const aggregation_source_id = this._source_name_mapping['aggregation_ns'];
            const gene_source_id = this._source_name_mapping['gene_ns'];
            // This connector assumes that genes are the main body of records from the chain, and that aggregation tests are
            //   a standalone source that has not acted on genes data yet
            const aggregationData = chain.discrete[aggregation_source_id];
            const genesData = chain.discrete[gene_source_id];

            const groupedAggregation = {};  // Group together all tests done on that gene- any mask, any test

            aggregationData.groups.forEach(function (result) {
                if (!Object.prototype.hasOwnProperty.call(groupedAggregation, result.group)) {
                    groupedAggregation[result.group] = [];
                }
                groupedAggregation[result.group].push(result.pvalue);
            });

            // Annotate any genes that have test results
            genesData.forEach(function (gene) {
                const gene_id = gene.gene_name;
                const tests = groupedAggregation[gene_id];
                if (tests) {
                    gene.aggregation_best_pvalue = Math.min.apply(null, tests);
                }
            });
            return genesData;
        }
    }


    LocusZoom.Adapters.add('AggregationTestSourceLZ', AggregationTestSource);
    LocusZoom.Adapters.add('AssocFromAggregationLZ', AssocFromAggregationLZ);
    LocusZoom.Adapters.add('GeneAggregationConnectorLZ', GeneAggregationConnectorLZ);
}


if (typeof LocusZoom !== 'undefined') {
    // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()
    // eslint-disable-next-line no-undef
    LocusZoom.use(install);
}


/* harmony default export */ __webpack_exports__["default"] = (install);


/***/ }),

/***/ "raremetal.js":
/*!****************************!*\
  !*** external "raremetal" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = raremetal;

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2RhdGEvYWRhcHRlcnMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2V4dC9sei1hZ2dyZWdhdGlvbi10ZXN0cy5qcyIsIndlYnBhY2s6Ly9bbmFtZV0vZXh0ZXJuYWwgXCJyYXJlbWV0YWxcIiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdlLHNFQUFPLEVBQUM7Ozs7Ozs7Ozs7OztBQ3pRdkIsMkIiLCJmaWxlIjoiZXh0L2x6LWFnZ3JlZ2F0aW9uLXRlc3RzLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vZXNtL2V4dC9sei1hZ2dyZWdhdGlvbi10ZXN0cy5qc1wiKTtcbiIsIi8qKlxuICogRGVmaW5lIHN0YW5kYXJkIGRhdGEgYWRhcHRlcnMgdXNlZCB0byByZXRyaWV2ZSBkYXRhICh1c3VhbGx5IGZyb20gUkVTVCBBUElzKVxuICogQG1vZHVsZVxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQnVpbGRTb3VyY2UoY2xhc3NfbmFtZSwgYnVpbGQsIHNvdXJjZSkge1xuICAgIC8vIEJ1aWxkIE9SIFNvdXJjZSwgbm90IGJvdGhcbiAgICBpZiAoKGJ1aWxkICYmIHNvdXJjZSkgfHwgIShidWlsZCB8fCBzb3VyY2UpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjbGFzc19uYW1lfSBtdXN0IHByb3ZpZGUgYSBwYXJhbWV0ZXIgc3BlY2lmeWluZyBlaXRoZXIgXCJidWlsZFwiIG9yIFwic291cmNlXCIuIEl0IHNob3VsZCBub3Qgc3BlY2lmeSBib3RoLmApO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgYnVpbGQgaXNuJ3QgcmVjb2duaXplZCwgb3VyIEFQSXMgY2FuJ3QgdHJhbnNwYXJlbnRseSBzZWxlY3QgYSBzb3VyY2UgdG8gbWF0Y2hcbiAgICBpZiAoYnVpbGQgJiYgIVsnR1JDaDM3JywgJ0dSQ2gzOCddLmluY2x1ZGVzKGJ1aWxkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y2xhc3NfbmFtZX0gbXVzdCBzcGVjaWZ5IGEgdmFsaWQgZ2Vub21lIGJ1aWxkIG51bWJlcmApO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIExvY3VzWm9vbSBkYXRhIHNvdXJjZXMgKGFueSkuIFNlZSBhbHNvOiBCYXNlQXBpQWRhcHRlclxuICogQHB1YmxpY1xuICovXG5jbGFzcyBCYXNlQWRhcHRlciB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgc291cmNlIHNob3VsZCBlbmFibGUgY2FjaGluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtCb29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZW5hYmxlQ2FjaGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jYWNoZWRLZXkgPSBudWxsO1xuXG4gICAgICAgIC8vIEFsbW9zdCBhbGwgTFogc291cmNlcyBhcmUgXCJyZWdpb24gYmFzZWRcIi4gQ2FjaGUgdGhlIHJlZ2lvbiByZXF1ZXN0ZWQgYW5kIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hldGhlclxuICAgICAgICAvLyAgIHRoZSBjYWNoZSB3b3VsZCBzYXRpc2Z5IHRoZSByZXF1ZXN0LlxuICAgICAgICB0aGlzLl9jYWNoZV9wb3Nfc3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYWNoZV9wb3NfZW5kID0gbnVsbDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIGRhdGEgc291cmNlIHR5cGUgaXMgZGVwZW5kZW50IG9uIHByZXZpb3VzIHJlcXVlc3RzLSBmb3IgZXhhbXBsZSwgdGhlIExEIHNvdXJjZSBjYW5ub3QgYW5ub3RhdGVcbiAgICAgICAgICogIGFzc29jaWF0aW9uIGRhdGEgaWYgbm8gZGF0YSB3YXMgZm91bmQgZm9yIHRoYXQgcmVnaW9uLlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fX2RlcGVuZGVudFNvdXJjZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFBhcnNlIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgICAgICB0aGlzLnBhcnNlSW5pdChjb25maWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIGNvbmZpZ3VyYXRpb24gdXNlZCB0byBjcmVhdGUgdGhlIGRhdGEgc291cmNlLiBNYW55IGN1c3RvbSBzb3VyY2VzIHdpbGwgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gc3VpdCB0aGVpclxuICAgICAqICBuZWVkcyAoZWcgc3BlY2lmaWMgY29uZmlnIG9wdGlvbnMsIG9yIGZvciBzb3VyY2VzIHRoYXQgZG8gbm90IHJldHJpZXZlIGRhdGEgZnJvbSBhIFVSTClcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBjb25maWcgQmFzaWMgY29uZmlndXJhdGlvbi0gZWl0aGVyIGEgdXJsLCBvciBhIGNvbmZpZyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy51cmxdIFRoZSBkYXRhc291cmNlIFVSTFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnBhcmFtc10gSW5pdGlhbCBjb25maWcgcGFyYW1zIGZvciB0aGUgZGF0YXNvdXJjZVxuICAgICAqL1xuICAgIHBhcnNlSW5pdChjb25maWcpIHtcbiAgICAgICAgLyoqIEBtZW1iZXIge09iamVjdH0gKi9cbiAgICAgICAgdGhpcy5wYXJhbXMgPSBjb25maWcucGFyYW1zIHx8IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgdW5pcXVlIGlkZW50aWZpZXIgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBjYWNoZWQgZGF0YSBpcyB2YWxpZCBmb3IgdGhpcyByZXF1ZXN0LiBGb3IgbW9zdCBzb3VyY2VzIHVzaW5nIEdFVFxuICAgICAqICByZXF1ZXN0cyB0byBhIFJFU1QgQVBJLCB0aGlzIGlzIHVzdWFsbHkgdGhlIHJlZ2lvbiByZXF1ZXN0ZWQuIFNvbWUgc291cmNlcyB3aWxsIGFwcGVuZCBhZGRpdGlvbmFsIHBhcmFtcyB0byBkZWZpbmUgdGhlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiAgVGhpcyBtZWFucyB0aGF0IHRvIGNoYW5nZSBjYWNoaW5nIGJlaGF2aW9yLCBib3RoIHRoZSBVUkwgYW5kIHRoZSBjYWNoZSBrZXkgbWF5IG5lZWQgdG8gYmUgdXBkYXRlZC4gSG93ZXZlcixcbiAgICAgKiAgICAgIGl0IGFsbG93cyBtb3N0IGRhdGFzb3VyY2VzIHRvIHNraXAgYW4gZXh0cmEgbmV0d29yayByZXF1ZXN0IHdoZW4gem9vbWluZyBpbi5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIEluZm9ybWF0aW9uIGF2YWlsYWJsZSBpbiBwbG90LnN0YXRlIChjaHIsIHN0YXJ0LCBlbmQpLiBTb21ldGltZXMgdXNlZCB0byBpbmplY3QgZ2xvYmFsbHlcbiAgICAgKiAgYXZhaWxhYmxlIGluZm9ybWF0aW9uIHRoYXQgaW5mbHVlbmNlcyB0aGUgcmVxdWVzdCBiZWluZyBtYWRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjaGFpbiBUaGUgZGF0YSBjaGFpbiBmcm9tIHByZXZpb3VzIHJlcXVlc3RzIG1hZGUgaW4gYSBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0gZmllbGRzXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDYWNoZUtleShzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICAvLyBNb3N0IHJlZ2lvbiBzb3VyY2VzLCBieSBkZWZhdWx0LCB3aWxsIGNhY2hlIHRoZSBsYXJnZXN0IHJlZ2lvbiB0aGF0IHNhdGlzZmllcyB0aGUgcmVxdWVzdDogem9vbWluZyBpblxuICAgICAgICAvLyAgc2hvdWxkIGJlIHNhdGlzZmllZCB2aWEgdGhlIGNhY2hlLCBidXQgcGFuIG9yIHJlZ2lvbiBjaGFuZ2Ugb3BlcmF0aW9ucyB3aWxsIGNhdXNlIGEgbmV0d29yayByZXF1ZXN0XG5cbiAgICAgICAgLy8gU29tZSBkYXRhIHNvdXJjZSByZWx5IG9uIHZhbHVlcyBzZXQgaW4gY2hhaW4uaGVhZGVyIGR1cmluZyB0aGUgZ2V0VVJMIGNhbGwuIChlZywgdGhlIExEIHNvdXJjZSB1c2VzXG4gICAgICAgIC8vICB0aGlzIHRvIGZpbmQgdGhlIExEIHJlZnZhcikgQ2FsbGluZyB0aGlzIG1ldGhvZCBpcyBhIGJhY2t3YXJkcy1jb21wYXRpYmxlIHdheSBvZiBlbnN1cmluZyB0aGF0IHZhbHVlIGlzIHNldCxcbiAgICAgICAgLy8gIGV2ZW4gb24gYSBjYWNoZSBoaXQgaW4gd2hpY2ggZ2V0VVJMIG90aGVyd2lzZSB3b3VsZG4ndCBiZSBjYWxsZWQuXG4gICAgICAgIC8vIFNvbWUgb2YgdGhlIGRhdGEgc291cmNlcyB0aGF0IHJlbHkgb24gdGhpcyBiZWhhdmlvciBhcmUgdXNlci1kZWZpbmVkLCBoZW5jZSBjb21wYXRpYmlsaXR5IGhhY2tcbiAgICAgICAgdGhpcy5nZXRVUkwoc3RhdGUsIGNoYWluLCBmaWVsZHMpO1xuXG4gICAgICAgIGNvbnN0IGNhY2hlX3Bvc19jaHIgPSBzdGF0ZS5jaHI7XG4gICAgICAgIGNvbnN0IHtfY2FjaGVfcG9zX3N0YXJ0LCBfY2FjaGVfcG9zX2VuZH0gPSB0aGlzO1xuICAgICAgICBpZiAoX2NhY2hlX3Bvc19zdGFydCAmJiBzdGF0ZS5zdGFydCA+PSBfY2FjaGVfcG9zX3N0YXJ0ICYmIF9jYWNoZV9wb3NfZW5kICYmIHN0YXRlLmVuZCA8PSBfY2FjaGVfcG9zX2VuZCApIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtjYWNoZV9wb3NfY2hyfV8ke19jYWNoZV9wb3Nfc3RhcnR9XyR7X2NhY2hlX3Bvc19lbmR9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtzdGF0ZS5jaHJ9XyR7c3RhdGUuc3RhcnR9XyR7c3RhdGUuZW5kfWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdHViOiBidWlsZCB0aGUgVVJMIGZvciBhbnkgcmVxdWVzdHMgbWFkZSBieSB0aGlzIHNvdXJjZS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVybDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgbmV0d29yayByZXF1ZXN0IHRvIGZldGNoIGRhdGEgZm9yIHRoaXMgc291cmNlLiBUaGlzIGlzIHVzdWFsbHkgdGhlIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gb3ZlcnJpZGVcbiAgICAgKiAgd2hlbiBkZWZpbmluZyBob3cgdG8gcmV0cmlldmUgZGF0YS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIFRoZSBzdGF0ZSBvZiB0aGUgcGFyZW50IHBsb3RcbiAgICAgKiBAcGFyYW0gY2hhaW5cbiAgICAgKiBAcGFyYW0gZmllbGRzXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgZmV0Y2hSZXF1ZXN0KHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKTtcbiAgICAgICAgcmV0dXJuIGZldGNoKHVybCkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkYXRhIGZvciBqdXN0IHRoaXMgc291cmNlLCB0eXBpY2FsbHkgdmlhIGEgbmV0d29yayByZXF1ZXN0IChidXQgdXNpbmcgY2FjaGUgd2hlcmUgcG9zc2libGUpXG4gICAgICpcbiAgICAgKiBGb3IgbW9zdCB1c2UgY2FzZXMsIGl0IGlzIGJldHRlciB0byBvdmVycmlkZSBgZmV0Y2hSZXF1ZXN0YCBpbnN0ZWFkLCB0byBhdm9pZCBieXBhc3NpbmcgdGhlIGNhY2hlIG1lY2hhbmlzbVxuICAgICAqIGJ5IGFjY2lkZW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIGdldFJlcXVlc3Qoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgbGV0IHJlcTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmdldENhY2hlS2V5KHN0YXRlLCBjaGFpbiwgZmllbGRzKTtcblxuICAgICAgICBpZiAodGhpcy5fZW5hYmxlQ2FjaGUgJiYgdHlwZW9mKGNhY2hlS2V5KSAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FjaGVLZXkgPT09IHRoaXMuX2NhY2hlZEtleSkge1xuICAgICAgICAgICAgcmVxID0gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2NhY2hlZFJlc3BvbnNlKTsgIC8vIFJlc29sdmUgdG8gdGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IHByb21pc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcSA9IHRoaXMuZmV0Y2hSZXF1ZXN0KHN0YXRlLCBjaGFpbiwgZmllbGRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVDYWNoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZEtleSA9IGNhY2hlS2V5O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlX3Bvc19zdGFydCA9IHN0YXRlLnN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlX3Bvc19lbmQgPSBzdGF0ZS5lbmQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUmVzcG9uc2UgPSByZXE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhlIHNlcnZlciByZXNwb25zZSBpcyBpbiBhIGNhbm9uaWNhbCBmb3JtLCBhbiBhcnJheSBvZiBvbmUgb2JqZWN0IHBlciByZWNvcmQuIFsge2ZpZWxkOiBvbmV2YWx9IF0uXG4gICAgICogSWYgdGhlIHNlcnZlciByZXNwb25zZSBjb250YWlucyBjb2x1bW5zLCByZWZvcm1hdHMgdGhlIHJlc3BvbnNlIGZyb20ge2NvbHVtbjE6IFtdLCBjb2x1bW4yOiBbXX0gdG8gdGhlIGFib3ZlLlxuICAgICAqXG4gICAgICogRG9lcyBub3QgYXBwbHkgbmFtZXNwYWNpbmcsIHRyYW5zZm9ybWF0aW9ucywgb3IgZmllbGQgZXh0cmFjdGlvbi5cbiAgICAgKlxuICAgICAqIE1heSBiZSBvdmVycmlkZGVuIGJ5IGRhdGEgc291cmNlcyB0aGF0IGluaGVyZW50bHkgcmV0dXJuIG1vcmUgY29tcGxleCBwYXlsb2Fkcywgb3IgdGhhdCBleGlzdCB0byBhbm5vdGF0ZSBvdGhlclxuICAgICAqICBzb3VyY2VzIChlZywgaWYgdGhlIHBheWxvYWQgcHJvdmlkZXMgZXh0cmEgZGF0YSByYXRoZXIgdGhhbiBhIHNlcmllcyBvZiByZWNvcmRzKS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3RbXXxPYmplY3R9IGRhdGEgVGhlIG9yaWdpbmFsIHBhcnNlZCBzZXJ2ZXIgcmVzcG9uc2VcbiAgICAgKi9cbiAgICBub3JtYWxpemVSZXNwb25zZShkYXRhKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAvLyBBbHJlYWR5IGluIHRoZSBkZXNpcmVkIGZvcm1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSwgYXNzdW1lIHRoZSBzZXJ2ZXIgcmVzcG9uc2UgaXMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyBjb2x1bW5zIG9mIGRhdGEuXG4gICAgICAgIC8vIEVhY2ggYXJyYXkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbGVuZ3RoICh2ZXJpZnkpLCBhbmQgYSBnaXZlbiBhcnJheSBpbmRleCBjb3JyZXNwb25kcyB0byBhIHNpbmdsZSByb3cuXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgICAgY29uc3QgTiA9IGRhdGFba2V5c1swXV0ubGVuZ3RoO1xuICAgICAgICBjb25zdCBzYW1lTGVuZ3RoID0ga2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZGF0YVtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubGVuZ3RoID09PSBOO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFzYW1lTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBleHBlY3RzIGEgcmVzcG9uc2UgaW4gd2hpY2ggYWxsIGFycmF5cyBvZiBkYXRhIGFyZSB0aGUgc2FtZSBsZW5ndGhgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdvIGRvd24gdGhlIHJvd3MsIGFuZCBjcmVhdGUgYW4gb2JqZWN0IGZvciBlYWNoIHJlY29yZFxuICAgICAgICBjb25zdCByZWNvcmRzID0gW107XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHJlY29yZFtmaWVsZHNbal1dID0gZGF0YVtmaWVsZHNbal1dW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjb3Jkcy5wdXNoKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9vayB0byBwb3N0LXByb2Nlc3MgdGhlIGRhdGEgcmV0dXJuZWQgYnkgdGhpcyBzb3VyY2Ugd2l0aCBuZXcsIGFkZGl0aW9uYWwgYmVoYXZpb3IuXG4gICAgICogICAoZWcgY2xlYW5pbmcgdXAgQVBJIHZhbHVlcyBvciBwZXJmb3JtaW5nIGNvbXBsZXggY2FsY3VsYXRpb25zIG9uIHRoZSByZXR1cm5lZCBkYXRhKVxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0W119IHJlY29yZHMgVGhlIHBhcnNlZCBkYXRhIGZyb20gdGhlIHNvdXJjZSAoZWcgc3RhbmRhcmRpemVkIGFwaSByZXNwb25zZSlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhaW4gVGhlIGRhdGEgY2hhaW4gb2JqZWN0LiBGb3IgZXhhbXBsZSwgY2hhaW4uaGVhZGVycyBtYXkgcHJvdmlkZSB1c2VmdWwgYW5ub3RhdGlvbiBtZXRhZGF0YVxuICAgICAqIEByZXR1cm5zIHtPYmplY3RbXXxQcm9taXNlfSBUaGUgbW9kaWZpZWQgc2V0IG9mIHJlY29yZHNcbiAgICAgKi9cbiAgICBhbm5vdGF0ZURhdGEocmVjb3JkcywgY2hhaW4pIHtcbiAgICAgICAgLy8gRGVmYXVsdCBiZWhhdmlvcjogbm8gdHJhbnNmb3JtYXRpb25zXG4gICAgICAgIHJldHVybiByZWNvcmRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFuIHVwIHRoZSBzZXJ2ZXIgcmVjb3JkcyBmb3IgdXNlIGJ5IGRhdGFsYXllcnM6IGV4dHJhY3Qgb25seSBjZXJ0YWluIGZpZWxkcywgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVzLlxuICAgICAqICAgQXBwbHkgcGVyLWZpZWxkIHRyYW5zZm9ybWF0aW9ucyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaG9vayBjYW4gYmUgb3ZlcnJpZGRlbiwgZWcgdG8gY3JlYXRlIGEgc291cmNlIHRoYXQgYWx3YXlzIHJldHVybnMgYWxsIHJlY29yZHMgYW5kIGlnbm9yZXMgdGhlIFwiZmllbGRzXCIgYXJyYXkuXG4gICAgICogIFRoaXMgaXMgcGFydGljdWxhcmx5IGNvbW1vbiBmb3Igc291cmNlcyBhdCB0aGUgZW5kIG9mIGEgY2hhaW4tIG1hbnkgXCJkZXBlbmRlbnRcIiBzb3VyY2VzIGRvIG5vdCBhbGxvd1xuICAgICAqICBjaGVycnktcGlja2luZyBpbmRpdmlkdWFsIGZpZWxkcywgaW4gd2hpY2ggY2FzZSBieSAqKmNvbnZlbnRpb24qKiB0aGUgZmllbGRzIGFycmF5IHNwZWNpZmllcyBcImxhc3Rfc291cmNlX25hbWU6YWxsXCJcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge09iamVjdFtdfSBkYXRhIE9uZSByZWNvcmQgb2JqZWN0IHBlciBlbGVtZW50XG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZmllbGRzIFRoZSBuYW1lcyBvZiBmaWVsZHMgdG8gZXh0cmFjdCAoYXMgbmFtZWQgaW4gdGhlIHNvdXJjZSBkYXRhKS4gRWcgXCJhZmllbGRcIlxuICAgICAqIEBwYXJhbSB7U3RyaW5nW119IG91dG5hbWVzIEhvdyB0byByZXByZXNlbnQgdGhlIHNvdXJjZSBmaWVsZHMgaW4gdGhlIG91dHB1dC4gRWcgXCJuYW1lc3BhY2U6YWZpZWxkfGF0cmFuc2Zvcm1cIlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb25bXX0gdHJhbnMgQW4gYXJyYXkgb2YgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIChpZiBhbnkpLiBPbmUgZnVuY3Rpb24gcGVyIGRhdGEgZWxlbWVudCwgb3IgbnVsbC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZXh0cmFjdEZpZWxkcyAoZGF0YSwgZmllbGRzLCBvdXRuYW1lcywgdHJhbnMpIHtcbiAgICAgICAgLy9pbnRlbmRlZCBmb3IgYW4gYXJyYXkgb2Ygb2JqZWN0c1xuICAgICAgICAvLyAgWyB7XCJpZFwiOjEsIFwidmFsXCI6NX0sIHtcImlkXCI6MiwgXCJ2YWxcIjoxMH1dXG4gICAgICAgIC8vIFNpbmNlIGEgbnVtYmVyIG9mIHNvdXJjZXMgZXhpc3QgdGhhdCBkbyBub3Qgb2JleSB0aGlzIGZvcm1hdCwgd2Ugd2lsbCBwcm92aWRlIGEgY29udmVuaWVudCBwYXNzLXRocm91Z2hcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFNvbWV0aW1lcyB0aGVyZSBhcmUgcmVnaW9ucyB0aGF0IGp1c3QgZG9uJ3QgaGF2ZSBkYXRhLSB0aGlzIHNob3VsZCBub3QgdHJpZ2dlciBhIG1pc3NpbmcgZmllbGQgZXJyb3IgbWVzc2FnZSFcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmllbGRGb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGZpZWxkcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgZmllbGRGb3VuZFtrXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWNvcmRzID0gZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dF9yZWNvcmQgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbCA9IGl0ZW1bZmllbGRzW2pdXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEZvdW5kW2pdID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zICYmIHRyYW5zW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHRyYW5zW2pdKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG91dHB1dF9yZWNvcmRbb3V0bmFtZXNbal1dID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dF9yZWNvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgICBmaWVsZEZvdW5kLmZvckVhY2goZnVuY3Rpb24odiwgaSkge1xuICAgICAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBmaWVsZCAke2ZpZWxkc1tpXX0gbm90IGZvdW5kIGluIHJlc3BvbnNlIGZvciAke291dG5hbWVzW2ldfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlY29yZHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tYmluZSByZWNvcmRzIGZyb20gdGhpcyBzb3VyY2Ugd2l0aCBvdGhlcnMgaW4gdGhlIGNoYWluIHRvIHlpZWxkIGZpbmFsIGNoYWluIGJvZHkuXG4gICAgICogICBIYW5kbGVzIG1lcmdpbmcgdGhpcyBkYXRhIHdpdGggb3RoZXIgc291cmNlcyAoaWYgYXBwbGljYWJsZSkuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtPYmplY3RbXX0gZGF0YSBUaGUgZGF0YSBUaGF0IHdvdWxkIGJlIHJldHVybmVkIGZyb20gdGhpcyBzb3VyY2UgYWxvbmVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhaW4gVGhlIGRhdGEgY2hhaW4gYnVpbHQgdXAgZHVyaW5nIHByZXZpb3VzIHJlcXVlc3RzXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZmllbGRzXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb3V0bmFtZXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSB0cmFuc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V8T2JqZWN0W119IFRoZSBuZXcgY2hhaW4gYm9keVxuICAgICAqL1xuICAgIGNvbWJpbmVDaGFpbkJvZHkoZGF0YSwgY2hhaW4sIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvb3JkaW5hdGVzIHRoZSB3b3JrIG9mIHBhcnNpbmcgYSByZXNwb25zZSBhbmQgcmV0dXJuaW5nIHJlY29yZHMuIFRoaXMgaXMgYnJva2VuIGludG8gNCBzdGVwcywgd2hpY2ggbWF5IGJlXG4gICAgICogIG92ZXJyaWRkZW4gc2VwYXJhdGVseSBmb3IgZmluZS1ncmFpbmVkIGNvbnRyb2wuIEVhY2ggc3RlcCBjYW4gcmV0dXJuIGVpdGhlciByYXcgZGF0YSBvciBhIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHJlc3AgVGhlIHJhdyBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhaW4gVGhlIGNvbWJpbmVkIHBhcnNlZCByZXNwb25zZSBkYXRhIGZyb20gdGhpcyBhbmQgYWxsIG90aGVyIHJlcXVlc3RzIG1hZGUgaW4gdGhlIGNoYWluXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZmllbGRzIEFycmF5IG9mIHJlcXVlc3RlZCBmaWVsZCBuYW1lcyAoYXMgdGhleSB3b3VsZCBhcHBlYXIgaW4gdGhlIHJlc3BvbnNlIHBheWxvYWQpXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gb3V0bmFtZXMgIEFycmF5IG9mIGZpZWxkIG5hbWVzIGFzIHRoZXkgd2lsbCBiZSByZXByZXNlbnRlZCBpbiB0aGUgZGF0YSByZXR1cm5lZCBieSB0aGlzIHNvdXJjZSxcbiAgICAgKiAgaW5jbHVkaW5nIHRoZSBuYW1lc3BhY2UuIFRoaXMgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHRoZSBzYW1lIGxlbmd0aCBhcyBgZmllbGRzYFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gdHJhbnMgVGhlIGNvbGxlY3Rpb24gb2YgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb25zIHRvIGJlIHJ1biBvbiBzZWxlY3RlZCBmaWVsZHMuXG4gICAgICogICAgIFRoaXMgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHRoZSBzYW1lIGxlbmd0aCBhcyBgZmllbGRzYFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBvYmplY3QgY29udGFpbmluZ1xuICAgICAqICAgcmVxdWVzdCBtZXRhZGF0YSAoYGhlYWRlcnM6IHt9YCksIHRoZSBjb25zb2xpZGF0ZWQgZGF0YSBmb3IgcGxvdHRpbmcgKGBib2R5OiBbXWApLCBhbmQgdGhlIGluZGl2aWR1YWwgcmVzcG9uc2VzIHRoYXQgd291bGQgYmVcbiAgICAgKiAgIHJldHVybmVkIGJ5IGVhY2ggc291cmNlIGluIHRoZSBjaGFpbiBpbiBpc29sYXRpb24gKGBkaXNjcmV0ZToge31gKVxuICAgICAqL1xuICAgIHBhcnNlUmVzcG9uc2UgKHJlc3AsIGNoYWluLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykge1xuICAgICAgICBjb25zdCBzb3VyY2VfaWQgPSB0aGlzLnNvdXJjZV9pZCB8fCB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIGlmICghY2hhaW4uZGlzY3JldGUpIHtcbiAgICAgICAgICAgIGNoYWluLmRpc2NyZXRlID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBqc29uID0gdHlwZW9mIHJlc3AgPT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKHJlc3ApIDogcmVzcDtcblxuICAgICAgICAvLyBQZXJmb3JtIHRoZSA0IHN0ZXBzIG9mIHBhcnNpbmcgdGhlIHBheWxvYWQgYW5kIHJldHVybiBhIGNvbWJpbmVkIGNoYWluIG9iamVjdFxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMubm9ybWFsaXplUmVzcG9uc2UoanNvbi5kYXRhIHx8IGpzb24pKVxuICAgICAgICAgICAgLnRoZW4oKHN0YW5kYXJkaXplZCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFBlcmZvcm0gY2FsY3VsYXRpb25zIG9uIHRoZSBkYXRhIGZyb20ganVzdCB0aGlzIHNvdXJjZVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hbm5vdGF0ZURhdGEoc3RhbmRhcmRpemVkLCBjaGFpbikpO1xuICAgICAgICAgICAgfSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5leHRyYWN0RmllbGRzKGRhdGEsIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSk7XG4gICAgICAgICAgICB9KS50aGVuKChvbmVfc291cmNlX2JvZHkpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBTdG9yZSBhIGNvcHkgb2YgdGhlIGRhdGEgdGhhdCB3b3VsZCBiZSByZXR1cm5lZCBieSBwYXJzaW5nIHRoaXMgc291cmNlIGluIGlzb2xhdGlvbiAoYW5kIHRha2luZyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGZpZWxkcyBhcnJheSBpbnRvIGFjY291bnQpLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHdlIHdhbnQgdG8gcmUtdXNlIHRoZSBzb3VyY2Ugb3V0cHV0IGluIG1hbnkgd2F5cy5cbiAgICAgICAgICAgICAgICBjaGFpbi5kaXNjcmV0ZVtzb3VyY2VfaWRdID0gb25lX3NvdXJjZV9ib2R5O1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5jb21iaW5lQ2hhaW5Cb2R5KG9uZV9zb3VyY2VfYm9keSwgY2hhaW4sIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSk7XG4gICAgICAgICAgICB9KS50aGVuKChuZXdfYm9keSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlYWRlcjogY2hhaW4uaGVhZGVyIHx8IHt9LCBkaXNjcmV0ZTogY2hhaW4uZGlzY3JldGUsIGJvZHk6IG5ld19ib2R5IH07XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgZGF0YSBmcm9tIHRoZSBzcGVjaWZpZWQgZGF0YSBzb3VyY2UsIGFuZCBhcHBseSB0cmFuc2Zvcm1hdGlvbnMgcmVxdWVzdGVkIGJ5IGFuIGV4dGVybmFsIGNvbnN1bWVyLlxuICAgICAqIFRoaXMgaXMgdGhlIHB1YmxpYy1mYWNpbmcgZGF0YXNvdXJjZSBtZXRob2QgdGhhdCB3aWxsIG1vc3QgYmUgY2FsbGVkIGJ5IHRoZSBwbG90LCBidXQgY3VzdG9tIGRhdGEgc291cmNlcyB3aWxsXG4gICAgICogIGFsbW9zdCBuZXZlciB3YW50IHRvIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGRpcmVjdGx5LSBtb3JlIHNwZWNpZmljIGhvb2tzIGFyZSBwcm92aWRlZCB0byBjb250cm9sIGluZGl2aWR1YWwgcGllY2VzXG4gICAgICogIG9mIHRoZSByZXF1ZXN0IGxpZmVjeWNsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIFRoZSBjdXJyZW50IFwic3RhdGVcIiBvZiB0aGUgcGxvdCwgc3VjaCBhcyBjaHJvbW9zb21lIGFuZCBzdGFydC9lbmQgcG9zaXRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gZmllbGRzIEFycmF5IG9mIGZpZWxkIG5hbWVzIHRoYXQgdGhlIHBsb3QgaGFzIHJlcXVlc3RlZCBmcm9tIHRoaXMgZGF0YSBzb3VyY2UuICh3aXRob3V0IHRoZSBcIm5hbWVzcGFjZVwiIHByZWZpeClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBvdXRuYW1lcyAgQXJyYXkgZGVzY3JpYmluZyBob3cgdGhlIG91dHB1dCBkYXRhIHNob3VsZCByZWZlciB0byB0aGlzIGZpZWxkLiBUaGlzIHJlcHJlc2VudHMgdGhlXG4gICAgICogICAgIG9yaWdpbmFsbHkgcmVxdWVzdGVkIGZpZWxkIG5hbWUsIGluY2x1ZGluZyB0aGUgbmFtZXNwYWNlLiBUaGlzIG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0aGUgc2FtZSBsZW5ndGggYXMgYGZpZWxkc2BcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9uW119IHRyYW5zIFRoZSBjb2xsZWN0aW9uIG9mIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9ucyB0byBiZSBydW4gb24gc2VsZWN0ZWQgZmllbGRzLlxuICAgICAqICAgICBUaGlzIG11c3QgYmUgYW4gYXJyYXkgd2l0aCB0aGUgc2FtZSBsZW5ndGggYXMgYGZpZWxkc2BcbiAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IEEgY2FsbGFibGUgb3BlcmF0aW9uIHRoYXQgY2FuIGJlIHVzZWQgYXMgcGFydCBvZiB0aGUgZGF0YSBjaGFpblxuICAgICAqL1xuICAgIGdldERhdGEoc3RhdGUsIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSB7XG4gICAgICAgIGlmICh0aGlzLnByZUdldERhdGEpIHsgLy8gVE9ETyB0cnkgdG8gcmVtb3ZlIHRoaXMgbWV0aG9kIGlmIGF0IGFsbCBwb3NzaWJsZVxuICAgICAgICAgICAgY29uc3QgcHJlID0gdGhpcy5wcmVHZXREYXRhKHN0YXRlLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucyk7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmUpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHByZS5zdGF0ZSB8fCBzdGF0ZTtcbiAgICAgICAgICAgICAgICBmaWVsZHMgPSBwcmUuZmllbGRzIHx8IGZpZWxkcztcbiAgICAgICAgICAgICAgICBvdXRuYW1lcyA9IHByZS5vdXRuYW1lcyB8fCBvdXRuYW1lcztcbiAgICAgICAgICAgICAgICB0cmFucyA9IHByZS50cmFucyB8fCB0cmFucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoY2hhaW4pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9fZGVwZW5kZW50U291cmNlICYmIGNoYWluICYmIGNoYWluLmJvZHkgJiYgIWNoYWluLmJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gQSBcImRlcGVuZGVudFwiIHNvdXJjZSBzaG91bGQgbm90IGF0dGVtcHQgdG8gZmlyZSBhIHJlcXVlc3QgaWYgdGhlcmUgaXMgbm8gZGF0YSBmb3IgaXQgdG8gYWN0IG9uLlxuICAgICAgICAgICAgICAgIC8vIFRoZXJlZm9yZSwgaXQgc2hvdWxkIHNpbXBseSByZXR1cm4gdGhlIHByZXZpb3VzIGRhdGEgY2hhaW4uXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjaGFpbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlcXVlc3Qoc3RhdGUsIGNoYWluLCBmaWVsZHMpLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJlc3BvbnNlKHJlc3AsIGNoYWluLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQmFzZSBzb3VyY2UgZm9yIExvY3VzWm9vbSBkYXRhIHNvdXJjZXMgdGhhdCByZWNlaXZlIHRoZWlyIGRhdGEgb3ZlciB0aGUgd2ViLiBBZGRzIGRlZmF1bHQgY29uZmlnIHBhcmFtZXRlcnNcbiAqICAoYW5kIHBvdGVudGlhbGx5IG90aGVyIGJlaGF2aW9yKSB0aGF0IGFyZSByZWxldmFudCB0byBVUkwtYmFzZWQgcmVxdWVzdHMuXG4gKi9cbmNsYXNzIEJhc2VBcGlBZGFwdGVyIGV4dGVuZHMgQmFzZUFkYXB0ZXIge1xuICAgIHBhcnNlSW5pdChjb25maWcpIHtcbiAgICAgICAgc3VwZXIucGFyc2VJbml0KGNvbmZpZyk7XG5cbiAgICAgICAgLyoqIEBtZW1iZXIge1N0cmluZ30gKi9cbiAgICAgICAgdGhpcy51cmwgPSBjb25maWcudXJsO1xuICAgICAgICBpZiAoIXRoaXMudXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBub3QgaW5pdGlhbGl6ZWQgd2l0aCByZXF1aXJlZCBVUkwnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBEYXRhIFNvdXJjZSBmb3IgQXNzb2NpYXRpb24gRGF0YSBmcm9tIHRoZSBMb2N1c1pvb20vIFBvcnRhbGRldiBBUEkgKG9yIGNvbXBhdGlibGUpLiBEZWZpbmVzIGhvdyB0byBtYWtlIGEgcmVxdWVzclxuICogQHB1YmxpY1xuICovXG5jbGFzcyBBc3NvY2lhdGlvbkxaIGV4dGVuZHMgQmFzZUFwaUFkYXB0ZXIge1xuICAgIHByZUdldERhdGEgKHN0YXRlLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykge1xuICAgICAgICAvLyBUT0RPOiBNb2RpZnkgaW50ZXJuYWxzIHRvIHNlZSBpZiB3ZSBjYW4gZ28gd2l0aG91dCB0aGlzIG1ldGhvZFxuICAgICAgICBjb25zdCBpZF9maWVsZCA9IHRoaXMucGFyYW1zLmlkX2ZpZWxkIHx8ICdpZCc7XG4gICAgICAgIFtpZF9maWVsZCwgJ3Bvc2l0aW9uJ10uZm9yRWFjaChmdW5jdGlvbih4KSB7XG4gICAgICAgICAgICBpZiAoIWZpZWxkcy5pbmNsdWRlcyh4KSkge1xuICAgICAgICAgICAgICAgIGZpZWxkcy51bnNoaWZ0KHgpO1xuICAgICAgICAgICAgICAgIG91dG5hbWVzLnVuc2hpZnQoeCk7XG4gICAgICAgICAgICAgICAgdHJhbnMudW5zaGlmdChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7ZmllbGRzOiBmaWVsZHMsIG91dG5hbWVzOm91dG5hbWVzLCB0cmFuczp0cmFuc307XG4gICAgfVxuXG4gICAgZ2V0VVJMIChzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICBjb25zdCBhbmFseXNpcyA9IGNoYWluLmhlYWRlci5hbmFseXNpcyB8fCB0aGlzLnBhcmFtcy5zb3VyY2UgfHwgdGhpcy5wYXJhbXMuYW5hbHlzaXM7ICAvLyBPbGQgdXNhZ2VzIGNhbGxlZCB0aGlzIHBhcmFtIFwiYW5hbHlzaXNcIlxuICAgICAgICBpZiAodHlwZW9mIGFuYWx5c2lzID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fzc29jaWF0aW9uIHNvdXJjZSBtdXN0IHNwZWNpZnkgYW4gYW5hbHlzaXMgSUQgdG8gcGxvdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnVybH1yZXN1bHRzLz9maWx0ZXI9YW5hbHlzaXMgaW4gJHthbmFseXNpc30gYW5kIGNocm9tb3NvbWUgaW4gICcke3N0YXRlLmNocn0nIGFuZCBwb3NpdGlvbiBnZSAke3N0YXRlLnN0YXJ0fSBhbmQgcG9zaXRpb24gbGUgJHtzdGF0ZS5lbmR9YDtcbiAgICB9XG5cbiAgICBub3JtYWxpemVSZXNwb25zZSAoZGF0YSkge1xuICAgICAgICAvLyBTb21lIGFzc29jaWF0aW9uIHNvdXJjZXMgZG8gbm90IHNvcnQgdGhlaXIgZGF0YSBpbiBhIHByZWRpY3RhYmxlIG9yZGVyLCB3aGljaCBtYWtlcyBpdCBoYXJkIHRvIHJlbGlhYmx5XG4gICAgICAgIC8vICBhbGlnbiB3aXRoIG90aGVyIHNvdXJjZXMgKHN1Y2ggYXMgTEQpLiBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgc29ydGluZyBpcyBhbiBvcHQtaW4gYXJndW1lbnQuXG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIG1vcmUgZmluZSBncmFpbmVkIHNvcnRpbmcgY29udHJvbCBpbiB0aGUgZnV0dXJlLiBUaGlzIHdhcyBhZGRlZCBhcyBhIHZlcnkgc3BlY2lmaWNcbiAgICAgICAgLy8gICB3b3JrYXJvdW5kIGZvciB0aGUgb3JpZ2luYWwgVDJEIHBvcnRhbC5cbiAgICAgICAgZGF0YSA9IHN1cGVyLm5vcm1hbGl6ZVJlc3BvbnNlKGRhdGEpO1xuICAgICAgICBpZiAodGhpcy5wYXJhbXMgJiYgdGhpcy5wYXJhbXMuc29ydCAmJiBkYXRhLmxlbmd0aCAmJiBkYXRhWzBdWydwb3NpdGlvbiddKSB7XG4gICAgICAgICAgICBkYXRhLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVsncG9zaXRpb24nXSAtIGJbJ3Bvc2l0aW9uJ107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG59XG5cbi8qKlxuICogRmV0Y2ggbGlua2FnZSBkaXNlcXVpbGlicml1bSBpbmZvcm1hdGlvbiBmcm9tIGEgVU1pY2ggTERTZXJ2ZXItY29tcGF0aWJsZSBBUElcbiAqXG4gKiBUaGlzIHNvdXJjZSBpcyBkZXNpZ25lZCB0byBjb25uZWN0IGl0cyByZXN1bHRzIHRvIGFzc29jaWF0aW9uIGRhdGEsIGFuZCB0aGVyZWZvcmUgZGVwZW5kcyBvbiBhc3NvY2lhdGlvbiBkYXRhIGhhdmluZ1xuICogIGJlZW4gbG9hZGVkIGJ5IGEgcHJldmlvdXMgcmVxdWVzdCBpbiB0aGUgZGF0YSBjaGFpbi5cbiAqXG4gKiBJbiBvbGRlciB2ZXJzaW9ucyBvZiBMb2N1c1pvb20sIHRoaXMgd2FzIGtub3duIGFzIFwiTERTZXJ2ZXJcIi4gQSBwcmlvciBzb3VyY2UgKHRhcmdldGVkIGF0IG9sZGVyIEFQSXMpIGhhcyBiZWVuIHJlbW92ZWQuXG4gKi9cbmNsYXNzIExEU2VydmVyIGV4dGVuZHMgQmFzZUFwaUFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLl9fZGVwZW5kZW50U291cmNlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBwcmVHZXREYXRhKHN0YXRlLCBmaWVsZHMpIHtcbiAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCAhPT0gMiB8fCAhZmllbGRzLmluY2x1ZGVzKCdpc3JlZnZhcicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMRCBkb2VzIG5vdCBrbm93IGhvdyB0byBnZXQgYWxsIGZpZWxkczogJHtmaWVsZHMuam9pbignLCAnKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZpbmRNZXJnZUZpZWxkcyhjaGFpbikge1xuICAgICAgICAvLyBGaW5kIHRoZSBmaWVsZHMgKGFzIHByb3ZpZGVkIGJ5IGEgcHJldmlvdXMgc3RlcCBpbiB0aGUgY2hhaW4sIGxpa2UgYW4gYXNzb2NpYXRpb24gc291cmNlKSB0aGF0IHdpbGwgYmUgbmVlZGVkIHRvXG4gICAgICAgIC8vICBjb21iaW5lIExEIGRhdGEgd2l0aCBleGlzdGluZyBpbmZvcm1hdGlvblxuXG4gICAgICAgIC8vIFNpbmNlIExEIGluZm9ybWF0aW9uIG1heSBiZSBzaGFyZWQgYWNyb3NzIG11bHRpcGxlIGFzc29jIHNvdXJjZXMgd2l0aCBkaWZmZXJlbnQgbmFtZXNwYWNlcyxcbiAgICAgICAgLy8gICB3ZSB1c2UgcmVnZXggdG8gZmluZCBjb2x1bW5zIHRvIGpvaW4gb24sIHJhdGhlciB0aGFuIHJlcXVpcmluZyBleGFjdCBtYXRjaGVzXG4gICAgICAgIGNvbnN0IGV4YWN0TWF0Y2ggPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ZXMgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gcmVnZXhlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbSA9IGFyci5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4Lm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBsZXQgZGF0YUZpZWxkcyA9IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLnBhcmFtcy5pZF9maWVsZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLnBhcmFtcy5wb3NpdGlvbl9maWVsZCxcbiAgICAgICAgICAgIHB2YWx1ZTogdGhpcy5wYXJhbXMucHZhbHVlX2ZpZWxkLFxuICAgICAgICAgICAgX25hbWVzXzpudWxsLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2hhaW4gJiYgY2hhaW4uYm9keSAmJiBjaGFpbi5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoY2hhaW4uYm9keVswXSk7XG4gICAgICAgICAgICBjb25zdCBuYW1lTWF0Y2ggPSBleGFjdE1hdGNoKG5hbWVzKTtcbiAgICAgICAgICAgIC8vIEludGVybmFsbHksIGZpZWxkcyBhcmUgZ2VuZXJhbGx5IHByZWZpeGVkIHdpdGggdGhlIG5hbWUgb2YgdGhlIHNvdXJjZSB0aGV5IGNvbWUgZnJvbS5cbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHByb3ZpZGVzIGFuIGlkX2ZpZWxkIChsaWtlIGB2YXJpYW50YCksIGl0IHNob3VsZCB3b3JrIGFjcm9zcyBkYXRhIHNvdXJjZXMoIGBhc3NvYzE6dmFyaWFudGAsXG4gICAgICAgICAgICAvLyAgYXNzb2MyOnZhcmlhbnQpLCBidXQgbm90IG1hdGNoIGZyYWdtZW50cyBvZiBvdGhlciBmaWVsZCBuYW1lcyAoYXNzb2MxOnZhcmlhbnRfdGhpbmcpXG4gICAgICAgICAgICAvLyBOb3RlOiB0aGVzZSBsb29rdXBzIGhhcmQtY29kZSBhIGNvdXBsZSBvZiBjb21tb24gZmllbGRzIHRoYXQgd2lsbCB3b3JrIGJhc2VkIG9uIGtub3duIEFQSXMgaW4gdGhlIHdpbGRcbiAgICAgICAgICAgIGNvbnN0IGlkX21hdGNoID0gZGF0YUZpZWxkcy5pZCAmJiBuYW1lTWF0Y2gobmV3IFJlZ0V4cChgJHtkYXRhRmllbGRzLmlkfVxcXFxiYCkpO1xuICAgICAgICAgICAgZGF0YUZpZWxkcy5pZCA9IGlkX21hdGNoIHx8IG5hbWVNYXRjaCgvXFxidmFyaWFudFxcYi8pIHx8IG5hbWVNYXRjaCgvXFxiaWRcXGIvKTtcbiAgICAgICAgICAgIGRhdGFGaWVsZHMucG9zaXRpb24gPSBkYXRhRmllbGRzLnBvc2l0aW9uIHx8IG5hbWVNYXRjaCgvXFxicG9zaXRpb25cXGIvaSwgL1xcYnBvc1xcYi9pKTtcbiAgICAgICAgICAgIGRhdGFGaWVsZHMucHZhbHVlID0gZGF0YUZpZWxkcy5wdmFsdWUgfHwgbmFtZU1hdGNoKC9cXGJwdmFsdWVcXGIvaSwgL1xcYmxvZ19wdmFsdWVcXGIvaSk7XG4gICAgICAgICAgICBkYXRhRmllbGRzLl9uYW1lc18gPSBuYW1lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YUZpZWxkcztcbiAgICB9XG5cbiAgICBmaW5kUmVxdWVzdGVkRmllbGRzIChmaWVsZHMsIG91dG5hbWVzKSB7XG4gICAgICAgIC8vIEFzc3VtcHRpb246IGFsbCB1c2FnZXMgb2YgdGhpcyBzb3VyY2Ugd2lsbCBvbmx5IGV2ZXIgYXNrIGZvciBcImlzcmVmdmFyXCIgb3IgXCJzdGF0ZVwiLiBUaGlzIG1hcHMgdG8gb3V0cHV0IG5hbWVzLlxuICAgICAgICBsZXQgb2JqID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRzW2ldID09PSAnaXNyZWZ2YXInKSB7XG4gICAgICAgICAgICAgICAgb2JqLmlzcmVmdmFyaW4gPSBmaWVsZHNbaV07XG4gICAgICAgICAgICAgICAgb2JqLmlzcmVmdmFyb3V0ID0gb3V0bmFtZXMgJiYgb3V0bmFtZXNbaV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9iai5sZGluID0gZmllbGRzW2ldO1xuICAgICAgICAgICAgICAgIG9iai5sZG91dCA9IG91dG5hbWVzICYmIG91dG5hbWVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplUmVzcG9uc2UgKGRhdGEpIHtcbiAgICAgICAgLy8gVGhlIExEIEFQSSBwYXlsb2FkIGRvZXMgbm90IG9iZXkgc3RhbmRhcmQgZm9ybWF0IGNvbnZlbnRpb25zOyBkbyBub3QgdHJ5IHRvIHRyYW5zZm9ybSBpdC5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBMRCByZWZlcmVuY2UgdmFyaWFudCwgd2hpY2ggYnkgZGVmYXVsdCB3aWxsIGJlIHRoZSBtb3N0IHNpZ25pZmljYW50IGhpdCBpbiB0aGUgYXNzb2MgcmVzdWx0c1xuICAgICAqICAgVGhpcyB3aWxsIGJlIHVzZWQgaW4gbWFraW5nIHRoZSBvcmlnaW5hbCBxdWVyeSB0byB0aGUgTEQgc2VydmVyIGZvciBwYWlyd2lzZSBMRCBpbmZvcm1hdGlvblxuICAgICAqIEByZXR1cm5zIFN0cmluZ1tdIFR3byBzdHJpbmdzOiAxKSB0aGUgbWFya2VyIGlkIChleHBlY3RlZCB0byBiZSBpbiBgY2hyOnBvc19yZWYvYWx0YCBmb3JtYXQpIG9mIHRoZSByZWZlcmVuY2VcbiAgICAgKiAgdmFyaWFudCwgYW5kIDIpIHRoZSBtYXJrZXIgSUQgYXMgaXQgYXBwZWFycyBpbiB0aGUgb3JpZ2luYWwgZGF0YXNldCB0aGF0IHdlIGFyZSBqb2luaW5nIHRvLCBzbyB0aGF0IHRoZSBleGFjdFxuICAgICAqICByZWZ2YXIgY2FuIGJlIG1hcmtlZCB3aGVuIHBsb3R0aW5nIHRoZSBkYXRhLi5cbiAgICAgKi9cbiAgICBnZXRSZWZ2YXIoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgbGV0IGZpbmRFeHRyZW1lVmFsdWUgPSBmdW5jdGlvbihyZWNvcmRzLCBwdmFsX2ZpZWxkKSB7XG4gICAgICAgICAgICAvLyBGaW5kcyB0aGUgbW9zdCBzaWduaWZpY2FudCBoaXQgKHNtYWxsZXN0IHB2YWx1ZSwgb3IgbGFyZ2VzdCAtbG9nMTBwKS4gV2lsbCB0cnkgdG8gYXV0by1kZXRlY3QgdGhlIGFwcHJvcHJpYXRlIGNvbXBhcmlzb24uXG4gICAgICAgICAgICBwdmFsX2ZpZWxkID0gcHZhbF9maWVsZCB8fCAnbG9nX3B2YWx1ZSc7ICAvLyBUaGUgb2ZmaWNpYWwgTFogQVBJIHJldHVybnMgbG9nX3B2YWx1ZVxuICAgICAgICAgICAgY29uc3QgaXNfbG9nID0gL2xvZy8udGVzdChwdmFsX2ZpZWxkKTtcbiAgICAgICAgICAgIGxldCBjbXA7XG4gICAgICAgICAgICBpZiAoaXNfbG9nKSB7XG4gICAgICAgICAgICAgICAgY21wID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA+IGI7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY21wID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYSA8IGI7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBleHRyZW1lVmFsID0gcmVjb3Jkc1swXVtwdmFsX2ZpZWxkXSwgZXh0cmVtZUlkeCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY21wKHJlY29yZHNbaV1bcHZhbF9maWVsZF0sIGV4dHJlbWVWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJlbWVWYWwgPSByZWNvcmRzW2ldW3B2YWxfZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICBleHRyZW1lSWR4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXh0cmVtZUlkeDtcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgcmVxRmllbGRzID0gdGhpcy5maW5kUmVxdWVzdGVkRmllbGRzKGZpZWxkcyk7XG4gICAgICAgIGxldCByZWZWYXIgPSByZXFGaWVsZHMubGRpbjtcbiAgICAgICAgaWYgKHJlZlZhciA9PT0gJ3N0YXRlJykge1xuICAgICAgICAgICAgcmVmVmFyID0gc3RhdGUubGRyZWZ2YXIgfHwgY2hhaW4uaGVhZGVyLmxkcmVmdmFyIHx8ICdiZXN0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmVmFyID09PSAnYmVzdCcpIHtcbiAgICAgICAgICAgIGlmICghY2hhaW4uYm9keSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYXNzb2NpYXRpb24gZGF0YSBmb3VuZCB0byBmaW5kIGJlc3QgcHZhbHVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQga2V5cyA9IHRoaXMuZmluZE1lcmdlRmllbGRzKGNoYWluKTtcbiAgICAgICAgICAgIGlmICgha2V5cy5wdmFsdWUgfHwgIWtleXMuaWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29sdW1ucyA9ICcnO1xuICAgICAgICAgICAgICAgIGlmICgha2V5cy5pZCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zICs9IGAke2NvbHVtbnMubGVuZ3RoID8gJywgJyA6ICcnfWlkYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFrZXlzLnB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zICs9IGAke2NvbHVtbnMubGVuZ3RoID8gJywgJyA6ICcnfXB2YWx1ZWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgbmVjZXNzYXJ5IGNvbHVtbihzKSBmb3IgbWVyZ2U6ICR7Y29sdW1uc30gKGF2YWlsYWJsZTogJHtrZXlzLl9uYW1lc199KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmVmFyID0gY2hhaW4uYm9keVtmaW5kRXh0cmVtZVZhbHVlKGNoYWluLmJvZHksIGtleXMucHZhbHVlKV1ba2V5cy5pZF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBkYXRhc2V0cywgbm90YWJseSB0aGUgUG9ydGFsLCB1c2UgYSBkaWZmZXJlbnQgbWFya2VyIGZvcm1hdC5cbiAgICAgICAgLy8gIENvZXJjZSBpdCBpbnRvIG9uZSB0aGF0IHdpbGwgd29yayB3aXRoIHRoZSBMRFNlcnZlciBBUEkuIChDSFJPTTpQT1NfUkVGL0FMVClcbiAgICAgICAgY29uc3QgUkVHRVhfTUFSS0VSID0gL14oPzpjaHIpPyhbYS16QS1aMC05XSs/KVtfOi1dKFxcZCspW186fC1dPyhcXHcrKT9bL186fC1dPyhbXl9dKyk/Xz8oLiopPy87XG4gICAgICAgIGNvbnN0IG1hdGNoID0gcmVmVmFyICYmIHJlZlZhci5tYXRjaChSRUdFWF9NQVJLRVIpO1xuXG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IHJlcXVlc3QgTEQgZm9yIGEgbWlzc2luZyBvciBpbmNvbXBsZXRlIG1hcmtlciBmb3JtYXQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb3JpZ2luYWwsIGNocm9tLCBwb3MsIHJlZiwgYWx0XSA9IG1hdGNoO1xuICAgICAgICAvLyBDdXJyZW50bHksIHRoZSBMRCBzZXJ2ZXIgb25seSBhY2NlcHRzIGZ1bGwgdmFyaWFudCBzcGVjczsgaXQgd29uJ3QgcmV0dXJuIExEIHcvbyByZWYrYWx0LiBBbGxvd2luZ1xuICAgICAgICAvLyAgYSBwYXJ0aWFsIG1hdGNoIGF0IG1vc3QgbGVhdmVzIHJvb20gZm9yIHBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZXMuXG4gICAgICAgIGxldCByZWZWYXJfZm9ybWF0dGVkID0gYCR7Y2hyb219OiR7cG9zfWA7XG4gICAgICAgIGlmIChyZWYgJiYgYWx0KSB7XG4gICAgICAgICAgICByZWZWYXJfZm9ybWF0dGVkICs9IGBfJHtyZWZ9LyR7YWx0fWA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3JlZlZhcl9mb3JtYXR0ZWQsIG9yaWdpbmFsXTtcbiAgICB9XG5cbiAgICBnZXRVUkwoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgLy8gQWNjZXB0IHRoZSBmb2xsb3dpbmcgcGFyYW1zIGluIHRoaXMucGFyYW1zOlxuICAgICAgICAvLyAtIG1ldGhvZCAociwgcnNxdWFyZSwgY292KVxuICAgICAgICAvLyAtIHNvdXJjZSAoYWthIHBhbmVsKVxuICAgICAgICAvLyAtIHBvcHVsYXRpb24gKEFMTCwgQUZSLCBFVVIsIGV0YylcbiAgICAgICAgLy8gLSBidWlsZFxuICAgICAgICAvLyBUaGUgTEQgc291cmNlL3BvcCBjYW4gYmUgb3ZlcnJpZGRlbiBmcm9tIHBsb3Quc3RhdGUgZm9yIGR5bmFtaWMgbGF5b3V0c1xuICAgICAgICBjb25zdCBidWlsZCA9IHN0YXRlLmdlbm9tZV9idWlsZCB8fCB0aGlzLnBhcmFtcy5idWlsZCB8fCAnR1JDaDM3JzsgLy8gVGhpcyBpc24ndCBleHBlY3RlZCB0byBjaGFuZ2UgYWZ0ZXIgdGhlIGRhdGEgaXMgcGxvdHRlZC5cbiAgICAgICAgbGV0IHNvdXJjZSA9IHN0YXRlLmxkX3NvdXJjZSB8fCB0aGlzLnBhcmFtcy5zb3VyY2UgfHwgJzEwMDBHJztcbiAgICAgICAgY29uc3QgcG9wdWxhdGlvbiA9IHN0YXRlLmxkX3BvcCB8fCB0aGlzLnBhcmFtcy5wb3B1bGF0aW9uIHx8ICdBTEwnOyAgLy8gTERTZXJ2ZXIgcGFuZWxzIHdpbGwgYWx3YXlzIGhhdmUgYW4gQUxMXG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMucGFyYW1zLm1ldGhvZCB8fCAncnNxdWFyZSc7XG5cbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gJzEwMDBHJyAmJiBidWlsZCA9PT0gJ0dSQ2gzOCcpIHtcbiAgICAgICAgICAgIC8vIEZvciBidWlsZCAzOCAob25seSksIHRoZXJlIGlzIGEgbmV3ZXIvaW1wcm92ZWQgMTAwMEcgTEQgcGFuZWwgYXZhaWxhYmxlIHRoYXQgdXNlcyBXR1MgZGF0YS4gQXV0byB1cGdyYWRlIGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICBzb3VyY2UgPSAnMTAwMEctRlJaMDknO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsaWRhdGVCdWlsZFNvdXJjZSh0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIGJ1aWxkLCBudWxsKTsgIC8vIExEIGRvZXNuJ3QgbmVlZCB0byB2YWxpZGF0ZSBgc291cmNlYCBvcHRpb25cblxuICAgICAgICBjb25zdCBbcmVmVmFyX2Zvcm1hdHRlZCwgcmVmVmFyX3Jhd10gPSB0aGlzLmdldFJlZnZhcihzdGF0ZSwgY2hhaW4sIGZpZWxkcyk7XG5cbiAgICAgICAgLy8gUHJlc2VydmUgdGhlIHVzZXItcHJvdmlkZWQgdmFyaWFudCBzcGVjIGZvciB1c2Ugd2hlbiBtYXRjaGluZyB0byBhc3NvYyBkYXRhXG4gICAgICAgIGNoYWluLmhlYWRlci5sZHJlZnZhciA9IHJlZlZhcl9yYXc7XG5cbiAgICAgICAgcmV0dXJuICBbXG4gICAgICAgICAgICB0aGlzLnVybCwgJ2dlbm9tZV9idWlsZHMvJywgYnVpbGQsICcvcmVmZXJlbmNlcy8nLCBzb3VyY2UsICcvcG9wdWxhdGlvbnMvJywgcG9wdWxhdGlvbiwgJy92YXJpYW50cycsXG4gICAgICAgICAgICAnP2NvcnJlbGF0aW9uPScsIG1ldGhvZCxcbiAgICAgICAgICAgICcmdmFyaWFudD0nLCBlbmNvZGVVUklDb21wb25lbnQocmVmVmFyX2Zvcm1hdHRlZCksXG4gICAgICAgICAgICAnJmNocm9tPScsIGVuY29kZVVSSUNvbXBvbmVudChzdGF0ZS5jaHIpLFxuICAgICAgICAgICAgJyZzdGFydD0nLCBlbmNvZGVVUklDb21wb25lbnQoc3RhdGUuc3RhcnQpLFxuICAgICAgICAgICAgJyZzdG9wPScsIGVuY29kZVVSSUNvbXBvbmVudChzdGF0ZS5lbmQpLFxuICAgICAgICBdLmpvaW4oJycpO1xuICAgIH1cblxuICAgIGdldENhY2hlS2V5KHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBzdXBlci5nZXRDYWNoZUtleShzdGF0ZSwgY2hhaW4sIGZpZWxkcyk7XG4gICAgICAgIGxldCBzb3VyY2UgPSBzdGF0ZS5sZF9zb3VyY2UgfHwgdGhpcy5wYXJhbXMuc291cmNlIHx8ICcxMDAwRyc7XG4gICAgICAgIGNvbnN0IHBvcHVsYXRpb24gPSBzdGF0ZS5sZF9wb3AgfHwgdGhpcy5wYXJhbXMucG9wdWxhdGlvbiB8fCAnQUxMJzsgIC8vIExEU2VydmVyIHBhbmVscyB3aWxsIGFsd2F5cyBoYXZlIGFuIEFMTFxuICAgICAgICBjb25zdCBbcmVmVmFyLCBfXSA9IHRoaXMuZ2V0UmVmdmFyKHN0YXRlLCBjaGFpbiwgZmllbGRzKTtcbiAgICAgICAgcmV0dXJuIGAke2Jhc2V9XyR7cmVmVmFyfV8ke3NvdXJjZX1fJHtwb3B1bGF0aW9ufWA7XG4gICAgfVxuXG4gICAgY29tYmluZUNoYWluQm9keShkYXRhLCBjaGFpbiwgZmllbGRzLCBvdXRuYW1lcywgdHJhbnMpIHtcbiAgICAgICAgbGV0IGtleXMgPSB0aGlzLmZpbmRNZXJnZUZpZWxkcyhjaGFpbik7XG4gICAgICAgIGxldCByZXFGaWVsZHMgPSB0aGlzLmZpbmRSZXF1ZXN0ZWRGaWVsZHMoZmllbGRzLCBvdXRuYW1lcyk7XG4gICAgICAgIGlmICgha2V5cy5wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBwb3NpdGlvbiBmaWVsZCBmb3IgbWVyZ2U6ICR7a2V5cy5fbmFtZXNffWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlZnRKb2luID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBsZmllbGQsIHJmaWVsZCkge1xuICAgICAgICAgICAgbGV0IGkgPSAwLCBqID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVmdC5sZW5ndGggJiYgaiA8IHJpZ2h0LnBvc2l0aW9uMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVmdFtpXVtrZXlzLnBvc2l0aW9uXSA9PT0gcmlnaHQucG9zaXRpb24yW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRbaV1bbGZpZWxkXSA9IHJpZ2h0W3JmaWVsZF1bal07XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdFtpXVtrZXlzLnBvc2l0aW9uXSA8IHJpZ2h0LnBvc2l0aW9uMltqXSkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdGFnUmVmVmFyaWFudCA9IGZ1bmN0aW9uIChkYXRhLCByZWZ2YXIsIGlkZmllbGQsIG91dHJlZm5hbWUsIG91dGxkbmFtZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV1baWRmaWVsZF0gJiYgZGF0YVtpXVtpZGZpZWxkXSA9PT0gcmVmdmFyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbaV1bb3V0cmVmbmFtZV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2ldW291dGxkbmFtZV0gPSAxOyAvLyBGb3IgbGFiZWwvZmlsdGVyIHB1cnBvc2VzLCBpbXBsaWNpdGx5IG1hcmsgdGhlIHJlZiB2YXIgYXMgTEQ9MSB0byBpdHNlbGZcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2ldW291dHJlZm5hbWVdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTEQgc2VydmVycyB2YXJ5IHNsaWdodGx5LiBTb21lIHJlcG9ydCBjb3JyIGFzIFwicnNxdWFyZVwiLCBvdGhlcnMgYXMgXCJjb3JyZWxhdGlvblwiXG4gICAgICAgIGxldCBjb3JyRmllbGQgPSBkYXRhLnJzcXVhcmUgPyAncnNxdWFyZScgOiAnY29ycmVsYXRpb24nO1xuICAgICAgICBsZWZ0Sm9pbihjaGFpbi5ib2R5LCBkYXRhLCByZXFGaWVsZHMubGRvdXQsIGNvcnJGaWVsZCk7XG4gICAgICAgIGlmIChyZXFGaWVsZHMuaXNyZWZ2YXJpbiAmJiBjaGFpbi5oZWFkZXIubGRyZWZ2YXIpIHtcbiAgICAgICAgICAgIHRhZ1JlZlZhcmlhbnQoY2hhaW4uYm9keSwgY2hhaW4uaGVhZGVyLmxkcmVmdmFyLCBrZXlzLmlkLCByZXFGaWVsZHMuaXNyZWZ2YXJvdXQsIHJlcUZpZWxkcy5sZG91dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYWluLmJvZHk7XG4gICAgfVxuXG4gICAgZmV0Y2hSZXF1ZXN0KHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIC8vIFRoZSBBUEkgaXMgcGFnaW5hdGVkLCBidXQgd2UgbmVlZCBhbGwgb2YgdGhlIGRhdGEgdG8gcmVuZGVyIGEgcGxvdC4gRGVwYWdpbmF0ZSBhbmQgY29tYmluZSB3aGVyZSBhcHByb3ByaWF0ZS5cbiAgICAgICAgbGV0IHVybCA9IHRoaXMuZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKTtcbiAgICAgICAgbGV0IGNvbWJpbmVkID0geyBkYXRhOiB7fSB9O1xuICAgICAgICBsZXQgY2hhaW5SZXF1ZXN0cyA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmwpLnRoZW4oKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocGF5bG9hZC5kYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tYmluZWQuZGF0YVtrZXldID0gKGNvbWJpbmVkLmRhdGFba2V5XSB8fCBbXSkuY29uY2F0KHBheWxvYWQuZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpblJlcXVlc3RzKHBheWxvYWQubmV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2hhaW5SZXF1ZXN0cyh1cmwpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEYXRhIHNvdXJjZSBmb3IgR1dBUyBjYXRhbG9ncyBvZiBrbm93biB2YXJpYW50c1xuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGluaXQgQ29uZmlndXJhdGlvbiAoVVJMIG9yIG9iamVjdClcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaW5pdC5wYXJhbXNdIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtpbml0LnBhcmFtcy5zb3VyY2U9Ml0gVGhlIElEIG9mIHRoZSBjaG9zZW4gY2F0YWxvZy4gRGVmYXVsdHMgdG8gRUJJIEdXQVMgY2F0YWxvZywgR1JDaDM3XG4gKiBAcGFyYW0geygnc3RyaWN0J3wnbG9vc2UnKX0gW2luaXQucGFyYW1zLm1hdGNoX3R5cGU9J3N0cmljdCddIFdoZXRoZXIgdG8gbWF0Y2ggb24gZXhhY3QgdmFyaWFudCwgb3IganVzdCBwb3NpdGlvbi5cbiAqL1xuY2xhc3MgR3dhc0NhdGFsb2dMWiBleHRlbmRzIEJhc2VBcGlBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnKTtcbiAgICAgICAgdGhpcy5fX2RlcGVuZGVudFNvdXJjZSA9IHRydWU7XG4gICAgfVxuXG4gICAgZ2V0VVJMKHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgYWxpZ25lZCB3aXRoIGFub3RoZXIgc291cmNlLSB3ZSB3aWxsIGFzc3VtZSB0aGV5IGFyZSBhbHdheXMgb3JkZXJlZCBieSBwb3NpdGlvbiwgYXNjXG4gICAgICAgIC8vICAocmVnYXJkbGVzcyBvZiB0aGUgYWN0dWFsIG1hdGNoIGZpZWxkKVxuICAgICAgICBjb25zdCBidWlsZF9vcHRpb24gPSBzdGF0ZS5nZW5vbWVfYnVpbGQgfHwgdGhpcy5wYXJhbXMuYnVpbGQ7XG4gICAgICAgIHZhbGlkYXRlQnVpbGRTb3VyY2UodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCBidWlsZF9vcHRpb24sIG51bGwpOyAvLyBTb3VyY2UgY2FuIG92ZXJyaWRlIGJ1aWxkLSBub3QgbXV0dWFsbHkgZXhjbHVzaXZlXG5cbiAgICAgICAgLy8gTW9zdCBvZiBvdXIgYW5ub3RhdGlvbnMgd2lsbCByZXNwZWN0IGdlbm9tZSBidWlsZCBiZWZvcmUgYW55IG90aGVyIG9wdGlvbi5cbiAgICAgICAgLy8gICBCdXQgdGhlcmUgY2FuIGJlIG1vcmUgdGhhbiBvbmUgR1dBUyBjYXRhbG9nIHZlcnNpb24gYXZhaWxhYmxlIGluIHRoZSBzYW1lIEFQSSwgZm9yIHRoZSBzYW1lIGJ1aWxkLSBhblxuICAgICAgICAvLyAgIGV4cGxpY2l0IGNvbmZpZyBvcHRpb24gd2lsbCBhbHdheXMgdGFrZVxuICAgICAgICAvLyAgIHByZWNlZGVuY2UuXG4gICAgICAgIC8vIFNlZTogaHR0cDovL3BvcnRhbGRldi5zcGgudW1pY2guZWR1L2FwaS92MS9hbm5vdGF0aW9uL2d3YXNjYXRhbG9nLz9mb3JtYXQ9b2JqZWN0c1xuICAgICAgICBjb25zdCBkZWZhdWx0X3NvdXJjZSA9IChidWlsZF9vcHRpb24gPT09ICdHUkNoMzgnKSA/IDUgOiA2OyAgLy8gRUJJIEdXQVMgY2F0YWxvZ1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnBhcmFtcy5zb3VyY2UgfHwgZGVmYXVsdF9zb3VyY2U7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnVybCAgfT9mb3JtYXQ9b2JqZWN0cyZzb3J0PXBvcyZmaWx0ZXI9aWQgZXEgJHtzb3VyY2V9IGFuZCBjaHJvbSBlcSAnJHtzdGF0ZS5jaHJ9JyBhbmQgcG9zIGdlICR7c3RhdGUuc3RhcnR9IGFuZCBwb3MgbGUgJHtzdGF0ZS5lbmR9YDtcbiAgICB9XG5cbiAgICBmaW5kTWVyZ2VGaWVsZHMocmVjb3Jkcykge1xuICAgICAgICAvLyBEYXRhIGZyb20gcHJldmlvdXMgc291cmNlcyBpcyBhbHJlYWR5IG5hbWVzcGFjZWQuIEZpbmQgdGhlIGFsaWdubWVudCBmaWVsZCBieSBtYXRjaGluZy5cbiAgICAgICAgY29uc3Qga25vd25GaWVsZHMgPSBPYmplY3Qua2V5cyhyZWNvcmRzKTtcbiAgICAgICAgLy8gTm90ZTogQWxsIEFQSSBlbmRvaW50cyBpbnZvbHZlZCBvbmx5IGdpdmUgcmVzdWx0cyBmb3IgMSBjaHJvbW9zb21lIGF0IGEgdGltZTsgbWF0Y2ggaXMgaW1wbGllZFxuICAgICAgICBjb25zdCBwb3NNYXRjaCA9IGtub3duRmllbGRzLmZpbmQoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLm1hdGNoKC9cXGIocG9zaXRpb258cG9zKVxcYi9pKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFwb3NNYXRjaCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBkYXRhIHRvIGFsaWduIHdpdGggR1dBUyBjYXRhbG9nIHJlc3VsdHMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAncG9zJzogcG9zTWF0Y2ggfTtcbiAgICB9XG5cbiAgICBleHRyYWN0RmllbGRzIChkYXRhLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykge1xuICAgICAgICAvLyBTa2lwIHRoZSBcImluZGl2aWR1YWwgZmllbGQgZXh0cmFjdGlvblwiIHN0ZXA7IGV4dHJhY3Rpb24gd2lsbCBiZSBoYW5kbGVkIHdoZW4gYnVpbGRpbmcgY2hhaW4gYm9keSBpbnN0ZWFkXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGNvbWJpbmVDaGFpbkJvZHkoZGF0YSwgY2hhaW4sIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSB7XG4gICAgICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbi5ib2R5O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIFRPRE86IEJldHRlciByZXVzZSBvcHRpb25zIGluIHRoZSBmdXR1cmUuIFRoaXMgc291cmNlIGlzIHZlcnkgc3BlY2lmaWNhbGx5IHRpZWQgdG8gdGhlIFVNIFBvcnRhbERldiBBUEksIHdoZXJlXG4gICAgICAgIC8vICAgdGhlIGZpZWxkIG5hbWUgaXMgYWx3YXlzIFwibG9nX3B2YWx1ZVwiLiBSZWxhdGl2ZWx5IGZldyBzaXRlcyB3aWxsIHdyaXRlIHRoZWlyIG93biBnd2FzLWNhdGFsb2cgZW5kcG9pbnQuXG4gICAgICAgIGNvbnN0IGRlY2lkZXIgPSAnbG9nX3B2YWx1ZSc7XG4gICAgICAgIGNvbnN0IGRlY2lkZXJfb3V0ID0gb3V0bmFtZXNbZmllbGRzLmluZGV4T2YoZGVjaWRlcildO1xuXG4gICAgICAgIGZ1bmN0aW9uIGxlZnRKb2luKGxlZnQsIHJpZ2h0LCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykgeyAvLyBBZGQgYGZpZWxkc2AgZnJvbSBgcmlnaHRgIHRvIGBsZWZ0YFxuICAgICAgICAgICAgLy8gQWRkIGEgc3ludGhldGljLCB1bi1uYW1lc3BhY2VkIGZpZWxkIHRvIGFsbCBtYXRjaGluZyByZWNvcmRzXG4gICAgICAgICAgICBjb25zdCBuX21hdGNoZXMgPSBsZWZ0WyduX2NhdGFsb2dfbWF0Y2hlcyddIHx8IDA7XG4gICAgICAgICAgICBsZWZ0WyduX2NhdGFsb2dfbWF0Y2hlcyddID0gbl9tYXRjaGVzICsgMTtcbiAgICAgICAgICAgIGlmIChkZWNpZGVyICYmIGxlZnRbZGVjaWRlcl9vdXRdICYmIGxlZnRbZGVjaWRlcl9vdXRdID4gcmlnaHRbZGVjaWRlcl0pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBHV0FTIGNhdGFsb2cgZW50cnkgZm9yIHRoZSBzYW1lIFNOUC4gVGhpcyBzb3VyY2UgaXMgaW50ZW5kZWQgZm9yIGEgMToxXG4gICAgICAgICAgICAgICAgLy8gIGFubm90YXRpb24gc2NlbmFyaW8sIHNvIGZvciBub3cgaXQgb25seSBqb2lucyB0aGUgY2F0YWxvZyBlbnRyeSB0aGF0IGhhcyB0aGUgYmVzdCAtbG9nMTAgcHZhbHVlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZuID0gZmllbGRzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dG4gPSBvdXRuYW1lc1tqXTtcblxuICAgICAgICAgICAgICAgIGxldCB2YWwgPSByaWdodFtmbl07XG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zICYmIHRyYW5zW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHRyYW5zW2pdKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxlZnRbb3V0bl0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGFpbk5hbWVzID0gdGhpcy5maW5kTWVyZ2VGaWVsZHMoY2hhaW4uYm9keVswXSk7XG4gICAgICAgIGNvbnN0IGNhdE5hbWVzID0gdGhpcy5maW5kTWVyZ2VGaWVsZHMoZGF0YVswXSk7XG5cbiAgICAgICAgdmFyIGkgPSAwLCBqID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBjaGFpbi5ib2R5Lmxlbmd0aCAmJiBqIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gY2hhaW4uYm9keVtpXTtcbiAgICAgICAgICAgIHZhciByaWdodCA9IGRhdGFbal07XG5cbiAgICAgICAgICAgIGlmIChsZWZ0W2NoYWluTmFtZXMucG9zXSA9PT0gcmlnaHRbY2F0TmFtZXMucG9zXSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZXJlIG1heSBiZSBtdWx0aXBsZSBjYXRhbG9nIGVudHJpZXMgZm9yIGVhY2ggbWF0Y2hpbmcgU05QOyBldmFsdWF0ZSBtYXRjaCBvbmUgYXQgYSB0aW1lXG4gICAgICAgICAgICAgICAgbGVmdEpvaW4obGVmdCwgcmlnaHQsIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKTtcbiAgICAgICAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnRbY2hhaW5OYW1lcy5wb3NdIDwgcmlnaHRbY2F0TmFtZXMucG9zXSkge1xuICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFpbi5ib2R5O1xuICAgIH1cbn1cblxuLyoqXG4gKiBEYXRhIFNvdXJjZSBmb3IgR2VuZSBEYXRhLCBhcyBmZXRjaGVkIGZyb20gdGhlIExvY3VzWm9vbS9Qb3J0YWxkZXYgQVBJIHNlcnZlciAob3IgY29tcGF0aWJsZSBmb3JtYXQpXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIEdlbmVMWiBleHRlbmRzIEJhc2VBcGlBZGFwdGVyIHtcbiAgICBnZXRVUkwoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgYnVpbGQgPSBzdGF0ZS5nZW5vbWVfYnVpbGQgfHwgdGhpcy5wYXJhbXMuYnVpbGQ7XG4gICAgICAgIGxldCBzb3VyY2UgPSB0aGlzLnBhcmFtcy5zb3VyY2U7XG4gICAgICAgIHZhbGlkYXRlQnVpbGRTb3VyY2UodGhpcy5jb25zdHJ1Y3Rvci5uYW1lLCBidWlsZCwgc291cmNlKTtcblxuICAgICAgICBpZiAoYnVpbGQpIHtcbiAgICAgICAgICAgIC8vIElmIGJ1aWxkIHNwZWNpZmllZCwgd2UgYXV0by1zZWxlY3QgdGhlIGJlc3QgY3VycmVudCBwb3J0YWxkZXYgQVBJIGRhdGFzZXQgZm9yIHRoYXQgYnVpbGRcbiAgICAgICAgICAgIC8vIElmIGJ1aWxkIGlzIG5vdCBzcGVjaWZpZWQsIHdlIHVzZSB0aGUgZXhhY3Qgc291cmNlIElEIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLlxuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL3BvcnRhbGRldi5zcGgudW1pY2guZWR1L2FwaS92MS9hbm5vdGF0aW9uL2dlbmVzL3NvdXJjZXMvP2Zvcm1hdD1vYmplY3RzXG4gICAgICAgICAgICBzb3VyY2UgPSAoYnVpbGQgPT09ICdHUkNoMzgnKSA/IDQgOiA1O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnVybH0/ZmlsdGVyPXNvdXJjZSBpbiAke3NvdXJjZX0gYW5kIGNocm9tIGVxICcke3N0YXRlLmNocn0nIGFuZCBzdGFydCBsZSAke3N0YXRlLmVuZH0gYW5kIGVuZCBnZSAke3N0YXRlLnN0YXJ0fWA7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplUmVzcG9uc2UoZGF0YSkge1xuICAgICAgICAvLyBHZW5lcyBoYXZlIGEgdmVyeSBjb21wbGV4IGludGVybmFsIGRhdGEgZm9ybWF0LiBCeXBhc3MgYW55IHJlY29yZCBwYXJzaW5nLCBhbmQgcHJvdmlkZSB0aGUgZGF0YSBsYXllciB3aXRoXG4gICAgICAgIC8vIHRoZSBleGFjdCBpbmZvcm1hdGlvbiByZXR1cm5lZCBieSB0aGUgQVBJLiAoaWdub3JpbmcgdGhlIGZpZWxkcyBhcnJheSBpbiB0aGUgbGF5b3V0KVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBleHRyYWN0RmllbGRzKGRhdGEsIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEYXRhIFNvdXJjZSBmb3IgR2VuZSBDb25zdHJhaW50IERhdGEsIGFzIGZldGNoZWQgZnJvbSB0aGUgZ25vbUFEIHNlcnZlciAob3IgY29tcGF0aWJsZSlcbiAqXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGJlIHRoZSBzZWNvbmQgcmVxdWVzdCBpbiBhIGNoYWluLCB3aXRoIHNwZWNpYWwgbG9naWMgdGhhdCBjb25uZWN0cyBpdCB0byBHZW5lcyBkYXRhXG4gKiAgYWxyZWFkeSBmZXRjaGVkLlxuICpcbiAqIEBwdWJsaWNcbiovXG5jbGFzcyBHZW5lQ29uc3RyYWludExaIGV4dGVuZHMgQmFzZUFwaUFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuICAgICAgICB0aGlzLl9fZGVwZW5kZW50U291cmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0VVJMKCkge1xuICAgICAgICAvLyBHcmFwaFFMIEFQSTogcmVxdWVzdCBkZXRhaWxzIGFyZSBlbmNvZGVkIGluIHRoZSBib2R5LCBub3QgdGhlIFVSTFxuICAgICAgICByZXR1cm4gdGhpcy51cmw7XG4gICAgfVxuXG4gICAgbm9ybWFsaXplUmVzcG9uc2UoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBmZXRjaFJlcXVlc3Qoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgYnVpbGQgPSBzdGF0ZS5nZW5vbWVfYnVpbGQgfHwgdGhpcy5wYXJhbXMuYnVpbGQ7XG4gICAgICAgIGlmICghYnVpbGQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YSBzb3VyY2UgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IG11c3Qgc3BlY2lmeSBhICdnZW5vbWVfYnVpbGQnIG9wdGlvbmApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdW5pcXVlX2dlbmVfbmFtZXMgPSBjaGFpbi5ib2R5LnJlZHVjZShcbiAgICAgICAgICAgIC8vIEluIHJhcmUgY2FzZXMsIHRoZSBzYW1lIGdlbmUgc3ltYm9sIG1heSBhcHBlYXIgYXQgbXVsdGlwbGUgcG9zaXRpb25zLiAoaXNzdWUgIzE3OSkgV2UgZGUtZHVwbGljYXRlIHRoZVxuICAgICAgICAgICAgLy8gIGdlbmUgbmFtZXMgdG8gYXZvaWQgaXNzdWluZyBhIG1hbGZvcm1lZCBHcmFwaFFMIHF1ZXJ5LlxuICAgICAgICAgICAgZnVuY3Rpb24gKGFjYywgZ2VuZSkge1xuICAgICAgICAgICAgICAgIGFjY1tnZW5lLmdlbmVfbmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge31cbiAgICAgICAgKTtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gT2JqZWN0LmtleXModW5pcXVlX2dlbmVfbmFtZXMpLm1hcChmdW5jdGlvbiAoZ2VuZV9uYW1lKSB7XG4gICAgICAgICAgICAvLyBHcmFwaFFMIGFsaWFzIG5hbWVzIG11c3QgbWF0Y2ggYSBzcGVjaWZpYyBzZXQgb2YgYWxsb3dlZCBjaGFyYWN0ZXJzOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDU3NTcwNjUvMTQyMjI2OFxuICAgICAgICAgICAgY29uc3QgYWxpYXMgPSBgXyR7Z2VuZV9uYW1lLnJlcGxhY2UoL1teQS1aYS16MC05X10vZywgJ18nKX1gO1xuICAgICAgICAgICAgLy8gRWFjaCBnZW5lIHN5bWJvbCBpcyBhIHNlcGFyYXRlIGdyYXBoUUwgcXVlcnksIGdyb3VwZWQgaW50byBvbmUgcmVxdWVzdCB1c2luZyBhbGlhc2VzXG4gICAgICAgICAgICByZXR1cm4gYCR7YWxpYXN9OiBnZW5lKGdlbmVfc3ltYm9sOiBcIiR7Z2VuZV9uYW1lfVwiLCByZWZlcmVuY2VfZ2Vub21lOiAke2J1aWxkfSkgeyBnbm9tYWRfY29uc3RyYWludCB7IGV4cF9zeW4gb2JzX3N5biBzeW5feiBvZV9zeW4gb2Vfc3luX2xvd2VyIG9lX3N5bl91cHBlciBleHBfbWlzIG9ic19taXMgbWlzX3ogb2VfbWlzIG9lX21pc19sb3dlciBvZV9taXNfdXBwZXIgZXhwX2xvZiBvYnNfbG9mIHBMSSBvZV9sb2Ygb2VfbG9mX2xvd2VyIG9lX2xvZl91cHBlciB9IH0gYDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFxdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBnZW5lcywgc2tpcCB0aGUgbmV0d29yayByZXF1ZXN0XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZGF0YTogbnVsbCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHF1ZXJ5ID0gYHske3F1ZXJ5LmpvaW4oJyAnKX0gfWA7IC8vIEdyYXBoUUwgaXNuJ3QgcXVpdGUgSlNPTjsgaXRlbXMgYXJlIHNlcGFyYXRlZCBieSBzcGFjZXMgYnV0IG5vdCBjb21tYXNcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5nZXRVUkwoc3RhdGUsIGNoYWluLCBmaWVsZHMpO1xuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ3JhcGhxbC5vcmcvbGVhcm4vc2VydmluZy1vdmVyLWh0dHAvXG4gICAgICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh7IHF1ZXJ5OiBxdWVyeSB9KTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9O1xuXG4gICAgICAgIC8vIE5vdGU6IFRoZSBnbm9tQUQgQVBJIHNvbWV0aW1lcyBmYWlscyByYW5kb21seS5cbiAgICAgICAgLy8gSWYgcmVxdWVzdCBibG9ja2VkLCByZXR1cm4gIGEgZmFrZSBcIm5vIGRhdGFcIiBzaWduYWwgc28gdGhlIGdlbmVzIHRyYWNrIGNhbiBzdGlsbCByZW5kZXIgdy9vIGNvbnN0cmFpbnQgaW5mb1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCB7IG1ldGhvZDogJ1BPU1QnLCBib2R5LCBoZWFkZXJzIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgfSkuY2F0Y2goKGVycikgPT4gW10pO1xuICAgIH1cblxuICAgIGNvbWJpbmVDaGFpbkJvZHkoZGF0YSwgY2hhaW4sIGZpZWxkcywgb3V0bmFtZXMsIHRyYW5zKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhaW4uYm9keS5mb3JFYWNoKGZ1bmN0aW9uKGdlbmUpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgcGF5bG9hZCBrZXlzIHRoYXQgbWF0Y2ggZ2VuZSBuYW1lcyBpbiB0aGlzIHJlc3BvbnNlXG4gICAgICAgICAgICBjb25zdCBhbGlhcyA9IGBfJHtnZW5lLmdlbmVfbmFtZS5yZXBsYWNlKC9bXkEtWmEtejAtOV9dL2csICdfJyl9YDsgIC8vIGFsaWFzZXMgYXJlIG1vZGlmaWVkIGdlbmUgbmFtZXNcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0cmFpbnQgPSBkYXRhW2FsaWFzXSAmJiBkYXRhW2FsaWFzXVsnZ25vbWFkX2NvbnN0cmFpbnQnXTsgLy8gZ25vbWFkIEFQSSBoYXMgdHdvIHdheXMgb2Ygc3BlY2lmeWluZyBtaXNzaW5nIGRhdGEgZm9yIGEgcmVxdWVzdGVkIGdlbmVcbiAgICAgICAgICAgIGlmIChjb25zdHJhaW50KSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGFsbCBmaWVsZHMgZnJvbSBjb25zdHJhaW50IGRhdGEtIGRvIG5vdCBvdmVycmlkZSBmaWVsZHMgcHJlc2VudCBpbiB0aGUgZ2VuZSBzb3VyY2VcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjb25zdHJhaW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbCA9IGNvbnN0cmFpbnRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnZW5lW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PSAnbnVtYmVyJyAmJiB2YWwudG9TdHJpbmcoKS5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VGbG9hdCh2YWwudG9GaXhlZCgyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lW2tleV0gPSB2YWw7ICAgLy8gVGhlc2UgdHdvIHNvdXJjZXMgYXJlIGJvdGggZGVzaWduZWQgdG8gYnlwYXNzIG5hbWVzcGFjaW5nXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjaGFpbi5ib2R5O1xuICAgIH1cbn1cblxuLyoqXG4gKiBEYXRhIFNvdXJjZSBmb3IgUmVjb21iaW5hdGlvbiBSYXRlIERhdGEsIGFzIGZldGNoZWQgZnJvbSB0aGUgTG9jdXNab29tIEFQSSBzZXJ2ZXIgKG9yIGNvbXBhdGlibGUpXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFJlY29tYkxaIGV4dGVuZHMgQmFzZUFwaUFkYXB0ZXIge1xuICAgIGdldFVSTChzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICBjb25zdCBidWlsZCA9IHN0YXRlLmdlbm9tZV9idWlsZCB8fCB0aGlzLnBhcmFtcy5idWlsZDtcbiAgICAgICAgbGV0IHNvdXJjZSA9IHRoaXMucGFyYW1zLnNvdXJjZTtcbiAgICAgICAgdmFsaWRhdGVCdWlsZFNvdXJjZSh0aGlzLmNvbnN0cnVjdG9yLlNPVVJDRV9OQU1FLCBidWlsZCwgc291cmNlKTtcblxuICAgICAgICBpZiAoYnVpbGQpIHsgLy8gSWYgYnVpbGQgc3BlY2lmaWVkLCBjaG9vc2UgYSBrbm93biBQb3J0YWwgQVBJIGRhdGFzZXQgSURzIChidWlsZCAzNy8zOClcbiAgICAgICAgICAgIHNvdXJjZSA9IChidWlsZCA9PT0gJ0dSQ2gzOCcpID8gMTYgOiAxNTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7dGhpcy51cmx9P2ZpbHRlcj1pZCBpbiAke3NvdXJjZX0gYW5kIGNocm9tb3NvbWUgZXEgJyR7c3RhdGUuY2hyfScgYW5kIHBvc2l0aW9uIGxlICR7c3RhdGUuZW5kfSBhbmQgcG9zaXRpb24gZ2UgJHtzdGF0ZS5zdGFydH1gO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEYXRhIFNvdXJjZSBmb3Igc3RhdGljIGJsb2JzIG9mIGRhdGEgYXMgcmF3IEpTIG9iamVjdHMuIFRoaXMgZG9lcyBub3QgcGVyZm9ybSBhZGRpdGlvbmFsIHBhcnNpbmcsIHdoaWNoIGlzIHJlcXVpcmVkXG4gKiAgZm9yIHNvbWUgc291cmNlcyAoZWcgd2hlbiBqb2luaW5nIHRvZ2V0aGVyIExEIGFuZCBhc3NvY2lhdGlvbiBkYXRhKS5cbiAqXG4gKiBUaGVyZWZvcmUgaXQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSB1c2VyIHRvIHBhc3MgaW5mb3JtYXRpb24gaW4gYSBmb3JtYXQgdGhhdCBjYW4gYmUgcmVhZCBhbmRcbiAqIHVuZGVyc3Rvb2QgYnkgdGhlIGNob3NlbiBwbG90LSBhIFN0YXRpY0pTT04gc291cmNlIGlzIHJhcmVseSBhIGRyb3AtaW4gcmVwbGFjZW1lbnQuXG4gKlxuICogVGhpcyBzb3VyY2UgaXMgbGFyZ2VseSBoZXJlIGZvciBsZWdhY3kgcmVhc29ucy4gTW9yZSBvZnRlbiwgYSBjb252ZW5pZW50IHdheSB0byBzZXJ2ZSBzdGF0aWMgZGF0YSBpcyBhcyBzZXBhcmF0ZVxuICogIEpTT04gZmlsZXMgdG8gYW4gZXhpc3Rpbmcgc291cmNlICh3aXRoIHRoZSBKU09OIHVybCBpbiBwbGFjZSBvZiBhbiBBUEkpLlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBTdGF0aWNTb3VyY2UgZXh0ZW5kcyBCYXNlQWRhcHRlciB7XG4gICAgcGFyc2VJbml0KGRhdGEpIHtcbiAgICAgICAgLy8gRG9lcyBub3QgcmVjZWl2ZSBhbnkgY29uZmlnOyB0aGUgb25seSBhcmd1bWVudCBpcyB0aGUgcmF3IGRhdGEsIGVtYmVkZGVkIHdoZW4gc291cmNlIGlzIGNyZWF0ZWRcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuICAgIGdldFJlcXVlc3Qoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9kYXRhKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBEYXRhIHNvdXJjZSBmb3IgUGhlV0FTIGRhdGEgcmV0cmlldmVkIGZyb20gYSBMb2N1c1pvb20vUG9ydGFsRGV2IGNvbXBhdGlibGUgQVBJXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBpbml0LnBhcmFtcy5idWlsZCBUaGlzIGRhdGFzb3VyY2UgZXhwZWN0cyB0byBiZSBwcm92aWRlZCB0aGUgbmFtZSBvZiB0aGUgZ2Vub21lIGJ1aWxkIHRoYXQgd2lsbFxuICogICBiZSB1c2VkIHRvIHByb3ZpZGUgcGhlV0FTIHJlc3VsdHMgZm9yIHRoaXMgcG9zaXRpb24uIE5vdGUgcG9zaXRpb25zIG1heSBub3QgdHJhbnNsYXRlIGJldHdlZW4gYnVpbGRzLlxuICovXG5jbGFzcyBQaGVXQVNMWiBleHRlbmRzIEJhc2VBcGlBZGFwdGVyIHtcbiAgICBnZXRVUkwoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgY29uc3QgYnVpbGQgPSAoc3RhdGUuZ2Vub21lX2J1aWxkID8gW3N0YXRlLmdlbm9tZV9idWlsZF0gOiBudWxsKSB8fCB0aGlzLnBhcmFtcy5idWlsZDtcbiAgICAgICAgaWYgKCFidWlsZCB8fCAhQXJyYXkuaXNBcnJheShidWlsZCkgfHwgIWJ1aWxkLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFsnRGF0YSBzb3VyY2UnLCB0aGlzLmNvbnN0cnVjdG9yLlNPVVJDRV9OQU1FLCAncmVxdWlyZXMgdGhhdCB5b3Ugc3BlY2lmeSBhcnJheSBvZiBvbmUgb3IgbW9yZSBkZXNpcmVkIGdlbm9tZSBidWlsZCBuYW1lcyddLmpvaW4oJyAnKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gW1xuICAgICAgICAgICAgdGhpcy51cmwsXG4gICAgICAgICAgICBcIj9maWx0ZXI9dmFyaWFudCBlcSAnXCIsIGVuY29kZVVSSUNvbXBvbmVudChzdGF0ZS52YXJpYW50KSwgXCInJmZvcm1hdD1vYmplY3RzJlwiLFxuICAgICAgICAgICAgYnVpbGQubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBidWlsZD0ke2VuY29kZVVSSUNvbXBvbmVudChpdGVtKX1gO1xuICAgICAgICAgICAgfSkuam9pbignJicpLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gdXJsLmpvaW4oJycpO1xuICAgIH1cblxuICAgIGdldENhY2hlS2V5KHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgbm90IGEgcmVnaW9uLWJhc2VkIHNvdXJjZTsgaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIGNhY2hlIGJ5IGEgcmVnaW9uXG4gICAgICAgIHJldHVybiB0aGlzLmdldFVSTChzdGF0ZSwgY2hhaW4sIGZpZWxkcyk7XG4gICAgfVxufVxuXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgXCJjb25uZWN0b3JzXCItIHRoaXMgaXMgbWVhbnQgdG8gYmUgc3ViY2xhc3NlZCwgcmF0aGVyIHRoYW4gdXNlZCBkaXJlY3RseS5cbiAqXG4gKiBBIGNvbm5lY3RvciBpcyBhIHNvdXJjZSB0aGF0IG1ha2VzIG5vIHNlcnZlciByZXF1ZXN0cyBhbmQgY2FjaGVzIG5vIGRhdGEgb2YgaXRzIG93bi4gSW5zdGVhZCwgaXQgZGVjaWRlcyBob3cgdG9cbiAqICBjb21iaW5lIGRhdGEgZnJvbSBvdGhlciBzb3VyY2VzIGluIHRoZSBjaGFpbi4gQ29ubmVjdG9ycyBhcmUgdXNlZnVsIHdoZW4gd2Ugd2FudCB0byByZXF1ZXN0IChvciBjYWxjdWxhdGUpIHNvbWVcbiAqICB1c2VmdWwgcGllY2Ugb2YgaW5mb3JtYXRpb24gb25jZSwgYnV0IGFwcGx5IGl0IHRvIG1hbnkgZGlmZmVyZW50IGtpbmRzIG9mIHJlY29yZCB0eXBlcy5cbiAqXG4gKiBUeXBpY2FsbHksIGEgc3ViY2xhc3Mgd2lsbCBpbXBsZW1lbnQgdGhlIGZpZWxkIG1lcmdpbmcgbG9naWMgaW4gYGNvbWJpbmVDaGFpbkJvZHlgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbml0IENvbmZpZ3VyYXRpb24gZm9yIHRoaXMgc291cmNlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5pdC5zb3VyY2VzIFNwZWNpZnkgaG93IHRoZSBoYXJkLWNvZGVkIGxvZ2ljIHNob3VsZCBmaW5kIHRoZSBkYXRhIGl0IHJlbGllcyBvbiBpbiB0aGUgY2hhaW4sXG4gKiAgYXMge2ludGVybmFsX25hbWU6IGNoYWluX3NvdXJjZV9pZH0gcGFpcnMuIFRoaXMgYWxsb3dzIHdyaXRpbmcgYSByZXVzYWJsZSBjb25uZWN0b3IgdGhhdCBkb2VzIG5vdCBuZWVkIHRvIG1ha2VcbiAqICBhc3N1bXB0aW9ucyBhYm91dCB3aGF0IG5hbWVzcGFjZXMgYSBzb3VyY2UgaXMgdXNpbmcuXG4gKiBAdHlwZSB7KnxGdW5jdGlvbn1cbiAqL1xuY2xhc3MgQ29ubmVjdG9yU291cmNlIGV4dGVuZHMgQmFzZUFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICBzdXBlcihjb25maWcpO1xuXG4gICAgICAgIGlmICghY29uZmlnIHx8ICFjb25maWcuc291cmNlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25uZWN0b3JzIG11c3Qgc3BlY2lmeSB0aGUgZGF0YSB0aGV5IHJlcXVpcmUgYXMgaW5pdC5zb3VyY2VzID0ge2ludGVybmFsX25hbWU6IGNoYWluX3NvdXJjZV9pZH19IHBhaXJzJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGVsbHMgdGhlIGNvbm5lY3RvciBob3cgdG8gZmluZCB0aGUgZGF0YSBpdCByZWxpZXMgb25cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIGV4YW1wbGUsIGEgY29ubmVjdG9yIHRoYXQgYXBwbGllcyBidXJkZW4gdGVzdCBpbmZvcm1hdGlvbiB0byB0aGUgZ2VuZXMgbGF5ZXIgbWlnaHQgc3BlY2lmeTpcbiAgICAgICAgICogIHtnZW5lX25zOiBcImdlbmVcIiwgYWdncmVnYXRpb25fbnM6IFwiYWdncmVnYXRpb25cIn1cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc291cmNlX25hbWVfbWFwcGluZyA9IGNvbmZpZy5zb3VyY2VzO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhpcyBzb3VyY2UgaGFzIGJlZW4gdG9sZCBob3cgdG8gZmluZCB0aGUgcmVxdWlyZWQgaW5mb3JtYXRpb25cbiAgICAgICAgY29uc3Qgc3BlY2lmaWVkX2lkcyA9IE9iamVjdC5rZXlzKGNvbmZpZy5zb3VyY2VzKTtcbiAgICAgICAgLyoqIEBwcm9wZXJ0eSB7U3RyaW5nW119IFNwZWNpZmllcyB0aGUgc291cmNlcyB0aGF0IG11c3QgYmUgcHJvdmlkZWQgaW4gdGhlIG9yaWdpbmFsIGNvbmZpZyBvYmplY3QgKi9cblxuICAgICAgICB0aGlzLl9nZXRSZXF1aXJlZFNvdXJjZXMoKS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNwZWNpZmllZF9pZHMuaW5jbHVkZXMoaykpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBGaXggY29uc3RydWN0b3IubmFtZSB1c2FnZSBpbiBtaW5pZmllZCBidW5kbGVzXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25maWd1cmF0aW9uIGZvciAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gbXVzdCBzcGVjaWZ5IGEgc291cmNlIElEIGNvcnJlc3BvbmRpbmcgdG8gJHtrfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTdHViLSBjb25uZWN0b3JzIGRvbid0IGhhdmUgdGhlaXIgb3duIHVybCBvciBkYXRhLCBzbyB0aGUgZGVmYXVsdHMgZG9uJ3QgbWFrZSBzZW5zZVxuICAgIHBhcnNlSW5pdCgpIHt9XG5cbiAgICBnZXRSZXF1ZXN0KHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgIC8vIENvbm5lY3RvcnMgZG8gbm90IHJlcXVlc3QgdGhlaXIgb3duIGRhdGEgYnkgZGVmaW5pdGlvbiwgYnV0IHRoZXkgKmRvKiBkZXBlbmQgb24gb3RoZXIgc291cmNlcyBoYXZpbmcgYmVlbiBsb2FkZWRcbiAgICAgICAgLy8gIGZpcnN0LiBUaGlzIG1ldGhvZCBwZXJmb3JtcyBiYXNpYyB2YWxpZGF0aW9uLCBhbmQgcHJlc2VydmVzIHRoZSBhY2N1bXVsYXRlZCBib2R5IGZyb20gdGhlIGNoYWluIHNvIGZhci5cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fc291cmNlX25hbWVfbWFwcGluZykuZm9yRWFjaCgobnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoYWluX3NvdXJjZV9pZCA9IHRoaXMuX3NvdXJjZV9uYW1lX21hcHBpbmdbbnNdO1xuICAgICAgICAgICAgaWYgKGNoYWluLmRpc2NyZXRlICYmICFjaGFpbi5kaXNjcmV0ZVtjaGFpbl9zb3VyY2VfaWRdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gY2Fubm90IGJlIHVzZWQgYmVmb3JlIGxvYWRpbmcgcmVxdWlyZWQgZGF0YSBmb3I6ICR7Y2hhaW5fc291cmNlX2lkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjaGFpbi5ib2R5IHx8IFtdKTtcbiAgICB9XG5cbiAgICBwYXJzZVJlc3BvbnNlKGRhdGEsIGNoYWluLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykge1xuICAgICAgICAvLyBBIGNvbm5lY3RvciBzb3VyY2UgZG9lcyBub3QgdXBkYXRlIGNoYWluLmRpc2NyZXRlLCBidXQgaXQgbWF5IHVzZSBpdC4gSXQgYnlwYXNzZXMgZGF0YSBmb3JtYXR0aW5nXG4gICAgICAgIC8vICBhbmQgZmllbGQgc2VsZWN0aW9uIChib3RoIGFyZSBhc3N1bWVkIHRvIGhhdmUgYmVlbiBkb25lIGFscmVhZHksIGJ5IHRoZSBwcmV2aW91cyBzb3VyY2VzIHRoaXMgZHJhd3MgZnJvbSlcblxuICAgICAgICAvLyBCZWNhdXNlIG9mIGhvdyB0aGUgY2hhaW4gd29ya3MsIGNvbm5lY3RvcnMgYXJlIG5vdCB2ZXJ5IGdvb2QgYXQgYXBwbHlpbmcgbmV3IHRyYW5zZm9ybWF0aW9ucyBvciBuYW1lc3BhY2luZy5cbiAgICAgICAgLy8gVHlwaWNhbGx5IGNvbm5lY3RvcnMgYXJlIGNhbGxlZCB3aXRoIGBjb25uZWN0b3JfbmFtZTphbGxgIGluIHRoZSBmaWVsZHMgYXJyYXkuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5jb21iaW5lQ2hhaW5Cb2R5KGRhdGEsIGNoYWluLCBmaWVsZHMsIG91dG5hbWVzLCB0cmFucykpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbihuZXdfYm9keSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7aGVhZGVyOiBjaGFpbi5oZWFkZXIgfHwge30sIGRpc2NyZXRlOiBjaGFpbi5kaXNjcmV0ZSB8fCB7fSwgYm9keTogbmV3X2JvZHl9O1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29tYmluZUNoYWluQm9keShyZWNvcmRzLCBjaGFpbikge1xuICAgICAgICAvLyBTdHViIG1ldGhvZDogc3BlY2lmaWVzIGhvdyB0byBjb21iaW5lIHRoZSBkYXRhXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIHN1YmNsYXNzJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCBzaW5jZSBFUzYgZG9lc24ndCBzdXBwb3J0IGNsYXNzIGZpZWxkc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2dldFJlcXVpcmVkU291cmNlcygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgYW4gYXJyYXkgdGhhdCBpZGVudGlmZXMgdGhlIGtpbmQgb2YgZGF0YSByZXF1aXJlZCBieSB0aGlzIHNvdXJjZScpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQmFzZUFkYXB0ZXIsIEJhc2VBcGlBZGFwdGVyIH07XG5cbmV4cG9ydCB7XG4gICAgQXNzb2NpYXRpb25MWixcbiAgICBDb25uZWN0b3JTb3VyY2UsXG4gICAgR2VuZUNvbnN0cmFpbnRMWixcbiAgICBHZW5lTFosXG4gICAgR3dhc0NhdGFsb2dMWixcbiAgICBMRFNlcnZlcixcbiAgICBQaGVXQVNMWixcbiAgICBSZWNvbWJMWixcbiAgICBTdGF0aWNTb3VyY2UsXG59O1xuIiwiLyoqIEBtb2R1bGUgKi9cbi8qXG4gKiBMb2N1c1pvb20gZXh0ZW5zaW9ucyB1c2VkIHRvIGNhbGN1bGF0ZSBhbmQgcmVuZGVyIGFnZ3JlZ2F0aW9uIHRlc3QgcmVzdWx0cy4gQmVjYXVzZSB0aGVzZSBjYWxjdWxhdGlvbnMgZGVwZW5kIG9uIGFuXG4gKiAgIGV4dGVybmFsIGxpYnJhcnksIHRoZSBzcGVjaWFsIGRhdGEgc291cmNlcyBhcmUgZGVmaW5lZCBoZXJlLCByYXRoZXIgdGhhbiBpbiBMb2N1c1pvb20gY29yZSBjb2RlLlxuICpcbiAqICAgICBUaGUgcGFnZSBtdXN0IGluY29ycG9yYXRlIGFuZCBsb2FkIGFsbCBsaWJyYXJpZXMgYmVmb3JlIHRoaXMgZmlsZSBjYW4gYmUgdXNlZCwgaW5jbHVkaW5nOlxuICogICAgLSBWZW5kb3IgYXNzZXRzXG4gKiAgICAtIExvY3VzWm9vbVxuICogICAgLSByYXJlbWV0YWwuanMgKGF2YWlsYWJsZSB2aWEgTlBNIG9yIGEgcmVsYXRlZCBDRE4pXG4gKi9cbi8vIFRoaXMgaXMgZGVmaW5lZCBhcyBhIFVNRCBtb2R1bGUsIHRvIHdvcmsgd2l0aCBtdWx0aXBsZSBkaWZmZXJlbnQgbW9kdWxlIHN5c3RlbXMgLyBidW5kbGVyc1xuLy8gQXJjYW5lIGJ1aWxkIG5vdGU6IGV2ZXJ5dGhpbmcgZGVmaW5lZCBoZXJlIGdldHMgcmVnaXN0ZXJlZCBnbG9iYWxseS4gVGhpcyBpcyBub3QgYSBcInB1cmVcIiBtb2R1bGUsIGFuZCBzb21lIGJ1aWxkXG4vLyAgc3lzdGVtcyBtYXkgcmVxdWlyZSBiZWluZyB0b2xkIHRoYXQgdGhpcyBmaWxlIGhhcyBzaWRlIGVmZmVjdHMuXG5cbmltcG9ydCB7aGVscGVyc30gZnJvbSAncmFyZW1ldGFsLmpzJztcbmltcG9ydCB7QmFzZUFwaUFkYXB0ZXJ9IGZyb20gJy4uL2RhdGEvYWRhcHRlcnMnO1xuXG5cbmZ1bmN0aW9uIGluc3RhbGwgKExvY3VzWm9vbSkge1xuICAgIC8qKlxuICAgICAqIERhdGEgU291cmNlIHRoYXQgY2FsY3VsYXRlcyBnZW5lIG9yIHJlZ2lvbi1iYXNlZCB0ZXN0cyBiYXNlZCBvbiBwcm92aWRlZCBkYXRhXG4gICAgICogICBJdCB3aWxsIHJhcmVseSBiZSB1c2VkIGJ5IGl0c2VsZiwgYnV0IHJhdGhlciB1c2luZyBhIGNvbm5lY3RvciB0aGF0IGF0dGFjaGVzIHRoZSByZXN1bHRzIHRvIGRhdGEgZnJvbVxuICAgICAqICAgYW5vdGhlciBzb3VyY2UgKGxpa2UgZ2VuZXMpLiBVc2luZyBhIHNlcGFyYXRlIGNvbm5lY3RvciBhbGxvd3MgdXMgdG8gYWRkIGNhY2hpbmcgYW5kIHJ1biB0aGlzIGZyb250LWVuZFxuICAgICAqICAgY2FsY3VsYXRpb24gb25seSBvbmNlLCB3aGlsZSB1c2luZyBpdCBpbiBtYW55IGRpZmZlcmVudCBwbGFjZXNcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY29uc3QgQmFzZUFkYXB0ZXIgPSBMb2N1c1pvb20uQWRhcHRlcnMuZ2V0KCdCYXNlQWRhcHRlcicpO1xuICAgIGNvbnN0IENvbm5lY3RvclNvdXJjZSA9IExvY3VzWm9vbS5BZGFwdGVycy5nZXQoJ0Nvbm5lY3RvclNvdXJjZScpO1xuXG4gICAgY2xhc3MgQWdncmVnYXRpb25UZXN0U291cmNlIGV4dGVuZHMgQmFzZUFwaUFkYXB0ZXIge1xuICAgICAgICBnZXRVUkwoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgICAgIC8vIFVubGlrZSBtb3N0IHNvdXJjZXMsIGNhbGN1bGF0aW9ucyBtYXkgcmVxdWlyZSBhY2Nlc3MgdG8gcGxvdCBzdGF0ZSBkYXRhIGV2ZW4gYWZ0ZXIgdGhlIGluaXRpYWwgcmVxdWVzdFxuICAgICAgICAgICAgLy8gVGhpcyBleGFtcGxlIHNvdXJjZSBSRVFVSVJFUyB0aGF0IHRoZSBleHRlcm5hbCBVSSB3aWRnZXQgd291bGQgc3RvcmUgdGhlIG5lZWRlZCB0ZXN0IGRlZmluaXRpb25zIGluIGEgcGxvdCBzdGF0ZVxuICAgICAgICAgICAgLy8gIGZpZWxkIGNhbGxlZCBgYWdncmVnYXRpb25fdGVzdHNgIChhbiBvYmplY3Qge21hc2tzOiBbXSwgY2FsY3M6IHt9KVxuICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRfaW5mbyA9IHN0YXRlLmFnZ3JlZ2F0aW9uX3Rlc3RzIHx8IHt9O1xuXG4gICAgICAgICAgICBpZiAoIWNoYWluLmhlYWRlcikge1xuICAgICAgICAgICAgICAgIGNoYWluLmhlYWRlciA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWxsIG9mIHRoZXNlIGZpZWxkcyBhcmUgcmVxdWlyZWQgaW4gb3JkZXIgdG8gdXNlIHRoaXMgZGF0YXNvdXJjZS4gVE9ETzogQWRkIHZhbGlkYXRpb24/XG4gICAgICAgICAgICBjaGFpbi5oZWFkZXIuYWdncmVnYXRpb25fZ2Vub3NldF9pZCA9IHJlcXVpcmVkX2luZm8uZ2Vub3NldF9pZCB8fCBudWxsOyAvLyBOdW1iZXJcbiAgICAgICAgICAgIGNoYWluLmhlYWRlci5hZ2dyZWdhdGlvbl9nZW5vc2V0X2J1aWxkID0gcmVxdWlyZWRfaW5mby5nZW5vc2V0X2J1aWxkIHx8IG51bGw7IC8vIFN0cmluZ1xuICAgICAgICAgICAgY2hhaW4uaGVhZGVyLmFnZ3JlZ2F0aW9uX3BoZW5vc2V0X2lkID0gcmVxdWlyZWRfaW5mby5waGVub3NldF9pZCB8fCBudWxsOyAgLy8gTnVtYmVyXG4gICAgICAgICAgICBjaGFpbi5oZWFkZXIuYWdncmVnYXRpb25fcGhlbm8gPSByZXF1aXJlZF9pbmZvLnBoZW5vIHx8IG51bGw7IC8vIFN0cmluZ1xuICAgICAgICAgICAgY2hhaW4uaGVhZGVyLmFnZ3JlZ2F0aW9uX2NhbGNzID0gcmVxdWlyZWRfaW5mby5jYWxjcyB8fCB7fTsgIC8vIFN0cmluZ1tdXG4gICAgICAgICAgICBjb25zdCBtYXNrX2RhdGEgPSByZXF1aXJlZF9pbmZvLm1hc2tzIHx8IFtdO1xuICAgICAgICAgICAgY2hhaW4uaGVhZGVyLmFnZ3JlZ2F0aW9uX21hc2tzID0gbWFza19kYXRhOyAgLy8ge25hbWU6ZGVzY31bXVxuICAgICAgICAgICAgY2hhaW4uaGVhZGVyLmFnZ3JlZ2F0aW9uX21hc2tfaWRzID0gbWFza19kYXRhLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLm5hbWU7XG4gICAgICAgICAgICB9KTsgLy8gTnVtYmVyW11cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldENhY2hlS2V5KHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgICAgICB0aGlzLmdldFVSTChzdGF0ZSwgY2hhaW4sIGZpZWxkcyk7ICAvLyBUT0RPOiBUaGlzIGp1c3Qgc2V0cyB0aGUgY2hhaW4uaGVhZGVyIGZpZWxkc1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBjaHJvbTogc3RhdGUuY2hyLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGF0ZS5zdGFydCxcbiAgICAgICAgICAgICAgICBzdG9wOiBzdGF0ZS5lbmQsXG4gICAgICAgICAgICAgICAgZ2Vub3R5cGVEYXRhc2V0OiBjaGFpbi5oZWFkZXIuYWdncmVnYXRpb25fZ2Vub3NldF9pZCxcbiAgICAgICAgICAgICAgICBwaGVub3R5cGVEYXRhc2V0OiBjaGFpbi5oZWFkZXIuYWdncmVnYXRpb25fcGhlbm9zZXRfaWQsXG4gICAgICAgICAgICAgICAgcGhlbm90eXBlOiBjaGFpbi5oZWFkZXIuYWdncmVnYXRpb25fcGhlbm8sXG4gICAgICAgICAgICAgICAgc2FtcGxlczogJ0FMTCcsXG4gICAgICAgICAgICAgICAgZ2Vub21lQnVpbGQ6IGNoYWluLmhlYWRlci5hZ2dyZWdhdGlvbl9nZW5vc2V0X2J1aWxkLFxuICAgICAgICAgICAgICAgIG1hc2tzOiBjaGFpbi5oZWFkZXIuYWdncmVnYXRpb25fbWFza19pZHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZldGNoUmVxdWVzdChzdGF0ZSwgY2hhaW4sIGZpZWxkcykge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gdGhpcy5nZXRVUkwoc3RhdGUsIGNoYWluLCBmaWVsZHMpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuZ2V0Q2FjaGVLZXkoc3RhdGUsIGNoYWluLCBmaWVsZHMpO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIGZldGNoKHVybCwge21ldGhvZDogJ1BPU1QnLCBib2R5OiBib2R5LCBoZWFkZXJzOiBoZWFkZXJzfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uID0gdHlwZW9mIHJlc3AgPT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKHJlc3ApIDogcmVzcDtcbiAgICAgICAgICAgICAgICBpZiAoanNvbi5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBSQVJFTUVUQUwtc2VydmVyIHF1aXJrOiBUaGUgQVBJIHNvbWV0aW1lcyByZXR1cm5zIGEgMjAwIHN0YXR1cyBjb2RlIGZvciBmYWlsZWQgcmVxdWVzdHMsXG4gICAgICAgICAgICAgICAgICAgIC8vICAgIHdpdGggYSBodW1hbi1yZWFkYWJsZSBlcnJvciBkZXNjcmlwdGlvbiBhcyBhIGtleVxuICAgICAgICAgICAgICAgICAgICAvLyBGb3Igbm93LCB0aGlzIHNob3VsZCBiZSB0cmVhdGVkIHN0cmljdGx5IGFzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihqc29uLmVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFubm90YXRlRGF0YShyZWNvcmRzLCBjaGFpbikge1xuICAgICAgICAgICAgLy8gT3BlcmF0ZSBvbiB0aGUgY2FsY3VsYXRlZCByZXN1bHRzLiBUaGUgcmVzdWx0IG9mIHRoaXMgbWV0aG9kIHdpbGwgYmUgYWRkZWQgdG8gY2hhaW4uZGlzY3JldGVcblxuICAgICAgICAgICAgLy8gSW4gYSBwYWdlIHVzaW5nIGxpdmUgQVBJIGRhdGEsIHRoZSBVSSB3b3VsZCBvbmx5IHJlcXVlc3QgdGhlIG1hc2tzIGl0IG5lZWRzIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICAgIC8vIEJ1dCBpbiBvdXIgZGVtb3MsIHNvbWV0aW1lcyBib2lsZXJwbGF0ZSBKU09OIGhhcyBtb3JlIG1hc2tzIHRoYW4gdGhlIFVJIGFza2VkIGZvci4gTGltaXQgd2hhdCBjYWxjcyB3ZSBydW4gKGJ5XG4gICAgICAgICAgICAvLyAgdHlwZSwgYW5kIHRvIHRoZSBzZXQgb2YgZ3JvdXBzIHJlcXVlc3RlZCBieSB0aGUgdXNlcilcblxuICAgICAgICAgICAgLy8gVGhlIFJhcmVtZXRhbC1zZXJ2ZXIgQVBJIGhhcyBhIHF1aXJrOiBpdCByZXR1cm5zIGEgZGlmZmVyZW50IHBheWxvYWQgc3RydWN0dXJlIGlmIG5vIGdyb3VwcyBhcmUgZGVmaW5lZFxuICAgICAgICAgICAgLy8gIGZvciB0aGUgcmVxdWVzdCByZWdpb24uIERldGVjdCB3aGVuIHRoYXQgaGFwcGVucyBhbmQgZW5kIHRoZSBjYWxjdWxhdGlvbiBpbW1lZGlhdGVseSBpbiB0aGF0IGNhc2VcbiAgICAgICAgICAgIGlmICghcmVjb3Jkcy5ncm91cHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBncm91cHM6IFtdLCB2YXJpYW50czogW10gfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVjb3Jkcy5ncm91cHMgPSByZWNvcmRzLmdyb3Vwcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5ncm91cFR5cGUgPT09ICdHRU5FJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBoZWxwZXJzLnBhcnNlUG9ydGFsSlNPTihyZWNvcmRzKTtcbiAgICAgICAgICAgIGxldCBncm91cHMgPSBwYXJzZWRbMF07XG4gICAgICAgICAgICBjb25zdCB2YXJpYW50cyA9IHBhcnNlZFsxXTtcbiAgICAgICAgICAgIC8vIFNvbWUgQVBJcyBtYXkgcmV0dXJuIG1vcmUgZGF0YSB0aGFuIHdlIHdhbnQgKGVnIHNpbXBsZSBzaXRlcyB0aGF0IGFyZSBqdXN0IHNlcnZpbmcgdXAgcHJlbWFkZSBzY29yZWNvdiBqc29uIGZpbGVzKS5cbiAgICAgICAgICAgIC8vICBGaWx0ZXIgdGhlIHJlc3BvbnNlIHRvIGp1c3Qgd2hhdCB0aGUgdXNlciBoYXMgY2hvc2VuIHRvIGFuYWx5emUuXG4gICAgICAgICAgICBncm91cHMgPSBncm91cHMuYnlNYXNrKGNoYWluLmhlYWRlci5hZ2dyZWdhdGlvbl9tYXNrX2lkcyk7XG5cbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGF0IGNhbGN1bGF0aW9ucyB0byBydW5cbiAgICAgICAgICAgIGNvbnN0IGNhbGNzID0gY2hhaW4uaGVhZGVyLmFnZ3JlZ2F0aW9uX2NhbGNzO1xuICAgICAgICAgICAgaWYgKCFjYWxjcyB8fCBPYmplY3Qua2V5cyhjYWxjcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gY2FsY3MgaGF2ZSBiZWVuIHJlcXVlc3RlZCwgdGhlbiByZXR1cm4gYSBkdW1teSBwbGFjZWhvbGRlciBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhcmlhbnRzOiBbXSwgZ3JvdXBzOiBbXSwgcmVzdWx0czogW10gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJ1bm5lciA9IG5ldyBoZWxwZXJzLlBvcnRhbFRlc3RSdW5uZXIoZ3JvdXBzLCB2YXJpYW50cywgY2FsY3MpO1xuXG4gICAgICAgICAgICByZXR1cm4gcnVubmVyLnRvSlNPTigpXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnRlcm5hbGx5LCByYXJlbWV0YWwgaGVscGVycyB0cmFjayBob3cgdGhlIGNhbGN1bGF0aW9uIGlzIGRvbmUsIGJ1dCBub3QgYW55IGRpc3BsYXktZnJpZW5kbHkgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgYW5ub3RhdGUgZWFjaCBtYXNrIG5hbWUgKGlkKSB3aXRoIGEgaHVtYW4tZnJpZW5kbHkgZGVzY3JpcHRpb24gZm9yIGxhdGVyIHVzZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXNrX2lkX3RvX2Rlc2MgPSBjaGFpbi5oZWFkZXIuYWdncmVnYXRpb25fbWFza3MucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjW3ZhbC5uYW1lXSA9IHZhbC5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmRhdGEuZ3JvdXBzLmZvckVhY2goZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cC5tYXNrX25hbWUgPSBtYXNrX2lkX3RvX2Rlc2NbZ3JvdXAubWFza107XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmRhdGE7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY2FsY3VsYXRlIGFnZ3JlZ2F0aW9uIHRlc3QgcmVzdWx0cycpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplUmVzcG9uc2UoZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICBjb21iaW5lQ2hhaW5Cb2R5KHJlY29yZHMsIGNoYWluKSB7XG4gICAgICAgICAgICAvLyBhZ2dyZWdhdGlvbiB0ZXN0cyBhcmUgYSBiaXQgdW5pcXVlLCBpbiB0aGF0IHRoZSBkYXRhIGlzIHJhcmVseSB1c2VkIGRpcmVjdGx5LSBpbnN0ZWFkIGl0IGlzIHVzZWQgdG8gYW5ub3RhdGUgbWFueVxuICAgICAgICAgICAgLy8gIG90aGVyIGxheWVycyBpbiBkaWZmZXJlbnQgd2F5cy4gVGhlIGNhbGN1bGF0ZWQgcmVzdWx0IGhhcyBiZWVuIGFkZGVkIHRvIGBjaGFpbi5kaXNjcmV0ZWAsIGJ1dCB3aWxsIG5vdCBiZSByZXR1cm5lZFxuICAgICAgICAgICAgLy8gIGFzIHBhcnQgb2YgdGhlIHJlc3BvbnNlIGJvZHkgYnVpbHQgdXAgYnkgdGhlIGNoYWluXG4gICAgICAgICAgICByZXR1cm4gY2hhaW4uYm9keTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgY2xhc3MgQXNzb2NGcm9tQWdncmVnYXRpb25MWiBleHRlbmRzIEJhc2VBZGFwdGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoIWNvbmZpZyB8fCAhY29uZmlnLmZyb20pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnTXVzdCBzcGVjaWZ5IHRoZSBuYW1lIG9mIHRoZSBzb3VyY2UgdGhhdCBjb250YWlucyBhc3NvY2lhdGlvbiBkYXRhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VJbml0KGNvbmZpZykge1xuICAgICAgICAgICAgc3VwZXIucGFyc2VJbml0KGNvbmZpZyk7XG4gICAgICAgICAgICB0aGlzLl9mcm9tID0gY29uZmlnLmZyb207XG4gICAgICAgIH1cblxuICAgICAgICBnZXRSZXF1ZXN0KHN0YXRlLCBjaGFpbiwgZmllbGRzKSB7XG4gICAgICAgICAgICAvLyBEb2VzIG5vdCBhY3R1YWxseSBtYWtlIGEgcmVxdWVzdC4gSnVzdCBwaWNrIG9mZiB0aGUgc3BlY2lmaWMgYnVuZGxlIG9mIGRhdGEgZnJvbSBhIGtub3duIHBheWxvYWQgc3RydWN0dXJlLlxuICAgICAgICAgICAgaWYgKGNoYWluLmRpc2NyZXRlICYmICFjaGFpbi5kaXNjcmV0ZVt0aGlzLl9mcm9tXSkge1xuICAgICAgICAgICAgICAgIHRocm93IGAke3RoaXMuY29uc3RydWN0b3IuU09VUkNFX05BTUV9IGNhbm5vdCBiZSB1c2VkIGJlZm9yZSBsb2FkaW5nIHJlcXVpcmVkIGRhdGEgZm9yOiAke3RoaXMuX2Zyb219YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvcHkgdGhlIGRhdGEgc28gdGhhdCBtdXRhdGlvbnMgKGxpa2Ugc29ydGluZykgZG9uJ3QgYWZmZWN0IHRoZSBvcmlnaW5hbFxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNoYWluLmRpc2NyZXRlW3RoaXMuX2Zyb21dWyd2YXJpYW50cyddKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9ybWFsaXplUmVzcG9uc2UoZGF0YSkge1xuICAgICAgICAgICAgLy8gVGhlIHBheWxvYWQgc3RydWN0dXJlIG9mIHRoZSBhc3NvY2lhdGlvbiBzb3VyY2UgaXMgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gdGhlIG9uZSByZXF1aXJlZCBieSBhc3NvY2lhdGlvblxuICAgICAgICAgICAgLy8gICBwbG90cy4gRm9yIGV4YW1wbGUsIHdlIG5lZWQgdG8gcGFyc2UgdmFyaWFudCBuYW1lcyBhbmQgY29udmVydCB0byBsb2dfcHZhbHVlXG4gICAgICAgICAgICBjb25zdCBSRUdFWF9FUEFDVFMgPSBuZXcgUmVnRXhwKCcoPzpjaHIpPyguKyk6KFxcXFxkKylfPyhcXFxcdyspPy8/KFteX10rKT9fPyguKik/Jyk7ICAvLyBtYXRjaCBBUEkgdmFyaWFudCBzdHJpbmdzXG4gICAgICAgICAgICByZXR1cm4gZGF0YS5tYXAoKG9uZV92YXJpYW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBvbmVfdmFyaWFudC52YXJpYW50Lm1hdGNoKFJFR0VYX0VQQUNUUyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFudDogb25lX3ZhcmlhbnQudmFyaWFudCxcbiAgICAgICAgICAgICAgICAgICAgY2hyb21vc29tZTogbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiArbWF0Y2hbMl0sXG4gICAgICAgICAgICAgICAgICAgIHJlZl9hbGxlbGU6IG1hdGNoWzNdLFxuICAgICAgICAgICAgICAgICAgICByZWZfYWxsZWxlX2ZyZXE6IDEgLSBvbmVfdmFyaWFudC5hbHRGcmVxLFxuICAgICAgICAgICAgICAgICAgICBsb2dfcHZhbHVlOiAtTWF0aC5sb2cxMChvbmVfdmFyaWFudC5wdmFsdWUpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgYSA9IGEudmFyaWFudDtcbiAgICAgICAgICAgICAgICBiID0gYi52YXJpYW50O1xuICAgICAgICAgICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhID4gYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBuYW1lcyBtdXN0IGJlIGVxdWFsXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzYW1wbGUgY29ubmVjdG9yIHRoYXQgYWxpZ25zIGNhbGN1bGF0ZWQgYWdncmVnYXRpb24gdGVzdCBkYXRhIHdpdGggY29ycmVzcG9uZGluZyBnZW5lIGluZm9ybWF0aW9uLiBSZXR1cm5zIGEgYm9keVxuICAgICAqICAgc3VpdGFibGUgZm9yIHVzZSB3aXRoIHRoZSBnZW5lcyBkYXRhbGF5ZXIuXG4gICAgICpcbiAgICAgKiAgVG8gdXNlIHRoaXMgc291cmNlLCBvbmUgbXVzdCBzcGVjaWZ5IGEgZmllbGRzIGFycmF5IHRoYXQgY2FsbHMgZmlyc3QgdGhlIGdlbmVzIHNvdXJjZSwgdGhlbiBhIGR1bW15IGZpZWxkIGZyb21cbiAgICAgKiAgICAgIHRoaXMgc291cmNlLiBUaGUgb3V0cHV0IHdpbGwgYmUgdG8gdHJhbnNwYXJlbnRseSBhZGQgc2V2ZXJhbCBuZXcgZmllbGRzIHRvIHRoZSBnZW5lcyBkYXRhLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBHZW5lQWdncmVnYXRpb25Db25uZWN0b3JMWiBleHRlbmRzIENvbm5lY3RvclNvdXJjZSB7XG4gICAgICAgIF9nZXRSZXF1aXJlZFNvdXJjZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gWydnZW5lX25zJywgJ2FnZ3JlZ2F0aW9uX25zJ107XG4gICAgICAgIH1cblxuICAgICAgICBjb21iaW5lQ2hhaW5Cb2R5KGRhdGEsIGNoYWluKSB7XG4gICAgICAgICAgICAvLyBUaGUgZ2VuZXMgbGF5ZXIgcmVjZWl2ZXMgYWxsIHJlc3VsdHMsIGFuZCBkaXNwbGF5cyBvbmx5IHRoZSBiZXN0IHB2YWx1ZSBmb3IgZWFjaCBnZW5lXG5cbiAgICAgICAgICAgIC8vIFRpZSB0aGUgY2FsY3VsYXRlZCBncm91cC10ZXN0IHJlc3VsdHMgdG8gZ2VuZXMgd2l0aCBhIG1hdGNoaW5nIG5hbWVcbiAgICAgICAgICAgIGNvbnN0IGFnZ3JlZ2F0aW9uX3NvdXJjZV9pZCA9IHRoaXMuX3NvdXJjZV9uYW1lX21hcHBpbmdbJ2FnZ3JlZ2F0aW9uX25zJ107XG4gICAgICAgICAgICBjb25zdCBnZW5lX3NvdXJjZV9pZCA9IHRoaXMuX3NvdXJjZV9uYW1lX21hcHBpbmdbJ2dlbmVfbnMnXTtcbiAgICAgICAgICAgIC8vIFRoaXMgY29ubmVjdG9yIGFzc3VtZXMgdGhhdCBnZW5lcyBhcmUgdGhlIG1haW4gYm9keSBvZiByZWNvcmRzIGZyb20gdGhlIGNoYWluLCBhbmQgdGhhdCBhZ2dyZWdhdGlvbiB0ZXN0cyBhcmVcbiAgICAgICAgICAgIC8vICAgYSBzdGFuZGFsb25lIHNvdXJjZSB0aGF0IGhhcyBub3QgYWN0ZWQgb24gZ2VuZXMgZGF0YSB5ZXRcbiAgICAgICAgICAgIGNvbnN0IGFnZ3JlZ2F0aW9uRGF0YSA9IGNoYWluLmRpc2NyZXRlW2FnZ3JlZ2F0aW9uX3NvdXJjZV9pZF07XG4gICAgICAgICAgICBjb25zdCBnZW5lc0RhdGEgPSBjaGFpbi5kaXNjcmV0ZVtnZW5lX3NvdXJjZV9pZF07XG5cbiAgICAgICAgICAgIGNvbnN0IGdyb3VwZWRBZ2dyZWdhdGlvbiA9IHt9OyAgLy8gR3JvdXAgdG9nZXRoZXIgYWxsIHRlc3RzIGRvbmUgb24gdGhhdCBnZW5lLSBhbnkgbWFzaywgYW55IHRlc3RcblxuICAgICAgICAgICAgYWdncmVnYXRpb25EYXRhLmdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChncm91cGVkQWdncmVnYXRpb24sIHJlc3VsdC5ncm91cCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBlZEFnZ3JlZ2F0aW9uW3Jlc3VsdC5ncm91cF0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3JvdXBlZEFnZ3JlZ2F0aW9uW3Jlc3VsdC5ncm91cF0ucHVzaChyZXN1bHQucHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBBbm5vdGF0ZSBhbnkgZ2VuZXMgdGhhdCBoYXZlIHRlc3QgcmVzdWx0c1xuICAgICAgICAgICAgZ2VuZXNEYXRhLmZvckVhY2goZnVuY3Rpb24gKGdlbmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnZW5lX2lkID0gZ2VuZS5nZW5lX25hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdHMgPSBncm91cGVkQWdncmVnYXRpb25bZ2VuZV9pZF07XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlbmUuYWdncmVnYXRpb25fYmVzdF9wdmFsdWUgPSBNYXRoLm1pbi5hcHBseShudWxsLCB0ZXN0cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXNEYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBMb2N1c1pvb20uQWRhcHRlcnMuYWRkKCdBZ2dyZWdhdGlvblRlc3RTb3VyY2VMWicsIEFnZ3JlZ2F0aW9uVGVzdFNvdXJjZSk7XG4gICAgTG9jdXNab29tLkFkYXB0ZXJzLmFkZCgnQXNzb2NGcm9tQWdncmVnYXRpb25MWicsIEFzc29jRnJvbUFnZ3JlZ2F0aW9uTFopO1xuICAgIExvY3VzWm9vbS5BZGFwdGVycy5hZGQoJ0dlbmVBZ2dyZWdhdGlvbkNvbm5lY3RvckxaJywgR2VuZUFnZ3JlZ2F0aW9uQ29ubmVjdG9yTFopO1xufVxuXG5cbmlmICh0eXBlb2YgTG9jdXNab29tICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEF1dG8tcmVnaXN0ZXIgdGhlIHBsdWdpbiB3aGVuIGluY2x1ZGVkIGFzIGEgc2NyaXB0IHRhZy4gRVM2IG1vZHVsZSB1c2VycyBtdXN0IHJlZ2lzdGVyIHZpYSBMb2N1c1pvb20udXNlKClcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICBMb2N1c1pvb20udXNlKGluc3RhbGwpO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IGluc3RhbGw7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJhcmVtZXRhbDsiXSwic291cmNlUm9vdCI6IiJ9