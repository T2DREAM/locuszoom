{"version":3,"sources":["lz-aggregation-tests.min.js"],"names":["root","factory","define","amd","LocusZoom","raremetal","module","exports","require","ext","Data","sources","Object","keys","forEach","key","this","AggregationTestSource","Source","extend","init","parseInit","prototype","getURL","state","chain","fields","required_info","aggregation_tests","header","aggregation_genoset_id","genoset_id","aggregation_genoset_build","genoset_build","aggregation_phenoset_id","phenoset_id","aggregation_pheno","pheno","aggregation_calcs","calcs","mask_data","masks","aggregation_masks","aggregation_mask_ids","map","item","name","url","getCacheKey","JSON","stringify","chrom","chr","start","stop","end","genotypeDataset","phenotypeDataset","phenotype","samples","genomeBuild","fetchRequest","body","createCORSPromise","Content-Type","then","resp","json","parse","error","Error","annotateData","records","groups","variants","filter","groupType","parsed","helpers","parsePortalJSON","byMask","length","PortalTestRunner","toJSON","res","mask_id_to_desc","reduce","acc","val","description","data","group","mask_name","mask","catch","e","console","results","normalizeResponse","combineChainBody","AssocFromAggregationLZ","KnownDataSources","from","params","_from","getRequest","discrete","self","constructor","SOURCE_NAME","Promise","resolve","REGEX_EPACTS","RegExp","one_variant","match","variant","chromosome","position","ref_allele","ref_allele_freq","altFreq","log_pvalue","Math","log10","pvalue","sort","a","b","GeneAggregationConnectorLZ","REQUIRED_SOURCES","aggregation_source_id","_source_name_mapping","gene_source_id","aggregationData","genesData","groupedAggregation","result","hasOwnProperty","push","gene","gene_id","gene_name","tests","aggregation_best_pvalue","min","apply"],"mappings":"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","file":"lz-aggregation-tests.min.js","sourcesContent":["'use strict';\n/*\n * LocusZoom extensions used to calculate and render aggregation test results. Because these calculations depend on an\n *   external library, the special data sources are defined here, rather than in LocusZoom core code.\n *\n *     The page must incorporate and load all libraries before this file can be used, including:\n *    - Vendor assets\n *    - LocusZoom\n *    - raremetal.js (available via NPM or a related CDN)\n */\n// This is defined as a UMD module, to work with multiple different module systems / bundlers\n// Arcane build note: everything defined here gets registered globally. This is not a \"pure\" module, and some build\n//  systems may require being told that this file has side effects.\n/* global define, module, require, Promise */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(['locuszoom', 'raremetal.js'] , function(LocusZoom, raremetal) {  // amd\n            return factory(LocusZoom, raremetal);\n        });\n    } else if(typeof module === 'object' && module.exports) {  // commonJS\n        module.exports = factory(require('locuszoom'), require('raremetal.js'));\n    } else {  // globals\n        if (!root.LocusZoom.ext.Data) {\n            root.LocusZoom.ext.Data = {};\n        }\n        var sources = factory(root.LocusZoom, root.raremetal);\n        Object.keys(sources).forEach(function(key) {\n            root.LocusZoom.ext.Data[key] = sources[key];\n        });\n    }\n}(this, function(LocusZoom, raremetal) {\n    /**\n     * Data Source that calculates gene or region-based tests based on provided data\n     *   It will rarely be used by itself, but rather using a connector that attaches the results to data from\n     *   another source (like genes). Using a separate connector allows us to add caching and run this front-end\n     *   calculation only once, while using it in many different places\n     * @public\n     * @class\n     * @augments LocusZoom.Data.Source\n     */\n    var AggregationTestSource = LocusZoom.Data.Source.extend(function (init) {\n        this.parseInit(init);\n    }, 'AggregationTestSourceLZ');\n\n    AggregationTestSource.prototype.getURL = function (state, chain, fields) {\n        // Unlike most sources, calculations may require access to plot state data even after the initial request\n        // This example source REQUIRES that the external UI widget would store the needed test definitions in a plot state\n        //  field called `aggregation_tests` (an object {masks: [], calcs: {})\n        var required_info = state.aggregation_tests || {};\n\n        if (!chain.header) {\n            chain.header = {};\n        }\n        // All of these fields are required in order to use this datasource. TODO: Add validation?\n        chain.header.aggregation_genoset_id = required_info.genoset_id || null; // Number\n        chain.header.aggregation_genoset_build = required_info.genoset_build || null; // String\n        chain.header.aggregation_phenoset_id = required_info.phenoset_id || null;  // Number\n        chain.header.aggregation_pheno = required_info.pheno || null; // String\n        chain.header.aggregation_calcs = required_info.calcs || {};  // String[]\n        var mask_data = required_info.masks || [];\n        chain.header.aggregation_masks = mask_data;  // {name:desc}[]\n        chain.header.aggregation_mask_ids = mask_data.map(function(item) { return item.name; }); // Number[]\n        return this.url;\n    };\n\n    AggregationTestSource.prototype.getCacheKey = function (state, chain, fields) {\n        this.getURL(state, chain, fields);  // TODO: This just sets the chain.header fields\n        return JSON.stringify({\n            chrom: state.chr,\n            start: state.start,\n            stop: state.end,\n            genotypeDataset: chain.header.aggregation_genoset_id,\n            phenotypeDataset: chain.header.aggregation_phenoset_id,\n            phenotype: chain.header.aggregation_pheno,\n            samples: 'ALL',\n            genomeBuild: chain.header.aggregation_genoset_build,\n            masks: chain.header.aggregation_mask_ids,\n        });\n    };\n\n\n    AggregationTestSource.prototype.fetchRequest = function (state, chain, fields) {\n        var url = this.getURL(state, chain, fields);\n        var body = this.getCacheKey(state, chain, fields);\n        var headers = {\n            'Content-Type': 'application/json'\n        };\n        return LocusZoom.createCORSPromise('POST', url, body, headers)\n            .then(function (resp) {\n                var json = typeof resp == 'string' ? JSON.parse(resp) : resp;\n                if (json.error) {\n                    // RAREMETAL-server quirk: The API sometimes returns a 200 status code for failed requests,\n                    //    with a human-readable error description as a key\n                    // For now, this should be treated strictly as an error\n                    throw new Error(json.error);\n                }\n                return json;\n            });\n    };\n\n    AggregationTestSource.prototype.annotateData = function (records, chain) {\n        // Operate on the calculated results. The result of this method will be added to chain.discrete\n\n        // In a page using live API data, the UI would only request the masks it needs from the API.\n        // But in our demos, sometimes boilerplate JSON has more masks than the UI asked for. Limit what calcs we run (by\n        //  type, and to the set of groups requested by the user)\n\n        // The Raremetal-server API has a quirk: it returns a different payload structure if no groups are defined\n        //  for the request region. Detect when that happens and end the calculation immediately in that case\n        if (!records.groups) {\n            return { groups: [], variants: [] };\n        }\n\n        records.groups = records.groups.filter(function (item) {\n            return item.groupType === 'GENE';\n        });\n\n        var parsed = raremetal.helpers.parsePortalJSON(records);\n        var groups = parsed[0];\n        var variants = parsed[1];\n        // Some APIs may return more data than we want (eg simple sites that are just serving up premade scorecov json files).\n        //  Filter the response to just what the user has chosen to analyze.\n        groups = groups.byMask(chain.header.aggregation_mask_ids);\n\n        // Determine what calculations to run\n        var calcs = chain.header.aggregation_calcs;\n        if (!calcs || Object.keys(calcs).length === 0) {\n            // If no calcs have been requested, then return a dummy placeholder immediately\n            return { variants: [], groups: [], results: [] };\n        }\n        var runner = new raremetal.helpers.PortalTestRunner(groups, variants, calcs);\n\n        return runner.toJSON()\n            .then(function(res) {\n                // Internally, raremetal helpers track how the calculation is done, but not any display-friendly values\n                // We will annotate each mask name (id) with a human-friendly description for later use\n                var mask_id_to_desc  = chain.header.aggregation_masks.reduce(function(acc, val) {\n                    acc[val.name] = val.description;\n                    return acc;\n                }, {});\n                res.data.groups.forEach(function(group)  {\n                    group.mask_name = mask_id_to_desc[group.mask];\n                });\n                return res.data;\n            })\n            .catch(function(e) {\n                console.error(e);\n                throw new Error('Failed to calculate aggregation test results');\n            });\n    };\n\n    AggregationTestSource.prototype.normalizeResponse = function (data) {\n        return data;\n    };\n\n    AggregationTestSource.prototype.combineChainBody = function (records, chain) {\n        // aggregation tests are a bit unique, in that the data is rarely used directly- instead it is used to annotate many\n        //  other layers in different ways. The calculated result has been added to `chain.discrete`, but will not be returned\n        //  as part of the response body built up by the chain\n        return chain.body;\n    };\n\n\n    /**\n     * A custom data source that reformats existing association data, rather than requesting new data from the server.\n     *  In this case, aggregation test calculations have already made data about variants available, and that data only\n     *  needs to be reformatted to work with the association data layer.\n     *\n     * @public\n     * @class\n     * @augments LocusZoom.Data.Source\n     */\n    var AssocFromAggregationLZ = LocusZoom.KnownDataSources.extend('AssociationLZ', 'AssocFromAggregationLZ', {\n        parseInit: function (init) {\n            if (!init || !init.from) {\n                throw 'Must specify the name of the source that contains association data';\n            }\n            this.params = init.params || {};\n            this._from = init.from;\n        },\n\n        getRequest: function (state, chain, fields) {\n            // Does not actually make a request. Just pick off the specific bundle of data from a known payload structure.\n            if (chain.discrete && !chain.discrete[this._from]) {\n                throw self.constructor.SOURCE_NAME + ' cannot be used before loading required data for: ' + this._from;\n            }\n            // Copy the data so that mutations (like sorting) don't affect the original\n            return Promise.resolve(JSON.parse(JSON.stringify(chain.discrete[this._from]['variants'])));\n        },\n\n        normalizeResponse: function (data) {\n            // The payload structure of the association source is slightly different than the one required by association\n            //   plots. For example, we need to parse variant names and convert to log_pvalue\n            var REGEX_EPACTS = new RegExp('(?:chr)?(.+):(\\\\d+)_?(\\\\w+)?/?([^_]+)?_?(.*)?');  // match API variant strings\n            return data.map(function (one_variant) {\n                var match = one_variant.variant.match(REGEX_EPACTS);\n                return {\n                    variant: one_variant.variant,\n                    chromosome: match[1],\n                    position: +match[2],\n                    ref_allele: match[3],\n                    ref_allele_freq: 1 - one_variant.altFreq,\n                    log_pvalue: -Math.log10(one_variant.pvalue)\n                };\n            }).sort(function (a, b) {\n                a = a.variant;\n                b = b.variant;\n                if (a < b) {\n                    return -1;\n                } else if (a > b) {\n                    return 1;\n                } else {\n                    // names must be equal\n                    return 0;\n                }\n            });\n        }\n    });\n\n\n    /**\n     * A sample connector that aligns calculated aggregation test data with corresponding gene information. Returns a body\n     *   suitable for use with the genes datalayer.\n     *\n     *  To use this source, one must specify a fields array that calls first the genes source, then a dummy field from\n     *      this source. The output will be to transparently add several new fields to the genes data.\n     * @public\n     * @class\n     * @augments LocusZoom.Data.Source\n     */\n    var GeneAggregationConnectorLZ = LocusZoom.KnownDataSources.extend('ConnectorSource', 'GeneAggregationConnectorLZ', {\n        REQUIRED_SOURCES: ['gene_ns', 'aggregation_ns'],\n        combineChainBody: function (data, chain) {\n            // The genes layer receives all results, and displays only the best pvalue for each gene\n\n            // Tie the calculated group-test results to genes with a matching name\n            var aggregation_source_id = this._source_name_mapping['aggregation_ns'];\n            var gene_source_id = this._source_name_mapping['gene_ns'];\n            // This connector assumes that genes are the main body of records from the chain, and that aggregation tests are\n            //   a standalone source that has not acted on genes data yet\n            var aggregationData = chain.discrete[aggregation_source_id];\n            var genesData = chain.discrete[gene_source_id];\n\n            var groupedAggregation = {};  // Group together all tests done on that gene- any mask, any test\n\n            aggregationData.groups.forEach(function (result) {\n                if (!groupedAggregation.hasOwnProperty(result.group)) {\n                    groupedAggregation[result.group] = [];\n                }\n                groupedAggregation[result.group].push(result.pvalue);\n            });\n\n            // Annotate any genes that have test results\n            genesData.forEach(function (gene) {\n                var gene_id = gene.gene_name;\n                var tests = groupedAggregation[gene_id];\n                if (tests) {\n                    gene.aggregation_best_pvalue = Math.min.apply(null, tests);\n                }\n            });\n            return genesData;\n        }\n    });\n\n\n    // Public interface for this extension; since everything is registered w/LocusZoom, this is rarely used directly.\n    return {\n        AggregationTestSource: AggregationTestSource,\n        AssocFromAggregationLZ: AssocFromAggregationLZ,\n        GeneAggregationConnectorLZ: GeneAggregationConnectorLZ\n    };\n}));\n"]}