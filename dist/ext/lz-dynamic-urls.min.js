/*! Locuszoom 0.13.0-beta.3 */
var LzDynamicUrls =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./esm/ext/lz-dynamic-urls.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./esm/ext/lz-dynamic-urls.js":
/*!************************************!*\
  !*** ./esm/ext/lz-dynamic-urls.js ***!
  \************************************/
/*! exports provided: default, paramsFromUrl, extractValues, plotUpdatesUrl, plotWatchesUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "paramsFromUrl", function() { return paramsFromUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extractValues", function() { return _extractValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plotUpdatesUrl", function() { return plotUpdatesUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "plotWatchesUrl", function() { return plotWatchesUrl; });
/**
 * Optional LocusZoom extension: must be included separately, and after LocusZoom has been loaded
 *
 * This plugin exports helper functions, but does not modify the global registry. It does not require `LocusZoom.use`.
 *
 * Demonstrates a mechanism by which the plot can be loaded to a specific initial state based on the URL query string
 *  (and, optionally, to update the URL bar when the plot state changes, with back button support)
 *
 * This makes it possible to create "direct links" to a particular plot of interest (and go back to a previous state
 *  as the user interacts with the page). Optionally, there is support for custom callbacks to connect the URL to
 *  arbitrarily complex plot behaviors.
 *  @module
 */

function _serializeQueryParams(paramsObj) {
    // Serialize an object of parameter values into a query string
    // TODO: Improve support for array values v[]=1&v[]=2
    return `?${
        Object.keys(paramsObj).map(function(key) {
            return `${encodeURIComponent(key)}=${encodeURIComponent(paramsObj[key])}`;
        }).join('&')}`;
}

function _parseQueryParams(queryString) {
    // Parse a query string into an object of parameter values.
    //   Does not attempt any type coercion; all values are, therefore, strings.
    // TODO future: Support arrays / params that specify more than one value
    const query = {};
    if (queryString) {
        const pairs = (queryString[0] === '?' ? queryString.substr(1) : queryString).split('&');
        for (let i = 0; i < pairs.length; i++) {
            const pair = pairs[i].split('=');
            query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
        }
    }
    return query;
}

// A useful helper function for serializing values from a provided object
function _extractValues(data, mapping, reverse) {
    // Use the mapping to convert between {stateField: urlParam} (or the reverse). Any fields not referenced in
    //  the "key" side of the mapping will be omitted from the return value.
    // Likewise, will omit any requested keys that the source side of the mapping has no information for
    reverse = reverse || false;

    const ret = {};
    let newMapping = mapping;
    if (reverse) {
        newMapping = {};
        Object.keys(mapping).forEach(function(k) {
            newMapping[mapping[k]] = k;
        });
    }

    Object.keys(newMapping).forEach(function(k) {
        const asName = newMapping[k];
        if (Object.prototype.hasOwnProperty.call(data, k)) {
            ret[asName] = data[k];
        }

    });
    return ret;
}

function _setStateFromUrlHandler(plot, stateData) {
    // A default way to deal with URL changes: push all the params as state into plot and rerender
    // More complex handlers are possible- example, URL parameters could be used to add or remove data layers
    plot.applyState(stateData);
}

function _setUrlFromStateHandler(plot, mapping) {
    // Serialize and return basic query params based solely on information from plot.state
    // More complex handlers are possible- the serializer can extract any information desired because it is given
    //  a direct reference to the plot object

    // This default method does not use the eventContext data, because so many things change plot.state without
    //  officially triggering an event.
    return _extractValues(plot.state, mapping);
}

/**
 * Extract plot parameters from the URL query string. Very useful for setting up the plot on initial page load.
 * @param {object} mapping How to map elements of plot state to URL param fields. Hash of
 *      {plotFieldName: urlParamName} entries (both values should be unique)
 * @param {string} [queryString='window.location.search'] The query string to parse
 * @returns {object} Plot parameter values
 */
function paramsFromUrl(mapping, queryString) {
    // Internal helper function: second argument only used for unit testing
    queryString = queryString || window.location.search;
    const queryParams = _parseQueryParams(queryString);
    return _extractValues(queryParams, mapping, true);
}

/**
 * Allows the plot to monitor changes in the URL and take action when the URL changes.
 *
 * For example, this enables using the browser back button to jump to a previous plot after user interaction.
 *
 * @param {Plot} plot A reference to the LZ plot
 * @param {object} mapping How to map elements of plot state to URL param fields. Hash of
 *      {plotFieldName: urlParamName} entries (both values should be unique)
 * @param {function} [callback] Specify how the plot acts on information read in from query params.
 *   The default behavior is to push the data into `plot.state`
 *   Signature is function(plot, plotDataFromQueryString)
 * @returns {function} The function handle for the new listener (allows cleanup if plot is removed later)
 */
function plotWatchesUrl(plot, mapping, callback) {
    callback = callback || _setStateFromUrlHandler;

    const listener = function (event) {
        const urlData = paramsFromUrl(mapping);
        // Tell the plot what to do with the params extracted from the URL
        callback(plot, urlData);
    };
    window.addEventListener('popstate', listener);
    plot.trackExternalListener(window, 'popstate', listener);
    return listener;
}

/**
 * Update the URL whenever the plot state changes
 * @param {Plot} plot A reference to the LZ plot
 * @param {object} mapping How to map elements of plot state to URL param fields. Hash of
 *      {plotFieldName: urlParamName} entries (both values should be unique)
 * @param {function} [callback] Specify how plot data will be serialized into query params
 *   The default behavior is to extract all the URL params from plot.state as the only source.
 *   Signature is function(plot, mapping, eventContext)
 * @returns {function} The function handle for the new listener (allows cleanup if plot is removed later)
 */
function plotUpdatesUrl(plot, mapping, callback) {
    callback = callback || _setUrlFromStateHandler;
    // Note: this event only fires when applyState receives *new* information that would trigger a rerender.
    // Plot state is sometimes changed without the event being fired.
    const listener = function (eventContext) {
        const oldParams = _parseQueryParams(window.location.search);
        // Apply custom serialization to convert plot data to URL params
        const serializedPlotData = callback(plot, mapping, eventContext);
        const newParams = Object.assign({}, oldParams, serializedPlotData);

        const update = Object.keys(newParams).some(function (k) {
            // Not every state change would affect the URL. Allow type coercion since query is a string.
            // eslint-disable-next-line eqeqeq
            return (oldParams[k] != newParams[k]);
        });
        if (update) {
            const queryString = _serializeQueryParams(newParams);

            if (Object.keys(oldParams).length) {
                history.pushState({}, document.title, queryString);
            } else {
                // Prevent broken back behavior on first page load: the first time query params are set,
                //  we don't generate a separate history entry
                history.replaceState({}, document.title, queryString);
            }

        }
    };
    plot.on('state_changed', listener);
    return listener;
}

// Slight build quirk: we use a single webpack file for all modules, but `libraryTarget` expects the entire
//  module to be exported as `default` in <script> tag mode.
const all = {
    paramsFromUrl,
    extractValues: _extractValues,
    plotUpdatesUrl,
    plotWatchesUrl,
};

/* harmony default export */ __webpack_exports__["default"] = (all);



/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2V4dC9sei1keW5hbWljLXVybHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QixHQUFHLG1DQUFtQztBQUNwRixTQUFTLFlBQVk7QUFDckI7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMscUJBQXFCO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsU0FBUyw0QkFBNEI7QUFDckMsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixTQUFTLDRCQUE0QjtBQUNyQyxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFNBQVMsNEJBQTRCO0FBQ3JDLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQyxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsa0VBQUcsRUFBQztBQUN1RSIsImZpbGUiOiJleHQvbHotZHluYW1pYy11cmxzLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vZXNtL2V4dC9sei1keW5hbWljLXVybHMuanNcIik7XG4iLCIvKipcbiAqIE9wdGlvbmFsIExvY3VzWm9vbSBleHRlbnNpb246IG11c3QgYmUgaW5jbHVkZWQgc2VwYXJhdGVseSwgYW5kIGFmdGVyIExvY3VzWm9vbSBoYXMgYmVlbiBsb2FkZWRcbiAqXG4gKiBUaGlzIHBsdWdpbiBleHBvcnRzIGhlbHBlciBmdW5jdGlvbnMsIGJ1dCBkb2VzIG5vdCBtb2RpZnkgdGhlIGdsb2JhbCByZWdpc3RyeS4gSXQgZG9lcyBub3QgcmVxdWlyZSBgTG9jdXNab29tLnVzZWAuXG4gKlxuICogRGVtb25zdHJhdGVzIGEgbWVjaGFuaXNtIGJ5IHdoaWNoIHRoZSBwbG90IGNhbiBiZSBsb2FkZWQgdG8gYSBzcGVjaWZpYyBpbml0aWFsIHN0YXRlIGJhc2VkIG9uIHRoZSBVUkwgcXVlcnkgc3RyaW5nXG4gKiAgKGFuZCwgb3B0aW9uYWxseSwgdG8gdXBkYXRlIHRoZSBVUkwgYmFyIHdoZW4gdGhlIHBsb3Qgc3RhdGUgY2hhbmdlcywgd2l0aCBiYWNrIGJ1dHRvbiBzdXBwb3J0KVxuICpcbiAqIFRoaXMgbWFrZXMgaXQgcG9zc2libGUgdG8gY3JlYXRlIFwiZGlyZWN0IGxpbmtzXCIgdG8gYSBwYXJ0aWN1bGFyIHBsb3Qgb2YgaW50ZXJlc3QgKGFuZCBnbyBiYWNrIHRvIGEgcHJldmlvdXMgc3RhdGVcbiAqICBhcyB0aGUgdXNlciBpbnRlcmFjdHMgd2l0aCB0aGUgcGFnZSkuIE9wdGlvbmFsbHksIHRoZXJlIGlzIHN1cHBvcnQgZm9yIGN1c3RvbSBjYWxsYmFja3MgdG8gY29ubmVjdCB0aGUgVVJMIHRvXG4gKiAgYXJiaXRyYXJpbHkgY29tcGxleCBwbG90IGJlaGF2aW9ycy5cbiAqICBAbW9kdWxlXG4gKi9cblxuZnVuY3Rpb24gX3NlcmlhbGl6ZVF1ZXJ5UGFyYW1zKHBhcmFtc09iaikge1xuICAgIC8vIFNlcmlhbGl6ZSBhbiBvYmplY3Qgb2YgcGFyYW1ldGVyIHZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG4gICAgLy8gVE9ETzogSW1wcm92ZSBzdXBwb3J0IGZvciBhcnJheSB2YWx1ZXMgdltdPTEmdltdPTJcbiAgICByZXR1cm4gYD8ke1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXNPYmopLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQocGFyYW1zT2JqW2tleV0pfWA7XG4gICAgICAgIH0pLmpvaW4oJyYnKX1gO1xufVxuXG5mdW5jdGlvbiBfcGFyc2VRdWVyeVBhcmFtcyhxdWVyeVN0cmluZykge1xuICAgIC8vIFBhcnNlIGEgcXVlcnkgc3RyaW5nIGludG8gYW4gb2JqZWN0IG9mIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAgLy8gICBEb2VzIG5vdCBhdHRlbXB0IGFueSB0eXBlIGNvZXJjaW9uOyBhbGwgdmFsdWVzIGFyZSwgdGhlcmVmb3JlLCBzdHJpbmdzLlxuICAgIC8vIFRPRE8gZnV0dXJlOiBTdXBwb3J0IGFycmF5cyAvIHBhcmFtcyB0aGF0IHNwZWNpZnkgbW9yZSB0aGFuIG9uZSB2YWx1ZVxuICAgIGNvbnN0IHF1ZXJ5ID0ge307XG4gICAgaWYgKHF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gKHF1ZXJ5U3RyaW5nWzBdID09PSAnPycgPyBxdWVyeVN0cmluZy5zdWJzdHIoMSkgOiBxdWVyeVN0cmluZykuc3BsaXQoJyYnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICBxdWVyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0gfHwgJycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWVyeTtcbn1cblxuLy8gQSB1c2VmdWwgaGVscGVyIGZ1bmN0aW9uIGZvciBzZXJpYWxpemluZyB2YWx1ZXMgZnJvbSBhIHByb3ZpZGVkIG9iamVjdFxuZnVuY3Rpb24gX2V4dHJhY3RWYWx1ZXMoZGF0YSwgbWFwcGluZywgcmV2ZXJzZSkge1xuICAgIC8vIFVzZSB0aGUgbWFwcGluZyB0byBjb252ZXJ0IGJldHdlZW4ge3N0YXRlRmllbGQ6IHVybFBhcmFtfSAob3IgdGhlIHJldmVyc2UpLiBBbnkgZmllbGRzIG5vdCByZWZlcmVuY2VkIGluXG4gICAgLy8gIHRoZSBcImtleVwiIHNpZGUgb2YgdGhlIG1hcHBpbmcgd2lsbCBiZSBvbWl0dGVkIGZyb20gdGhlIHJldHVybiB2YWx1ZS5cbiAgICAvLyBMaWtld2lzZSwgd2lsbCBvbWl0IGFueSByZXF1ZXN0ZWQga2V5cyB0aGF0IHRoZSBzb3VyY2Ugc2lkZSBvZiB0aGUgbWFwcGluZyBoYXMgbm8gaW5mb3JtYXRpb24gZm9yXG4gICAgcmV2ZXJzZSA9IHJldmVyc2UgfHwgZmFsc2U7XG5cbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBsZXQgbmV3TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgbmV3TWFwcGluZyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyhtYXBwaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIG5ld01hcHBpbmdbbWFwcGluZ1trXV0gPSBrO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhuZXdNYXBwaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgY29uc3QgYXNOYW1lID0gbmV3TWFwcGluZ1trXTtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrKSkge1xuICAgICAgICAgICAgcmV0W2FzTmFtZV0gPSBkYXRhW2tdO1xuICAgICAgICB9XG5cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBfc2V0U3RhdGVGcm9tVXJsSGFuZGxlcihwbG90LCBzdGF0ZURhdGEpIHtcbiAgICAvLyBBIGRlZmF1bHQgd2F5IHRvIGRlYWwgd2l0aCBVUkwgY2hhbmdlczogcHVzaCBhbGwgdGhlIHBhcmFtcyBhcyBzdGF0ZSBpbnRvIHBsb3QgYW5kIHJlcmVuZGVyXG4gICAgLy8gTW9yZSBjb21wbGV4IGhhbmRsZXJzIGFyZSBwb3NzaWJsZS0gZXhhbXBsZSwgVVJMIHBhcmFtZXRlcnMgY291bGQgYmUgdXNlZCB0byBhZGQgb3IgcmVtb3ZlIGRhdGEgbGF5ZXJzXG4gICAgcGxvdC5hcHBseVN0YXRlKHN0YXRlRGF0YSk7XG59XG5cbmZ1bmN0aW9uIF9zZXRVcmxGcm9tU3RhdGVIYW5kbGVyKHBsb3QsIG1hcHBpbmcpIHtcbiAgICAvLyBTZXJpYWxpemUgYW5kIHJldHVybiBiYXNpYyBxdWVyeSBwYXJhbXMgYmFzZWQgc29sZWx5IG9uIGluZm9ybWF0aW9uIGZyb20gcGxvdC5zdGF0ZVxuICAgIC8vIE1vcmUgY29tcGxleCBoYW5kbGVycyBhcmUgcG9zc2libGUtIHRoZSBzZXJpYWxpemVyIGNhbiBleHRyYWN0IGFueSBpbmZvcm1hdGlvbiBkZXNpcmVkIGJlY2F1c2UgaXQgaXMgZ2l2ZW5cbiAgICAvLyAgYSBkaXJlY3QgcmVmZXJlbmNlIHRvIHRoZSBwbG90IG9iamVjdFxuXG4gICAgLy8gVGhpcyBkZWZhdWx0IG1ldGhvZCBkb2VzIG5vdCB1c2UgdGhlIGV2ZW50Q29udGV4dCBkYXRhLCBiZWNhdXNlIHNvIG1hbnkgdGhpbmdzIGNoYW5nZSBwbG90LnN0YXRlIHdpdGhvdXRcbiAgICAvLyAgb2ZmaWNpYWxseSB0cmlnZ2VyaW5nIGFuIGV2ZW50LlxuICAgIHJldHVybiBfZXh0cmFjdFZhbHVlcyhwbG90LnN0YXRlLCBtYXBwaW5nKTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IHBsb3QgcGFyYW1ldGVycyBmcm9tIHRoZSBVUkwgcXVlcnkgc3RyaW5nLiBWZXJ5IHVzZWZ1bCBmb3Igc2V0dGluZyB1cCB0aGUgcGxvdCBvbiBpbml0aWFsIHBhZ2UgbG9hZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBtYXBwaW5nIEhvdyB0byBtYXAgZWxlbWVudHMgb2YgcGxvdCBzdGF0ZSB0byBVUkwgcGFyYW0gZmllbGRzLiBIYXNoIG9mXG4gKiAgICAgIHtwbG90RmllbGROYW1lOiB1cmxQYXJhbU5hbWV9IGVudHJpZXMgKGJvdGggdmFsdWVzIHNob3VsZCBiZSB1bmlxdWUpXG4gKiBAcGFyYW0ge3N0cmluZ30gW3F1ZXJ5U3RyaW5nPSd3aW5kb3cubG9jYXRpb24uc2VhcmNoJ10gVGhlIHF1ZXJ5IHN0cmluZyB0byBwYXJzZVxuICogQHJldHVybnMge29iamVjdH0gUGxvdCBwYXJhbWV0ZXIgdmFsdWVzXG4gKi9cbmZ1bmN0aW9uIHBhcmFtc0Zyb21VcmwobWFwcGluZywgcXVlcnlTdHJpbmcpIHtcbiAgICAvLyBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb246IHNlY29uZCBhcmd1bWVudCBvbmx5IHVzZWQgZm9yIHVuaXQgdGVzdGluZ1xuICAgIHF1ZXJ5U3RyaW5nID0gcXVlcnlTdHJpbmcgfHwgd2luZG93LmxvY2F0aW9uLnNlYXJjaDtcbiAgICBjb25zdCBxdWVyeVBhcmFtcyA9IF9wYXJzZVF1ZXJ5UGFyYW1zKHF1ZXJ5U3RyaW5nKTtcbiAgICByZXR1cm4gX2V4dHJhY3RWYWx1ZXMocXVlcnlQYXJhbXMsIG1hcHBpbmcsIHRydWUpO1xufVxuXG4vKipcbiAqIEFsbG93cyB0aGUgcGxvdCB0byBtb25pdG9yIGNoYW5nZXMgaW4gdGhlIFVSTCBhbmQgdGFrZSBhY3Rpb24gd2hlbiB0aGUgVVJMIGNoYW5nZXMuXG4gKlxuICogRm9yIGV4YW1wbGUsIHRoaXMgZW5hYmxlcyB1c2luZyB0aGUgYnJvd3NlciBiYWNrIGJ1dHRvbiB0byBqdW1wIHRvIGEgcHJldmlvdXMgcGxvdCBhZnRlciB1c2VyIGludGVyYWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7UGxvdH0gcGxvdCBBIHJlZmVyZW5jZSB0byB0aGUgTFogcGxvdFxuICogQHBhcmFtIHtvYmplY3R9IG1hcHBpbmcgSG93IHRvIG1hcCBlbGVtZW50cyBvZiBwbG90IHN0YXRlIHRvIFVSTCBwYXJhbSBmaWVsZHMuIEhhc2ggb2ZcbiAqICAgICAge3Bsb3RGaWVsZE5hbWU6IHVybFBhcmFtTmFtZX0gZW50cmllcyAoYm90aCB2YWx1ZXMgc2hvdWxkIGJlIHVuaXF1ZSlcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gU3BlY2lmeSBob3cgdGhlIHBsb3QgYWN0cyBvbiBpbmZvcm1hdGlvbiByZWFkIGluIGZyb20gcXVlcnkgcGFyYW1zLlxuICogICBUaGUgZGVmYXVsdCBiZWhhdmlvciBpcyB0byBwdXNoIHRoZSBkYXRhIGludG8gYHBsb3Quc3RhdGVgXG4gKiAgIFNpZ25hdHVyZSBpcyBmdW5jdGlvbihwbG90LCBwbG90RGF0YUZyb21RdWVyeVN0cmluZylcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gVGhlIGZ1bmN0aW9uIGhhbmRsZSBmb3IgdGhlIG5ldyBsaXN0ZW5lciAoYWxsb3dzIGNsZWFudXAgaWYgcGxvdCBpcyByZW1vdmVkIGxhdGVyKVxuICovXG5mdW5jdGlvbiBwbG90V2F0Y2hlc1VybChwbG90LCBtYXBwaW5nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgX3NldFN0YXRlRnJvbVVybEhhbmRsZXI7XG5cbiAgICBjb25zdCBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBjb25zdCB1cmxEYXRhID0gcGFyYW1zRnJvbVVybChtYXBwaW5nKTtcbiAgICAgICAgLy8gVGVsbCB0aGUgcGxvdCB3aGF0IHRvIGRvIHdpdGggdGhlIHBhcmFtcyBleHRyYWN0ZWQgZnJvbSB0aGUgVVJMXG4gICAgICAgIGNhbGxiYWNrKHBsb3QsIHVybERhdGEpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgbGlzdGVuZXIpO1xuICAgIHBsb3QudHJhY2tFeHRlcm5hbExpc3RlbmVyKHdpbmRvdywgJ3BvcHN0YXRlJywgbGlzdGVuZXIpO1xuICAgIHJldHVybiBsaXN0ZW5lcjtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIFVSTCB3aGVuZXZlciB0aGUgcGxvdCBzdGF0ZSBjaGFuZ2VzXG4gKiBAcGFyYW0ge1Bsb3R9IHBsb3QgQSByZWZlcmVuY2UgdG8gdGhlIExaIHBsb3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBtYXBwaW5nIEhvdyB0byBtYXAgZWxlbWVudHMgb2YgcGxvdCBzdGF0ZSB0byBVUkwgcGFyYW0gZmllbGRzLiBIYXNoIG9mXG4gKiAgICAgIHtwbG90RmllbGROYW1lOiB1cmxQYXJhbU5hbWV9IGVudHJpZXMgKGJvdGggdmFsdWVzIHNob3VsZCBiZSB1bmlxdWUpXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIFNwZWNpZnkgaG93IHBsb3QgZGF0YSB3aWxsIGJlIHNlcmlhbGl6ZWQgaW50byBxdWVyeSBwYXJhbXNcbiAqICAgVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gZXh0cmFjdCBhbGwgdGhlIFVSTCBwYXJhbXMgZnJvbSBwbG90LnN0YXRlIGFzIHRoZSBvbmx5IHNvdXJjZS5cbiAqICAgU2lnbmF0dXJlIGlzIGZ1bmN0aW9uKHBsb3QsIG1hcHBpbmcsIGV2ZW50Q29udGV4dClcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn0gVGhlIGZ1bmN0aW9uIGhhbmRsZSBmb3IgdGhlIG5ldyBsaXN0ZW5lciAoYWxsb3dzIGNsZWFudXAgaWYgcGxvdCBpcyByZW1vdmVkIGxhdGVyKVxuICovXG5mdW5jdGlvbiBwbG90VXBkYXRlc1VybChwbG90LCBtYXBwaW5nLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgX3NldFVybEZyb21TdGF0ZUhhbmRsZXI7XG4gICAgLy8gTm90ZTogdGhpcyBldmVudCBvbmx5IGZpcmVzIHdoZW4gYXBwbHlTdGF0ZSByZWNlaXZlcyAqbmV3KiBpbmZvcm1hdGlvbiB0aGF0IHdvdWxkIHRyaWdnZXIgYSByZXJlbmRlci5cbiAgICAvLyBQbG90IHN0YXRlIGlzIHNvbWV0aW1lcyBjaGFuZ2VkIHdpdGhvdXQgdGhlIGV2ZW50IGJlaW5nIGZpcmVkLlxuICAgIGNvbnN0IGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50Q29udGV4dCkge1xuICAgICAgICBjb25zdCBvbGRQYXJhbXMgPSBfcGFyc2VRdWVyeVBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICAgICAgLy8gQXBwbHkgY3VzdG9tIHNlcmlhbGl6YXRpb24gdG8gY29udmVydCBwbG90IGRhdGEgdG8gVVJMIHBhcmFtc1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkUGxvdERhdGEgPSBjYWxsYmFjayhwbG90LCBtYXBwaW5nLCBldmVudENvbnRleHQpO1xuICAgICAgICBjb25zdCBuZXdQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBvbGRQYXJhbXMsIHNlcmlhbGl6ZWRQbG90RGF0YSk7XG5cbiAgICAgICAgY29uc3QgdXBkYXRlID0gT2JqZWN0LmtleXMobmV3UGFyYW1zKS5zb21lKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgICAvLyBOb3QgZXZlcnkgc3RhdGUgY2hhbmdlIHdvdWxkIGFmZmVjdCB0aGUgVVJMLiBBbGxvdyB0eXBlIGNvZXJjaW9uIHNpbmNlIHF1ZXJ5IGlzIGEgc3RyaW5nLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgcmV0dXJuIChvbGRQYXJhbXNba10gIT0gbmV3UGFyYW1zW2tdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gX3NlcmlhbGl6ZVF1ZXJ5UGFyYW1zKG5ld1BhcmFtcyk7XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvbGRQYXJhbXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGhpc3RvcnkucHVzaFN0YXRlKHt9LCBkb2N1bWVudC50aXRsZSwgcXVlcnlTdHJpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGJyb2tlbiBiYWNrIGJlaGF2aW9yIG9uIGZpcnN0IHBhZ2UgbG9hZDogdGhlIGZpcnN0IHRpbWUgcXVlcnkgcGFyYW1zIGFyZSBzZXQsXG4gICAgICAgICAgICAgICAgLy8gIHdlIGRvbid0IGdlbmVyYXRlIGEgc2VwYXJhdGUgaGlzdG9yeSBlbnRyeVxuICAgICAgICAgICAgICAgIGhpc3RvcnkucmVwbGFjZVN0YXRlKHt9LCBkb2N1bWVudC50aXRsZSwgcXVlcnlTdHJpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHBsb3Qub24oJ3N0YXRlX2NoYW5nZWQnLCBsaXN0ZW5lcik7XG4gICAgcmV0dXJuIGxpc3RlbmVyO1xufVxuXG4vLyBTbGlnaHQgYnVpbGQgcXVpcms6IHdlIHVzZSBhIHNpbmdsZSB3ZWJwYWNrIGZpbGUgZm9yIGFsbCBtb2R1bGVzLCBidXQgYGxpYnJhcnlUYXJnZXRgIGV4cGVjdHMgdGhlIGVudGlyZVxuLy8gIG1vZHVsZSB0byBiZSBleHBvcnRlZCBhcyBgZGVmYXVsdGAgaW4gPHNjcmlwdD4gdGFnIG1vZGUuXG5jb25zdCBhbGwgPSB7XG4gICAgcGFyYW1zRnJvbVVybCxcbiAgICBleHRyYWN0VmFsdWVzOiBfZXh0cmFjdFZhbHVlcyxcbiAgICBwbG90VXBkYXRlc1VybCxcbiAgICBwbG90V2F0Y2hlc1VybCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFsbDtcbmV4cG9ydCB7IHBhcmFtc0Zyb21VcmwsIF9leHRyYWN0VmFsdWVzIGFzIGV4dHJhY3RWYWx1ZXMsIHBsb3RVcGRhdGVzVXJsLCBwbG90V2F0Y2hlc1VybCB9O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==