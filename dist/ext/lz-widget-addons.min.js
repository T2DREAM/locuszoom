/*! Locuszoom 0.13.0-beta.3 */
var LzWidgetAddons =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./esm/ext/lz-widget-addons.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./esm/ext/lz-widget-addons.js":
/*!*************************************!*\
  !*** ./esm/ext/lz-widget-addons.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _helpers_layouts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/layouts */ "./esm/helpers/layouts.js");
/**
 * Optional LocusZoom extension: must be included separately, and after LocusZoom has been loaded
 *
 * This contains (reusable) code to power some (rarely used) demo features:
 *  - The "covariates model" demo, in which an LZ toolbar widget is populated
 *    with information by selecting points on the plot (see "covariates model" demo)
 *  - The "data layers" button, which allows fine control over multiple data layers shown in the same panel
 *    (show/hide, fade, change order, etc). This is powerful, but rarely used because showing many datasets in a small
 *    space is hard to read. (see "multiple phenotypes layered" demo)
 * @module
 */


// In order to work in a UMD context, this module imports the top-level LocusZoom symbol

const STATUS_VERBS = ['highlight', 'select', 'fade', 'hide'];
const STATUS_ADJECTIVES = ['highlighted', 'selected', 'faded', 'hidden'];
const STATUS_ANTIVERBS = ['unhighlight', 'deselect', 'unfade', 'show'];


// LocusZoom plugins work by exporting a function that receives the `LocusZoom` object
// This allows them to work in many contexts (including script tags and ES6 imports)
function install(LocusZoom) {
    const _Button = LocusZoom.Widgets.get('_Button');
    const _BaseWidget = LocusZoom.Widgets.get('BaseWidget');


    /**
     * Special button/menu to allow model building by tracking individual covariants. Will track a list of covariate
     *   objects and store them in the special `model.covariates` field of plot `state`.
     * @param {object} layout
     * @param {string} layout.button_html The HTML to render inside the button
     * @param {string} layout.button_title Text to display as a tooltip when hovering over the button
     */
    class CovariatesModel extends _BaseWidget {
        initialize() {
            // Initialize state.model.covariates
            this.parent_plot.state.model = this.parent_plot.state.model || {};
            this.parent_plot.state.model.covariates = this.parent_plot.state.model.covariates || [];
            // Create an object at the plot level for easy access to interface methods in custom client-side JS
            /**
             * When a covariates model toolbar element is present, create (one) object at the plot level that exposes
             *   widget data and state for custom interactions with other plot elements.
             * @class CovariatesModel
             */
            this.parent_plot.CovariatesModel = {
                /** @member {Button} */
                button: this,
                /**
                 * Add an element to the model and show a representation of it in the toolbar widget menu. If the
                 *   element is already part of the model, do nothing (to avoid adding duplicates).
                 * When plot state is changed, this will automatically trigger requests for new data accordingly.
                 * @param {string|object} element_reference Can be any value that can be put through JSON.stringify()
                 *   to create a serialized representation of itself.
                 */
                add: (element_reference) => {
                    const plot = this.parent_plot;
                    const element = Object(_helpers_layouts__WEBPACK_IMPORTED_MODULE_0__["deepCopy"])(element_reference);
                    if (typeof element_reference == 'object' && typeof element.html != 'string') {
                        element.html = ( (typeof element_reference.toHTML == 'function') ? element_reference.toHTML() : element_reference.toString());
                    }
                    // Check if the element is already in the model covariates array and return if it is.
                    for (let i = 0; i < plot.state.model.covariates.length; i++) {
                        if (JSON.stringify(plot.state.model.covariates[i]) === JSON.stringify(element)) {
                            return plot;
                        }
                    }
                    plot.state.model.covariates.push(element);
                    plot.applyState();
                    plot.CovariatesModel.updateWidget();
                    return plot;
                },
                /**
                 * Remove an element from `state.model.covariates` (and from the toolbar widget menu's
                 *  representation of the state model). When plot state is changed, this will automatically trigger
                 *  requests for new data accordingly.
                 * @param {number} idx Array index of the element, in the `state.model.covariates array`.
                 */
                removeByIdx: (idx) => {
                    const plot = this.parent_plot;
                    if (typeof plot.state.model.covariates[idx] == 'undefined') {
                        throw new Error(`Unable to remove model covariate, invalid index: ${idx.toString()}`);
                    }
                    plot.state.model.covariates.splice(idx, 1);
                    plot.applyState();
                    plot.CovariatesModel.updateWidget();
                    return plot;
                },
                /**
                 * Empty the `state.model.covariates` array (and toolbar widget menu representation thereof) of all
                 *  elements. When plot state is changed, this will automatically trigger requests for new data accordingly
                 */
                removeAll: () => {
                    const plot = this.parent_plot;
                    plot.state.model.covariates = [];
                    plot.applyState();
                    plot.CovariatesModel.updateWidget();
                    return plot;
                },
                /**
                 * Manually trigger the update methods on the toolbar widget's button and menu elements to force
                 *   display of most up-to-date content. Can be used to force the toolbar to reflect changes made, eg if
                 *   modifying `state.model.covariates` directly instead of via `plot.CovariatesModel`
                 */
                updateWidget: () => {
                    this.button.update();
                    this.button.menu.update();
                },
            };
        }

        update() {

            if (this.button) {
                return this;
            }

            this.button = new _Button(this)
                .setColor(this.layout.color)
                .setHtml(this.layout.button_html)
                .setTitle(this.layout.button_title)
                .setOnclick(() => {
                    this.button.menu.populate();
                });

            this.button.menu.setPopulate(() => {
                const selector = this.button.menu.inner_selector;
                selector.html('');
                // General model HTML representation
                if (typeof this.parent_plot.state.model.html != 'undefined') {
                    selector.append('div').html(this.parent_plot.state.model.html);
                }
                // Model covariates table
                if (!this.parent_plot.state.model.covariates.length) {
                    selector.append('i').html('no covariates in model');
                } else {
                    selector.append('h5').html(`Model Covariates (${this.parent_plot.state.model.covariates.length})`);
                    const table = selector.append('table');
                    this.parent_plot.state.model.covariates.forEach((covariate, idx) => {
                        const html = ((typeof covariate == 'object' && typeof covariate.html == 'string') ? covariate.html : covariate.toString());
                        const row = table.append('tr');
                        row.append('td').append('button')
                            .attr('class', `lz-toolbar-button lz-toolbar-button-${this.layout.color}`)
                            .style('margin-left', '0em')
                            .on('click', () => this.parent_plot.CovariatesModel.removeByIdx(idx))
                            .html('×');
                        row.append('td')
                            .html(html);
                    });
                    selector.append('button')
                        .attr('class', `lz-toolbar-button lz-toolbar-button-${this.layout.color}`)
                        .style('margin-left', '4px')
                        .html('× Remove All Covariates')
                        .on('click', () => this.parent_plot.CovariatesModel.removeAll());
                }
            });

            this.button.preUpdate = () => {
                let html = 'Model';
                const count = this.parent_plot.state.model.covariates.length;
                if (count) {
                    const noun = count > 1 ? 'covariates' : 'covariate';
                    html += ` (${count} ${noun})`;
                }
                this.button.setHtml(html).disable(false);
            };

            this.button.show();

            return this;
        }
    }


    /**
     * Menu for manipulating multiple data layers in a single panel: show/hide, change order, etc.
     */
    class DataLayersWidget extends _BaseWidget {
        update() {

            if (typeof this.layout.button_html != 'string') {
                this.layout.button_html = 'Data Layers';
            }
            if (typeof this.layout.button_title != 'string') {
                this.layout.button_title = 'Manipulate Data Layers (sort, dim, show/hide, etc.)';
            }

            if (this.button) {
                return this;
            }

            this.button = new _Button(this)
                .setColor(this.layout.color)
                .setHtml(this.layout.button_html)
                .setTitle(this.layout.button_title)
                .setOnclick(() => {
                    this.button.menu.populate();
                });

            this.button.menu.setPopulate(() => {
                this.button.menu.inner_selector.html('');
                const table = this.button.menu.inner_selector.append('table');
                this.parent_panel.data_layer_ids_by_z_index.slice().reverse().forEach((id, idx) => {
                    const data_layer = this.parent_panel.data_layers[id];
                    const name = (typeof data_layer.layout.name != 'string') ? data_layer.id : data_layer.layout.name;
                    const row = table.append('tr');
                    // Layer name
                    row.append('td').html(name);
                    // Status toggle buttons
                    this.layout.statuses.forEach((status_adj) => {
                        const status_idx = STATUS_ADJECTIVES.indexOf(status_adj);
                        const status_verb = STATUS_VERBS[status_idx];
                        let html, onclick, highlight;
                        if (data_layer.global_statuses[status_adj]) {
                            html = STATUS_ANTIVERBS[status_idx];
                            onclick = `un${status_verb}AllElements`;
                            highlight = '-highlighted';
                        } else {
                            html = STATUS_VERBS[status_idx];
                            onclick = `${status_verb}AllElements`;
                            highlight = '';
                        }
                        row.append('td').append('a')
                            .attr('class', `lz-toolbar-button lz-toolbar-button-${this.layout.color}${highlight}`)
                            .style('margin-left', '0em')
                            .on('click', () => {
                                data_layer[onclick]();
                                this.button.menu.populate();
                            })
                            .html(html);
                    });
                    // Sort layer buttons
                    const at_top = (idx === 0);
                    const at_bottom = (idx === (this.parent_panel.data_layer_ids_by_z_index.length - 1));
                    const td = row.append('td');
                    td.append('a')
                        .attr('class', `lz-toolbar-button lz-toolbar-button-group-start lz-toolbar-button-${this.layout.color}${at_bottom ? '-disabled' : ''}`)
                        .style('margin-left', '0em')
                        .on('click', () => {
                            data_layer.moveBack(); this.button.menu.populate();
                        })
                        .html('▾')
                        .attr('title', 'Move layer down (further back)');
                    td.append('a')
                        .attr('class', `lz-toolbar-button lz-toolbar-button-group-middle lz-toolbar-button-${this.layout.color}${at_top ? '-disabled' : ''}`)
                        .style('margin-left', '0em')
                        .on('click', () => {
                            data_layer.moveForward(); this.button.menu.populate();
                        })
                        .html('▴')
                        .attr('title', 'Move layer up (further front)');
                    td.append('a')
                        .attr('class', 'lz-toolbar-button lz-toolbar-button-group-end lz-toolbar-button-red')
                        .style('margin-left', '0em')
                        .on('click', () => {
                            if (confirm(`Are you sure you want to remove the ${name} layer? This cannot be undone.`)) {
                                data_layer.parent.removeDataLayer(id);
                            }
                            return this.button.menu.populate();
                        })
                        .html('×')
                        .attr('title', 'Remove layer');
                });
                return this;
            });

            this.button.show();

            return this;
        }
    }

    const covariates_model_tooltip = function () {
        const covariates_model_association = LocusZoom.Layouts.get('tooltip', 'standard_association', { unnamespaced: true });
        covariates_model_association.html += '<a href="javascript:void(0);" onclick="LocusZoom.getToolTipPlot(this).CovariatesModel.add(LocusZoom.getToolTipData(this));">Condition on Variant</a><br>';
        return covariates_model_association;
    }();

    const covariates_model_plot = function () {
        const covariates_model_plot_toolbar = LocusZoom.Layouts.get('toolbar', 'standard_association', { unnamespaced: true });
        covariates_model_plot_toolbar.widgets.push({
            type: 'covariates_model',
            button_html: 'Model',
            button_title: 'Show and edit covariates currently in model',
            position: 'left',
        });
        return covariates_model_plot_toolbar;
    }();

    LocusZoom.Widgets.add('covariates_model', CovariatesModel);
    LocusZoom.Widgets.add('data_layers', DataLayersWidget);

    LocusZoom.Layouts.add('tooltip', 'covariates_model_association', covariates_model_tooltip);
    LocusZoom.Layouts.add('toolbar', 'covariates_model_plot', covariates_model_plot);
}

if (typeof LocusZoom !== 'undefined') {
    // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()
    // eslint-disable-next-line no-undef
    LocusZoom.use(install);
}


/* harmony default export */ __webpack_exports__["default"] = (install);


/***/ }),

/***/ "./esm/helpers/layouts.js":
/*!********************************!*\
  !*** ./esm/helpers/layouts.js ***!
  \********************************/
/*! exports provided: applyNamespaces, deepCopy, merge, nameToSymbol */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyNamespaces", function() { return applyNamespaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepCopy", function() { return deepCopy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return merge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nameToSymbol", function() { return nameToSymbol; });
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Utilities for modifying or working with layout objects
 *  @module
 */


const sqrt3 = Math.sqrt(3);
// D3 v5 does not provide a triangle down symbol shape, but it is very useful for showing direction of effect.
//  Modified from https://github.com/d3/d3-shape/blob/master/src/symbol/triangle.js
const triangledown = {
    draw(context, size) {
        const y = -Math.sqrt(size / (sqrt3 * 3));
        context.moveTo(0, -y * 2);
        context.lineTo(-sqrt3 * y, y);
        context.lineTo(sqrt3 * y, y);
        context.closePath();
    },
};

/**
 * Apply namespaces to layout, recursively
 * @private
  */
function applyNamespaces(element, namespace, default_namespace) {
    if (namespace) {
        if (typeof namespace == 'string') {
            namespace = { default: namespace };
        }
    } else {
        namespace = { default: '' };
    }
    if (typeof element == 'string') {
        const re = /\{\{namespace(\[[A-Za-z_0-9]+\]|)\}\}/g;
        let match, base, key, resolved_namespace;
        const replace = [];
        while ((match = re.exec(element)) !== null) {
            base = match[0];
            key = match[1].length ? match[1].replace(/(\[|\])/g, '') : null;
            resolved_namespace = default_namespace;
            if (namespace != null && typeof namespace == 'object' && typeof namespace[key] != 'undefined') {
                resolved_namespace = namespace[key] + (namespace[key].length ? ':' : '');
            }
            replace.push({ base: base, namespace: resolved_namespace });
        }
        for (let r in replace) {
            element = element.replace(replace[r].base, replace[r].namespace);
        }
    } else if (typeof element == 'object' && element != null) {
        if (typeof element.namespace != 'undefined') {
            const merge_namespace = (typeof element.namespace == 'string') ? { default: element.namespace } : element.namespace;
            namespace = merge(namespace, merge_namespace);
        }
        let namespaced_element, namespaced_property;
        for (let property in element) {
            if (property === 'namespace') {
                continue;
            }
            namespaced_element = applyNamespaces(element[property], namespace, default_namespace);
            namespaced_property = applyNamespaces(property, namespace, default_namespace);
            if (property !== namespaced_property) {
                delete element[property];
            }
            element[namespaced_property] = namespaced_element;
        }
    }
    return element;
}

/**
 * A helper method used for merging two objects. If a key is present in both, takes the value from the first object
 *   Values from `default_layout` will be cleanly copied over, ensuring no references or shared state.
 *
 * Frequently used for preparing custom layouts. Both objects should be JSON-serializable.
 *
 * @param {object} custom_layout An object containing configuration parameters that override or add to defaults
 * @param {object} default_layout An object containing default settings.
 * @returns {object} The custom layout is modified in place and also returned from this method.
 */
function merge(custom_layout, default_layout) {
    if (typeof custom_layout !== 'object' || typeof default_layout !== 'object') {
        throw new Error(`LocusZoom.Layouts.merge only accepts two layout objects; ${typeof custom_layout}, ${typeof default_layout} given`);
    }
    for (let property in default_layout) {
        if (!Object.prototype.hasOwnProperty.call(default_layout, property)) {
            continue;
        }
        // Get types for comparison. Treat nulls in the custom layout as undefined for simplicity.
        // (javascript treats nulls as "object" when we just want to overwrite them as if they're undefined)
        // Also separate arrays from objects as a discrete type.
        let custom_type = custom_layout[property] === null ? 'undefined' : typeof custom_layout[property];
        let default_type = typeof default_layout[property];
        if (custom_type === 'object' && Array.isArray(custom_layout[property])) {
            custom_type = 'array';
        }
        if (default_type === 'object' && Array.isArray(default_layout[property])) {
            default_type = 'array';
        }
        // Unsupported property types: throw an exception
        if (custom_type === 'function' || default_type === 'function') {
            throw new Error('LocusZoom.Layouts.merge encountered an unsupported property type');
        }
        // Undefined custom value: pull the default value
        if (custom_type === 'undefined') {
            custom_layout[property] = deepCopy(default_layout[property]);
            continue;
        }
        // Both values are objects: merge recursively
        if (custom_type === 'object' && default_type === 'object') {
            custom_layout[property] = merge(custom_layout[property], default_layout[property]);
            continue;
        }
    }
    return custom_layout;
}

function deepCopy(item) {
    return JSON.parse(JSON.stringify(item));
}

/**
 * Convert name to symbol
 * Layout objects accept symbol names as strings (circle, triangle, etc). Convert to symbol objects.
 * @return {object|null} An object that implements a draw method (eg d3-shape symbols or extra LZ items)
 */
function nameToSymbol(shape) {
    if (!shape) {
        return null;
    }
    if (shape === 'triangledown') {
        // D3 does not provide this symbol natively
        return triangledown;
    }
    // Legend shape names are strings; need to connect this to factory. Eg circle --> d3.symbolCircle
    const factory_name = `symbol${shape.charAt(0).toUpperCase() + shape.slice(1)}`;
    return d3__WEBPACK_IMPORTED_MODULE_0__[factory_name] || null;
}




/***/ }),

/***/ "d3":
/*!*********************!*\
  !*** external "d3" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = d3;

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2V4dC9sei13aWRnZXQtYWRkb25zLmpzIiwid2VicGFjazovL1tuYW1lXS8uL2VzbS9oZWxwZXJzL2xheW91dHMuanMiLCJ3ZWJwYWNrOi8vW25hbWVdL2V4dGVybmFsIFwiZDNcIiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEM7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFD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LWFkZG9ucy5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2VzbS9leHQvbHotd2lkZ2V0LWFkZG9ucy5qc1wiKTtcbiIsIi8qKlxuICogT3B0aW9uYWwgTG9jdXNab29tIGV4dGVuc2lvbjogbXVzdCBiZSBpbmNsdWRlZCBzZXBhcmF0ZWx5LCBhbmQgYWZ0ZXIgTG9jdXNab29tIGhhcyBiZWVuIGxvYWRlZFxuICpcbiAqIFRoaXMgY29udGFpbnMgKHJldXNhYmxlKSBjb2RlIHRvIHBvd2VyIHNvbWUgKHJhcmVseSB1c2VkKSBkZW1vIGZlYXR1cmVzOlxuICogIC0gVGhlIFwiY292YXJpYXRlcyBtb2RlbFwiIGRlbW8sIGluIHdoaWNoIGFuIExaIHRvb2xiYXIgd2lkZ2V0IGlzIHBvcHVsYXRlZFxuICogICAgd2l0aCBpbmZvcm1hdGlvbiBieSBzZWxlY3RpbmcgcG9pbnRzIG9uIHRoZSBwbG90IChzZWUgXCJjb3ZhcmlhdGVzIG1vZGVsXCIgZGVtbylcbiAqICAtIFRoZSBcImRhdGEgbGF5ZXJzXCIgYnV0dG9uLCB3aGljaCBhbGxvd3MgZmluZSBjb250cm9sIG92ZXIgbXVsdGlwbGUgZGF0YSBsYXllcnMgc2hvd24gaW4gdGhlIHNhbWUgcGFuZWxcbiAqICAgIChzaG93L2hpZGUsIGZhZGUsIGNoYW5nZSBvcmRlciwgZXRjKS4gVGhpcyBpcyBwb3dlcmZ1bCwgYnV0IHJhcmVseSB1c2VkIGJlY2F1c2Ugc2hvd2luZyBtYW55IGRhdGFzZXRzIGluIGEgc21hbGxcbiAqICAgIHNwYWNlIGlzIGhhcmQgdG8gcmVhZC4gKHNlZSBcIm11bHRpcGxlIHBoZW5vdHlwZXMgbGF5ZXJlZFwiIGRlbW8pXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7ZGVlcENvcHl9IGZyb20gJy4uL2hlbHBlcnMvbGF5b3V0cyc7XG5cbi8vIEluIG9yZGVyIHRvIHdvcmsgaW4gYSBVTUQgY29udGV4dCwgdGhpcyBtb2R1bGUgaW1wb3J0cyB0aGUgdG9wLWxldmVsIExvY3VzWm9vbSBzeW1ib2xcblxuY29uc3QgU1RBVFVTX1ZFUkJTID0gWydoaWdobGlnaHQnLCAnc2VsZWN0JywgJ2ZhZGUnLCAnaGlkZSddO1xuY29uc3QgU1RBVFVTX0FESkVDVElWRVMgPSBbJ2hpZ2hsaWdodGVkJywgJ3NlbGVjdGVkJywgJ2ZhZGVkJywgJ2hpZGRlbiddO1xuY29uc3QgU1RBVFVTX0FOVElWRVJCUyA9IFsndW5oaWdobGlnaHQnLCAnZGVzZWxlY3QnLCAndW5mYWRlJywgJ3Nob3cnXTtcblxuXG4vLyBMb2N1c1pvb20gcGx1Z2lucyB3b3JrIGJ5IGV4cG9ydGluZyBhIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGBMb2N1c1pvb21gIG9iamVjdFxuLy8gVGhpcyBhbGxvd3MgdGhlbSB0byB3b3JrIGluIG1hbnkgY29udGV4dHMgKGluY2x1ZGluZyBzY3JpcHQgdGFncyBhbmQgRVM2IGltcG9ydHMpXG5mdW5jdGlvbiBpbnN0YWxsKExvY3VzWm9vbSkge1xuICAgIGNvbnN0IF9CdXR0b24gPSBMb2N1c1pvb20uV2lkZ2V0cy5nZXQoJ19CdXR0b24nKTtcbiAgICBjb25zdCBfQmFzZVdpZGdldCA9IExvY3VzWm9vbS5XaWRnZXRzLmdldCgnQmFzZVdpZGdldCcpO1xuXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWFsIGJ1dHRvbi9tZW51IHRvIGFsbG93IG1vZGVsIGJ1aWxkaW5nIGJ5IHRyYWNraW5nIGluZGl2aWR1YWwgY292YXJpYW50cy4gV2lsbCB0cmFjayBhIGxpc3Qgb2YgY292YXJpYXRlXG4gICAgICogICBvYmplY3RzIGFuZCBzdG9yZSB0aGVtIGluIHRoZSBzcGVjaWFsIGBtb2RlbC5jb3ZhcmlhdGVzYCBmaWVsZCBvZiBwbG90IGBzdGF0ZWAuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGxheW91dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsYXlvdXQuYnV0dG9uX2h0bWwgVGhlIEhUTUwgdG8gcmVuZGVyIGluc2lkZSB0aGUgYnV0dG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxheW91dC5idXR0b25fdGl0bGUgVGV4dCB0byBkaXNwbGF5IGFzIGEgdG9vbHRpcCB3aGVuIGhvdmVyaW5nIG92ZXIgdGhlIGJ1dHRvblxuICAgICAqL1xuICAgIGNsYXNzIENvdmFyaWF0ZXNNb2RlbCBleHRlbmRzIF9CYXNlV2lkZ2V0IHtcbiAgICAgICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgc3RhdGUubW9kZWwuY292YXJpYXRlc1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGxvdC5zdGF0ZS5tb2RlbCA9IHRoaXMucGFyZW50X3Bsb3Quc3RhdGUubW9kZWwgfHwge307XG4gICAgICAgICAgICB0aGlzLnBhcmVudF9wbG90LnN0YXRlLm1vZGVsLmNvdmFyaWF0ZXMgPSB0aGlzLnBhcmVudF9wbG90LnN0YXRlLm1vZGVsLmNvdmFyaWF0ZXMgfHwgW107XG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gb2JqZWN0IGF0IHRoZSBwbG90IGxldmVsIGZvciBlYXN5IGFjY2VzcyB0byBpbnRlcmZhY2UgbWV0aG9kcyBpbiBjdXN0b20gY2xpZW50LXNpZGUgSlNcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiBhIGNvdmFyaWF0ZXMgbW9kZWwgdG9vbGJhciBlbGVtZW50IGlzIHByZXNlbnQsIGNyZWF0ZSAob25lKSBvYmplY3QgYXQgdGhlIHBsb3QgbGV2ZWwgdGhhdCBleHBvc2VzXG4gICAgICAgICAgICAgKiAgIHdpZGdldCBkYXRhIGFuZCBzdGF0ZSBmb3IgY3VzdG9tIGludGVyYWN0aW9ucyB3aXRoIG90aGVyIHBsb3QgZWxlbWVudHMuXG4gICAgICAgICAgICAgKiBAY2xhc3MgQ292YXJpYXRlc01vZGVsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMucGFyZW50X3Bsb3QuQ292YXJpYXRlc01vZGVsID0ge1xuICAgICAgICAgICAgICAgIC8qKiBAbWVtYmVyIHtCdXR0b259ICovXG4gICAgICAgICAgICAgICAgYnV0dG9uOiB0aGlzLFxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFkZCBhbiBlbGVtZW50IHRvIHRoZSBtb2RlbCBhbmQgc2hvdyBhIHJlcHJlc2VudGF0aW9uIG9mIGl0IGluIHRoZSB0b29sYmFyIHdpZGdldCBtZW51LiBJZiB0aGVcbiAgICAgICAgICAgICAgICAgKiAgIGVsZW1lbnQgaXMgYWxyZWFkeSBwYXJ0IG9mIHRoZSBtb2RlbCwgZG8gbm90aGluZyAodG8gYXZvaWQgYWRkaW5nIGR1cGxpY2F0ZXMpLlxuICAgICAgICAgICAgICAgICAqIFdoZW4gcGxvdCBzdGF0ZSBpcyBjaGFuZ2VkLCB0aGlzIHdpbGwgYXV0b21hdGljYWxseSB0cmlnZ2VyIHJlcXVlc3RzIGZvciBuZXcgZGF0YSBhY2NvcmRpbmdseS5cbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGVsZW1lbnRfcmVmZXJlbmNlIENhbiBiZSBhbnkgdmFsdWUgdGhhdCBjYW4gYmUgcHV0IHRocm91Z2ggSlNPTi5zdHJpbmdpZnkoKVxuICAgICAgICAgICAgICAgICAqICAgdG8gY3JlYXRlIGEgc2VyaWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiBpdHNlbGYuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYWRkOiAoZWxlbWVudF9yZWZlcmVuY2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGxvdCA9IHRoaXMucGFyZW50X3Bsb3Q7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkZWVwQ29weShlbGVtZW50X3JlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudF9yZWZlcmVuY2UgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGVsZW1lbnQuaHRtbCAhPSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5odG1sID0gKCAodHlwZW9mIGVsZW1lbnRfcmVmZXJlbmNlLnRvSFRNTCA9PSAnZnVuY3Rpb24nKSA/IGVsZW1lbnRfcmVmZXJlbmNlLnRvSFRNTCgpIDogZWxlbWVudF9yZWZlcmVuY2UudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBpbiB0aGUgbW9kZWwgY292YXJpYXRlcyBhcnJheSBhbmQgcmV0dXJuIGlmIGl0IGlzLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsb3Quc3RhdGUubW9kZWwuY292YXJpYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEpTT04uc3RyaW5naWZ5KHBsb3Quc3RhdGUubW9kZWwuY292YXJpYXRlc1tpXSkgPT09IEpTT04uc3RyaW5naWZ5KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsb3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGxvdC5zdGF0ZS5tb2RlbC5jb3ZhcmlhdGVzLnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHBsb3QuYXBwbHlTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBwbG90LkNvdmFyaWF0ZXNNb2RlbC51cGRhdGVXaWRnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsb3Q7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZW1vdmUgYW4gZWxlbWVudCBmcm9tIGBzdGF0ZS5tb2RlbC5jb3ZhcmlhdGVzYCAoYW5kIGZyb20gdGhlIHRvb2xiYXIgd2lkZ2V0IG1lbnUnc1xuICAgICAgICAgICAgICAgICAqICByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3RhdGUgbW9kZWwpLiBXaGVuIHBsb3Qgc3RhdGUgaXMgY2hhbmdlZCwgdGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAqICByZXF1ZXN0cyBmb3IgbmV3IGRhdGEgYWNjb3JkaW5nbHkuXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeCBBcnJheSBpbmRleCBvZiB0aGUgZWxlbWVudCwgaW4gdGhlIGBzdGF0ZS5tb2RlbC5jb3ZhcmlhdGVzIGFycmF5YC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZW1vdmVCeUlkeDogKGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbG90ID0gdGhpcy5wYXJlbnRfcGxvdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwbG90LnN0YXRlLm1vZGVsLmNvdmFyaWF0ZXNbaWR4XSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gcmVtb3ZlIG1vZGVsIGNvdmFyaWF0ZSwgaW52YWxpZCBpbmRleDogJHtpZHgudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwbG90LnN0YXRlLm1vZGVsLmNvdmFyaWF0ZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBsb3QuYXBwbHlTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBwbG90LkNvdmFyaWF0ZXNNb2RlbC51cGRhdGVXaWRnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsb3Q7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFbXB0eSB0aGUgYHN0YXRlLm1vZGVsLmNvdmFyaWF0ZXNgIGFycmF5IChhbmQgdG9vbGJhciB3aWRnZXQgbWVudSByZXByZXNlbnRhdGlvbiB0aGVyZW9mKSBvZiBhbGxcbiAgICAgICAgICAgICAgICAgKiAgZWxlbWVudHMuIFdoZW4gcGxvdCBzdGF0ZSBpcyBjaGFuZ2VkLCB0aGlzIHdpbGwgYXV0b21hdGljYWxseSB0cmlnZ2VyIHJlcXVlc3RzIGZvciBuZXcgZGF0YSBhY2NvcmRpbmdseVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJlbW92ZUFsbDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwbG90ID0gdGhpcy5wYXJlbnRfcGxvdDtcbiAgICAgICAgICAgICAgICAgICAgcGxvdC5zdGF0ZS5tb2RlbC5jb3ZhcmlhdGVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHBsb3QuYXBwbHlTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBwbG90LkNvdmFyaWF0ZXNNb2RlbC51cGRhdGVXaWRnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsb3Q7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBNYW51YWxseSB0cmlnZ2VyIHRoZSB1cGRhdGUgbWV0aG9kcyBvbiB0aGUgdG9vbGJhciB3aWRnZXQncyBidXR0b24gYW5kIG1lbnUgZWxlbWVudHMgdG8gZm9yY2VcbiAgICAgICAgICAgICAgICAgKiAgIGRpc3BsYXkgb2YgbW9zdCB1cC10by1kYXRlIGNvbnRlbnQuIENhbiBiZSB1c2VkIHRvIGZvcmNlIHRoZSB0b29sYmFyIHRvIHJlZmxlY3QgY2hhbmdlcyBtYWRlLCBlZyBpZlxuICAgICAgICAgICAgICAgICAqICAgbW9kaWZ5aW5nIGBzdGF0ZS5tb2RlbC5jb3ZhcmlhdGVzYCBkaXJlY3RseSBpbnN0ZWFkIG9mIHZpYSBgcGxvdC5Db3ZhcmlhdGVzTW9kZWxgXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdXBkYXRlV2lkZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5tZW51LnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5idXR0b24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5idXR0b24gPSBuZXcgX0J1dHRvbih0aGlzKVxuICAgICAgICAgICAgICAgIC5zZXRDb2xvcih0aGlzLmxheW91dC5jb2xvcilcbiAgICAgICAgICAgICAgICAuc2V0SHRtbCh0aGlzLmxheW91dC5idXR0b25faHRtbClcbiAgICAgICAgICAgICAgICAuc2V0VGl0bGUodGhpcy5sYXlvdXQuYnV0dG9uX3RpdGxlKVxuICAgICAgICAgICAgICAgIC5zZXRPbmNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b24ubWVudS5wb3B1bGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5tZW51LnNldFBvcHVsYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuYnV0dG9uLm1lbnUuaW5uZXJfc2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IuaHRtbCgnJyk7XG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhbCBtb2RlbCBIVE1MIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnBhcmVudF9wbG90LnN0YXRlLm1vZGVsLmh0bWwgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IuYXBwZW5kKCdkaXYnKS5odG1sKHRoaXMucGFyZW50X3Bsb3Quc3RhdGUubW9kZWwuaHRtbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE1vZGVsIGNvdmFyaWF0ZXMgdGFibGVcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50X3Bsb3Quc3RhdGUubW9kZWwuY292YXJpYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IuYXBwZW5kKCdpJykuaHRtbCgnbm8gY292YXJpYXRlcyBpbiBtb2RlbCcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yLmFwcGVuZCgnaDUnKS5odG1sKGBNb2RlbCBDb3ZhcmlhdGVzICgke3RoaXMucGFyZW50X3Bsb3Quc3RhdGUubW9kZWwuY292YXJpYXRlcy5sZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IHNlbGVjdG9yLmFwcGVuZCgndGFibGUnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRfcGxvdC5zdGF0ZS5tb2RlbC5jb3ZhcmlhdGVzLmZvckVhY2goKGNvdmFyaWF0ZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBodG1sID0gKCh0eXBlb2YgY292YXJpYXRlID09ICdvYmplY3QnICYmIHR5cGVvZiBjb3ZhcmlhdGUuaHRtbCA9PSAnc3RyaW5nJykgPyBjb3ZhcmlhdGUuaHRtbCA6IGNvdmFyaWF0ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IHRhYmxlLmFwcGVuZCgndHInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmQoJ3RkJykuYXBwZW5kKCdidXR0b24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBsei10b29sYmFyLWJ1dHRvbiBsei10b29sYmFyLWJ1dHRvbi0ke3RoaXMubGF5b3V0LmNvbG9yfWApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4tbGVmdCcsICcwZW0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB0aGlzLnBhcmVudF9wbG90LkNvdmFyaWF0ZXNNb2RlbC5yZW1vdmVCeUlkeChpZHgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKCfDlycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZCgndGQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKGh0bWwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IuYXBwZW5kKCdidXR0b24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgYGx6LXRvb2xiYXItYnV0dG9uIGx6LXRvb2xiYXItYnV0dG9uLSR7dGhpcy5sYXlvdXQuY29sb3J9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luLWxlZnQnLCAnNHB4JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKCfDlyBSZW1vdmUgQWxsIENvdmFyaWF0ZXMnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHRoaXMucGFyZW50X3Bsb3QuQ292YXJpYXRlc01vZGVsLnJlbW92ZUFsbCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5idXR0b24ucHJlVXBkYXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBodG1sID0gJ01vZGVsJztcbiAgICAgICAgICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMucGFyZW50X3Bsb3Quc3RhdGUubW9kZWwuY292YXJpYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdW4gPSBjb3VudCA+IDEgPyAnY292YXJpYXRlcycgOiAnY292YXJpYXRlJztcbiAgICAgICAgICAgICAgICAgICAgaHRtbCArPSBgICgke2NvdW50fSAke25vdW59KWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLnNldEh0bWwoaHRtbCkuZGlzYWJsZShmYWxzZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5zaG93KCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBNZW51IGZvciBtYW5pcHVsYXRpbmcgbXVsdGlwbGUgZGF0YSBsYXllcnMgaW4gYSBzaW5nbGUgcGFuZWw6IHNob3cvaGlkZSwgY2hhbmdlIG9yZGVyLCBldGMuXG4gICAgICovXG4gICAgY2xhc3MgRGF0YUxheWVyc1dpZGdldCBleHRlbmRzIF9CYXNlV2lkZ2V0IHtcbiAgICAgICAgdXBkYXRlKCkge1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMubGF5b3V0LmJ1dHRvbl9odG1sICE9ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuYnV0dG9uX2h0bWwgPSAnRGF0YSBMYXllcnMnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxheW91dC5idXR0b25fdGl0bGUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dC5idXR0b25fdGl0bGUgPSAnTWFuaXB1bGF0ZSBEYXRhIExheWVycyAoc29ydCwgZGltLCBzaG93L2hpZGUsIGV0Yy4pJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYnV0dG9uID0gbmV3IF9CdXR0b24odGhpcylcbiAgICAgICAgICAgICAgICAuc2V0Q29sb3IodGhpcy5sYXlvdXQuY29sb3IpXG4gICAgICAgICAgICAgICAgLnNldEh0bWwodGhpcy5sYXlvdXQuYnV0dG9uX2h0bWwpXG4gICAgICAgICAgICAgICAgLnNldFRpdGxlKHRoaXMubGF5b3V0LmJ1dHRvbl90aXRsZSlcbiAgICAgICAgICAgICAgICAuc2V0T25jbGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLm1lbnUucG9wdWxhdGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5idXR0b24ubWVudS5zZXRQb3B1bGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24ubWVudS5pbm5lcl9zZWxlY3Rvci5odG1sKCcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWJsZSA9IHRoaXMuYnV0dG9uLm1lbnUuaW5uZXJfc2VsZWN0b3IuYXBwZW5kKCd0YWJsZScpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50X3BhbmVsLmRhdGFfbGF5ZXJfaWRzX2J5X3pfaW5kZXguc2xpY2UoKS5yZXZlcnNlKCkuZm9yRWFjaCgoaWQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhX2xheWVyID0gdGhpcy5wYXJlbnRfcGFuZWwuZGF0YV9sYXllcnNbaWRdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gKHR5cGVvZiBkYXRhX2xheWVyLmxheW91dC5uYW1lICE9ICdzdHJpbmcnKSA/IGRhdGFfbGF5ZXIuaWQgOiBkYXRhX2xheWVyLmxheW91dC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByb3cgPSB0YWJsZS5hcHBlbmQoJ3RyJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIExheWVyIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZCgndGQnKS5odG1sKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGF0dXMgdG9nZ2xlIGJ1dHRvbnNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQuc3RhdHVzZXMuZm9yRWFjaCgoc3RhdHVzX2FkaikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzX2lkeCA9IFNUQVRVU19BREpFQ1RJVkVTLmluZGV4T2Yoc3RhdHVzX2Fkaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNfdmVyYiA9IFNUQVRVU19WRVJCU1tzdGF0dXNfaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBodG1sLCBvbmNsaWNrLCBoaWdobGlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YV9sYXllci5nbG9iYWxfc3RhdHVzZXNbc3RhdHVzX2Fkal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBodG1sID0gU1RBVFVTX0FOVElWRVJCU1tzdGF0dXNfaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmNsaWNrID0gYHVuJHtzdGF0dXNfdmVyYn1BbGxFbGVtZW50c2A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0ID0gJy1oaWdobGlnaHRlZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh0bWwgPSBTVEFUVVNfVkVSQlNbc3RhdHVzX2lkeF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljayA9IGAke3N0YXR1c192ZXJifUFsbEVsZW1lbnRzYDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWdobGlnaHQgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmQoJ3RkJykuYXBwZW5kKCdhJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY2xhc3MnLCBgbHotdG9vbGJhci1idXR0b24gbHotdG9vbGJhci1idXR0b24tJHt0aGlzLmxheW91dC5jb2xvcn0ke2hpZ2hsaWdodH1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luLWxlZnQnLCAnMGVtJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAub24oJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhX2xheWVyW29uY2xpY2tdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLm1lbnUucG9wdWxhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKGh0bWwpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU29ydCBsYXllciBidXR0b25zXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0X3RvcCA9IChpZHggPT09IDApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdF9ib3R0b20gPSAoaWR4ID09PSAodGhpcy5wYXJlbnRfcGFuZWwuZGF0YV9sYXllcl9pZHNfYnlfel9pbmRleC5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRkID0gcm93LmFwcGVuZCgndGQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGQuYXBwZW5kKCdhJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBsei10b29sYmFyLWJ1dHRvbiBsei10b29sYmFyLWJ1dHRvbi1ncm91cC1zdGFydCBsei10b29sYmFyLWJ1dHRvbi0ke3RoaXMubGF5b3V0LmNvbG9yfSR7YXRfYm90dG9tID8gJy1kaXNhYmxlZCcgOiAnJ31gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKCdtYXJnaW4tbGVmdCcsICcwZW0nKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhX2xheWVyLm1vdmVCYWNrKCk7IHRoaXMuYnV0dG9uLm1lbnUucG9wdWxhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuaHRtbCgn4pa+JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0aXRsZScsICdNb3ZlIGxheWVyIGRvd24gKGZ1cnRoZXIgYmFjayknKTtcbiAgICAgICAgICAgICAgICAgICAgdGQuYXBwZW5kKCdhJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsIGBsei10b29sYmFyLWJ1dHRvbiBsei10b29sYmFyLWJ1dHRvbi1ncm91cC1taWRkbGUgbHotdG9vbGJhci1idXR0b24tJHt0aGlzLmxheW91dC5jb2xvcn0ke2F0X3RvcCA/ICctZGlzYWJsZWQnIDogJyd9YClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luLWxlZnQnLCAnMGVtJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YV9sYXllci5tb3ZlRm9yd2FyZCgpOyB0aGlzLmJ1dHRvbi5tZW51LnBvcHVsYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmh0bWwoJ+KWtCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGl0bGUnLCAnTW92ZSBsYXllciB1cCAoZnVydGhlciBmcm9udCknKTtcbiAgICAgICAgICAgICAgICAgICAgdGQuYXBwZW5kKCdhJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei10b29sYmFyLWJ1dHRvbiBsei10b29sYmFyLWJ1dHRvbi1ncm91cC1lbmQgbHotdG9vbGJhci1idXR0b24tcmVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZSgnbWFyZ2luLWxlZnQnLCAnMGVtJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm0oYEFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byByZW1vdmUgdGhlICR7bmFtZX0gbGF5ZXI/IFRoaXMgY2Fubm90IGJlIHVuZG9uZS5gKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhX2xheWVyLnBhcmVudC5yZW1vdmVEYXRhTGF5ZXIoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5idXR0b24ubWVudS5wb3B1bGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKCfDlycpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXR0cigndGl0bGUnLCAnUmVtb3ZlIGxheWVyJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5idXR0b24uc2hvdygpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGNvdmFyaWF0ZXNfbW9kZWxfdG9vbHRpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgY292YXJpYXRlc19tb2RlbF9hc3NvY2lhdGlvbiA9IExvY3VzWm9vbS5MYXlvdXRzLmdldCgndG9vbHRpcCcsICdzdGFuZGFyZF9hc3NvY2lhdGlvbicsIHsgdW5uYW1lc3BhY2VkOiB0cnVlIH0pO1xuICAgICAgICBjb3ZhcmlhdGVzX21vZGVsX2Fzc29jaWF0aW9uLmh0bWwgKz0gJzxhIGhyZWY9XCJqYXZhc2NyaXB0OnZvaWQoMCk7XCIgb25jbGljaz1cIkxvY3VzWm9vbS5nZXRUb29sVGlwUGxvdCh0aGlzKS5Db3ZhcmlhdGVzTW9kZWwuYWRkKExvY3VzWm9vbS5nZXRUb29sVGlwRGF0YSh0aGlzKSk7XCI+Q29uZGl0aW9uIG9uIFZhcmlhbnQ8L2E+PGJyPic7XG4gICAgICAgIHJldHVybiBjb3ZhcmlhdGVzX21vZGVsX2Fzc29jaWF0aW9uO1xuICAgIH0oKTtcblxuICAgIGNvbnN0IGNvdmFyaWF0ZXNfbW9kZWxfcGxvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgY292YXJpYXRlc19tb2RlbF9wbG90X3Rvb2xiYXIgPSBMb2N1c1pvb20uTGF5b3V0cy5nZXQoJ3Rvb2xiYXInLCAnc3RhbmRhcmRfYXNzb2NpYXRpb24nLCB7IHVubmFtZXNwYWNlZDogdHJ1ZSB9KTtcbiAgICAgICAgY292YXJpYXRlc19tb2RlbF9wbG90X3Rvb2xiYXIud2lkZ2V0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdjb3ZhcmlhdGVzX21vZGVsJyxcbiAgICAgICAgICAgIGJ1dHRvbl9odG1sOiAnTW9kZWwnLFxuICAgICAgICAgICAgYnV0dG9uX3RpdGxlOiAnU2hvdyBhbmQgZWRpdCBjb3ZhcmlhdGVzIGN1cnJlbnRseSBpbiBtb2RlbCcsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2xlZnQnLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvdmFyaWF0ZXNfbW9kZWxfcGxvdF90b29sYmFyO1xuICAgIH0oKTtcblxuICAgIExvY3VzWm9vbS5XaWRnZXRzLmFkZCgnY292YXJpYXRlc19tb2RlbCcsIENvdmFyaWF0ZXNNb2RlbCk7XG4gICAgTG9jdXNab29tLldpZGdldHMuYWRkKCdkYXRhX2xheWVycycsIERhdGFMYXllcnNXaWRnZXQpO1xuXG4gICAgTG9jdXNab29tLkxheW91dHMuYWRkKCd0b29sdGlwJywgJ2NvdmFyaWF0ZXNfbW9kZWxfYXNzb2NpYXRpb24nLCBjb3ZhcmlhdGVzX21vZGVsX3Rvb2x0aXApO1xuICAgIExvY3VzWm9vbS5MYXlvdXRzLmFkZCgndG9vbGJhcicsICdjb3ZhcmlhdGVzX21vZGVsX3Bsb3QnLCBjb3ZhcmlhdGVzX21vZGVsX3Bsb3QpO1xufVxuXG5pZiAodHlwZW9mIExvY3VzWm9vbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBBdXRvLXJlZ2lzdGVyIHRoZSBwbHVnaW4gd2hlbiBpbmNsdWRlZCBhcyBhIHNjcmlwdCB0YWcuIEVTNiBtb2R1bGUgdXNlcnMgbXVzdCByZWdpc3RlciB2aWEgTG9jdXNab29tLnVzZSgpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgTG9jdXNab29tLnVzZShpbnN0YWxsKTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBpbnN0YWxsO1xuIiwiLyoqXG4gKiBVdGlsaXRpZXMgZm9yIG1vZGlmeWluZyBvciB3b3JraW5nIHdpdGggbGF5b3V0IG9iamVjdHNcbiAqICBAbW9kdWxlXG4gKi9cbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcblxuY29uc3Qgc3FydDMgPSBNYXRoLnNxcnQoMyk7XG4vLyBEMyB2NSBkb2VzIG5vdCBwcm92aWRlIGEgdHJpYW5nbGUgZG93biBzeW1ib2wgc2hhcGUsIGJ1dCBpdCBpcyB2ZXJ5IHVzZWZ1bCBmb3Igc2hvd2luZyBkaXJlY3Rpb24gb2YgZWZmZWN0LlxuLy8gIE1vZGlmaWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNoYXBlL2Jsb2IvbWFzdGVyL3NyYy9zeW1ib2wvdHJpYW5nbGUuanNcbmNvbnN0IHRyaWFuZ2xlZG93biA9IHtcbiAgICBkcmF3KGNvbnRleHQsIHNpemUpIHtcbiAgICAgICAgY29uc3QgeSA9IC1NYXRoLnNxcnQoc2l6ZSAvIChzcXJ0MyAqIDMpKTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgLXkgKiAyKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oLXNxcnQzICogeSwgeSk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHNxcnQzICogeSwgeSk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfSxcbn07XG5cbi8qKlxuICogQXBwbHkgbmFtZXNwYWNlcyB0byBsYXlvdXQsIHJlY3Vyc2l2ZWx5XG4gKiBAcHJpdmF0ZVxuICAqL1xuZnVuY3Rpb24gYXBwbHlOYW1lc3BhY2VzKGVsZW1lbnQsIG5hbWVzcGFjZSwgZGVmYXVsdF9uYW1lc3BhY2UpIHtcbiAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSB7IGRlZmF1bHQ6IG5hbWVzcGFjZSB9O1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZXNwYWNlID0geyBkZWZhdWx0OiAnJyB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgcmUgPSAvXFx7XFx7bmFtZXNwYWNlKFxcW1tBLVphLXpfMC05XStcXF18KVxcfVxcfS9nO1xuICAgICAgICBsZXQgbWF0Y2gsIGJhc2UsIGtleSwgcmVzb2x2ZWRfbmFtZXNwYWNlO1xuICAgICAgICBjb25zdCByZXBsYWNlID0gW107XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKGVsZW1lbnQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYmFzZSA9IG1hdGNoWzBdO1xuICAgICAgICAgICAga2V5ID0gbWF0Y2hbMV0ubGVuZ3RoID8gbWF0Y2hbMV0ucmVwbGFjZSgvKFxcW3xcXF0pL2csICcnKSA6IG51bGw7XG4gICAgICAgICAgICByZXNvbHZlZF9uYW1lc3BhY2UgPSBkZWZhdWx0X25hbWVzcGFjZTtcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2UgIT0gbnVsbCAmJiB0eXBlb2YgbmFtZXNwYWNlID09ICdvYmplY3QnICYmIHR5cGVvZiBuYW1lc3BhY2Vba2V5XSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkX25hbWVzcGFjZSA9IG5hbWVzcGFjZVtrZXldICsgKG5hbWVzcGFjZVtrZXldLmxlbmd0aCA/ICc6JyA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGxhY2UucHVzaCh7IGJhc2U6IGJhc2UsIG5hbWVzcGFjZTogcmVzb2x2ZWRfbmFtZXNwYWNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHIgaW4gcmVwbGFjZSkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQucmVwbGFjZShyZXBsYWNlW3JdLmJhc2UsIHJlcGxhY2Vbcl0ubmFtZXNwYWNlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT0gJ29iamVjdCcgJiYgZWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudC5uYW1lc3BhY2UgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlX25hbWVzcGFjZSA9ICh0eXBlb2YgZWxlbWVudC5uYW1lc3BhY2UgPT0gJ3N0cmluZycpID8geyBkZWZhdWx0OiBlbGVtZW50Lm5hbWVzcGFjZSB9IDogZWxlbWVudC5uYW1lc3BhY2U7XG4gICAgICAgICAgICBuYW1lc3BhY2UgPSBtZXJnZShuYW1lc3BhY2UsIG1lcmdlX25hbWVzcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5hbWVzcGFjZWRfZWxlbWVudCwgbmFtZXNwYWNlZF9wcm9wZXJ0eTtcbiAgICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAnbmFtZXNwYWNlJykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZXNwYWNlZF9lbGVtZW50ID0gYXBwbHlOYW1lc3BhY2VzKGVsZW1lbnRbcHJvcGVydHldLCBuYW1lc3BhY2UsIGRlZmF1bHRfbmFtZXNwYWNlKTtcbiAgICAgICAgICAgIG5hbWVzcGFjZWRfcHJvcGVydHkgPSBhcHBseU5hbWVzcGFjZXMocHJvcGVydHksIG5hbWVzcGFjZSwgZGVmYXVsdF9uYW1lc3BhY2UpO1xuICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSBuYW1lc3BhY2VkX3Byb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudFtuYW1lc3BhY2VkX3Byb3BlcnR5XSA9IG5hbWVzcGFjZWRfZWxlbWVudDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBBIGhlbHBlciBtZXRob2QgdXNlZCBmb3IgbWVyZ2luZyB0d28gb2JqZWN0cy4gSWYgYSBrZXkgaXMgcHJlc2VudCBpbiBib3RoLCB0YWtlcyB0aGUgdmFsdWUgZnJvbSB0aGUgZmlyc3Qgb2JqZWN0XG4gKiAgIFZhbHVlcyBmcm9tIGBkZWZhdWx0X2xheW91dGAgd2lsbCBiZSBjbGVhbmx5IGNvcGllZCBvdmVyLCBlbnN1cmluZyBubyByZWZlcmVuY2VzIG9yIHNoYXJlZCBzdGF0ZS5cbiAqXG4gKiBGcmVxdWVudGx5IHVzZWQgZm9yIHByZXBhcmluZyBjdXN0b20gbGF5b3V0cy4gQm90aCBvYmplY3RzIHNob3VsZCBiZSBKU09OLXNlcmlhbGl6YWJsZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gY3VzdG9tX2xheW91dCBBbiBvYmplY3QgY29udGFpbmluZyBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgdGhhdCBvdmVycmlkZSBvciBhZGQgdG8gZGVmYXVsdHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBkZWZhdWx0X2xheW91dCBBbiBvYmplY3QgY29udGFpbmluZyBkZWZhdWx0IHNldHRpbmdzLlxuICogQHJldHVybnMge29iamVjdH0gVGhlIGN1c3RvbSBsYXlvdXQgaXMgbW9kaWZpZWQgaW4gcGxhY2UgYW5kIGFsc28gcmV0dXJuZWQgZnJvbSB0aGlzIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gbWVyZ2UoY3VzdG9tX2xheW91dCwgZGVmYXVsdF9sYXlvdXQpIHtcbiAgICBpZiAodHlwZW9mIGN1c3RvbV9sYXlvdXQgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBkZWZhdWx0X2xheW91dCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMb2N1c1pvb20uTGF5b3V0cy5tZXJnZSBvbmx5IGFjY2VwdHMgdHdvIGxheW91dCBvYmplY3RzOyAke3R5cGVvZiBjdXN0b21fbGF5b3V0fSwgJHt0eXBlb2YgZGVmYXVsdF9sYXlvdXR9IGdpdmVuYCk7XG4gICAgfVxuICAgIGZvciAobGV0IHByb3BlcnR5IGluIGRlZmF1bHRfbGF5b3V0KSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRlZmF1bHRfbGF5b3V0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0eXBlcyBmb3IgY29tcGFyaXNvbi4gVHJlYXQgbnVsbHMgaW4gdGhlIGN1c3RvbSBsYXlvdXQgYXMgdW5kZWZpbmVkIGZvciBzaW1wbGljaXR5LlxuICAgICAgICAvLyAoamF2YXNjcmlwdCB0cmVhdHMgbnVsbHMgYXMgXCJvYmplY3RcIiB3aGVuIHdlIGp1c3Qgd2FudCB0byBvdmVyd3JpdGUgdGhlbSBhcyBpZiB0aGV5J3JlIHVuZGVmaW5lZClcbiAgICAgICAgLy8gQWxzbyBzZXBhcmF0ZSBhcnJheXMgZnJvbSBvYmplY3RzIGFzIGEgZGlzY3JldGUgdHlwZS5cbiAgICAgICAgbGV0IGN1c3RvbV90eXBlID0gY3VzdG9tX2xheW91dFtwcm9wZXJ0eV0gPT09IG51bGwgPyAndW5kZWZpbmVkJyA6IHR5cGVvZiBjdXN0b21fbGF5b3V0W3Byb3BlcnR5XTtcbiAgICAgICAgbGV0IGRlZmF1bHRfdHlwZSA9IHR5cGVvZiBkZWZhdWx0X2xheW91dFtwcm9wZXJ0eV07XG4gICAgICAgIGlmIChjdXN0b21fdHlwZSA9PT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheShjdXN0b21fbGF5b3V0W3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICAgIGN1c3RvbV90eXBlID0gJ2FycmF5JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmYXVsdF90eXBlID09PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KGRlZmF1bHRfbGF5b3V0W3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICAgIGRlZmF1bHRfdHlwZSA9ICdhcnJheSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5zdXBwb3J0ZWQgcHJvcGVydHkgdHlwZXM6IHRocm93IGFuIGV4Y2VwdGlvblxuICAgICAgICBpZiAoY3VzdG9tX3R5cGUgPT09ICdmdW5jdGlvbicgfHwgZGVmYXVsdF90eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY3VzWm9vbS5MYXlvdXRzLm1lcmdlIGVuY291bnRlcmVkIGFuIHVuc3VwcG9ydGVkIHByb3BlcnR5IHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVbmRlZmluZWQgY3VzdG9tIHZhbHVlOiBwdWxsIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICAgIGlmIChjdXN0b21fdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGN1c3RvbV9sYXlvdXRbcHJvcGVydHldID0gZGVlcENvcHkoZGVmYXVsdF9sYXlvdXRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJvdGggdmFsdWVzIGFyZSBvYmplY3RzOiBtZXJnZSByZWN1cnNpdmVseVxuICAgICAgICBpZiAoY3VzdG9tX3R5cGUgPT09ICdvYmplY3QnICYmIGRlZmF1bHRfdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGN1c3RvbV9sYXlvdXRbcHJvcGVydHldID0gbWVyZ2UoY3VzdG9tX2xheW91dFtwcm9wZXJ0eV0sIGRlZmF1bHRfbGF5b3V0W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VzdG9tX2xheW91dDtcbn1cblxuZnVuY3Rpb24gZGVlcENvcHkoaXRlbSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGl0ZW0pKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IG5hbWUgdG8gc3ltYm9sXG4gKiBMYXlvdXQgb2JqZWN0cyBhY2NlcHQgc3ltYm9sIG5hbWVzIGFzIHN0cmluZ3MgKGNpcmNsZSwgdHJpYW5nbGUsIGV0YykuIENvbnZlcnQgdG8gc3ltYm9sIG9iamVjdHMuXG4gKiBAcmV0dXJuIHtvYmplY3R8bnVsbH0gQW4gb2JqZWN0IHRoYXQgaW1wbGVtZW50cyBhIGRyYXcgbWV0aG9kIChlZyBkMy1zaGFwZSBzeW1ib2xzIG9yIGV4dHJhIExaIGl0ZW1zKVxuICovXG5mdW5jdGlvbiBuYW1lVG9TeW1ib2woc2hhcGUpIHtcbiAgICBpZiAoIXNoYXBlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc2hhcGUgPT09ICd0cmlhbmdsZWRvd24nKSB7XG4gICAgICAgIC8vIEQzIGRvZXMgbm90IHByb3ZpZGUgdGhpcyBzeW1ib2wgbmF0aXZlbHlcbiAgICAgICAgcmV0dXJuIHRyaWFuZ2xlZG93bjtcbiAgICB9XG4gICAgLy8gTGVnZW5kIHNoYXBlIG5hbWVzIGFyZSBzdHJpbmdzOyBuZWVkIHRvIGNvbm5lY3QgdGhpcyB0byBmYWN0b3J5LiBFZyBjaXJjbGUgLS0+IGQzLnN5bWJvbENpcmNsZVxuICAgIGNvbnN0IGZhY3RvcnlfbmFtZSA9IGBzeW1ib2wke3NoYXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc2hhcGUuc2xpY2UoMSl9YDtcbiAgICByZXR1cm4gZDNbZmFjdG9yeV9uYW1lXSB8fCBudWxsO1xufVxuXG5leHBvcnQgeyBhcHBseU5hbWVzcGFjZXMsIGRlZXBDb3B5LCBtZXJnZSwgbmFtZVRvU3ltYm9sIH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGQzOyJdLCJzb3VyY2VSb290IjoiIn0=