/*! Locuszoom 0.13.0-beta.3 */
var LzCredibleSets =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./esm/ext/lz-credible-sets.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./esm/ext/lz-credible-sets.js":
/*!*************************************!*\
  !*** ./esm/ext/lz-credible-sets.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var gwas_credible_sets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gwas-credible-sets */ "gwas-credible-sets");
/* harmony import */ var gwas_credible_sets__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(gwas_credible_sets__WEBPACK_IMPORTED_MODULE_0__);
/**
    Custom code used to power credible sets demonstration example. This is not part of the core LocusZoom library,
    but can be included as a standalone file.

    The page must incorporate and load all libraries before this file can be used, including:
     - Vendor assets
     - LocusZoom
     - gwas-credible-sets (available via NPM or a related CDN)
 @module
*/



function install (LocusZoom) {
    const BaseAdapter = LocusZoom.Adapters.get('BaseAdapter');
    /**
     * Custom data source that calculates the 95% credible set based on provided data.
     * This source must be requested as the second step in a chain, after a previous step that returns fields required
     *  for the calculation.
     *
     * @param {Object} init.params
     * @param {Object} init.params.fields
     * @param {String} init.params.fields.log_pvalue The name of the field containing -log10 pvalue information
     * @param {Number} [init.params.threshold=0.95] The credible set threshold (eg 95%). Will continue selecting SNPs
     *  until the posterior probabilities add up to at least this fraction of the total.
     * @param {Number} [init.params.significance_threshold=7.301] Do not perform a credible set calculation for this
     *  region unless AT LEAST ONE SNP (as -log10p) exceeds the line of GWAS signficance. Otherwise we are declaring a
     *  credible set when there is no evidence of anything being significant at all. If one snp is significant, it will
     *  create a credible set for the entire region; the resulting set may include things below the line of significance.
     */
    class CredibleSetLZ extends BaseAdapter {
        constructor(config) {
            super(...arguments);
            this.dependentSource = true; // Don't do calcs for a region with no assoc data
        }

        parseInit(config) {
            super.parseInit(...arguments);
            if (!(this.params.fields && this.params.fields.log_pvalue)) {
                throw new Error(`Source config for ${this.constructor.SOURCE_NAME} must specify how to find 'fields.log_pvalue'`);
            }

            // Set defaults. Default sig threshold is the line of GWAS significance. (as -log10p)
            this.params = Object.assign(
                { threshold: 0.95, significance_threshold: 7.301 },
                this.params
            );
        }

        getCacheKey (state, chain, fields) {
            const threshold = state.credible_set_threshold || this.params.threshold;
            return [threshold, state.chr, state.start, state.end].join('_');
        }

        fetchRequest(state, chain) {
            if (!chain.body.length) {
                // No credible set can be calculated because there is no association data for this region
                return Promise.resolve([]);
            }

            const self = this;
            // The threshold can be overridden dynamically via `plot.state`, or set when the source is created
            const threshold = state.credible_set_threshold || this.params.threshold;
            // Calculate raw bayes factors and posterior probabilities based on information returned from the API
            if (typeof chain.body[0][self.params.fields.log_pvalue] === 'undefined') {
                throw new Error('Credible set source could not locate the required fields from a previous request.');
            }
            const nlogpvals = chain.body.map((item) => item[self.params.fields.log_pvalue]);

            if (!nlogpvals.some((val) => val >= self.params.significance_threshold)) {
                // If NO points have evidence of significance, define the credible set to be empty
                //  (rather than make a credible set that we don't think is meaningful)
                return Promise.resolve([]);
            }

            const credset_data = [];
            try {
                const scores = gwas_credible_sets__WEBPACK_IMPORTED_MODULE_0__["scoring"].bayesFactors(nlogpvals);
                const posteriorProbabilities = gwas_credible_sets__WEBPACK_IMPORTED_MODULE_0__["scoring"].normalizeProbabilities(scores);

                // Use scores to mark the credible set in various ways (depending on your visualization preferences,
                //   some of these may not be needed)
                const credibleSet = gwas_credible_sets__WEBPACK_IMPORTED_MODULE_0__["marking"].findCredibleSet(posteriorProbabilities, threshold);
                const credSetScaled = gwas_credible_sets__WEBPACK_IMPORTED_MODULE_0__["marking"].rescaleCredibleSet(credibleSet);
                const credSetBool = gwas_credible_sets__WEBPACK_IMPORTED_MODULE_0__["marking"].markBoolean(credibleSet);

                // Annotate each response record based on credible set membership
                for (let i = 0; i < chain.body.length; i++) {
                    credset_data.push({
                        posterior_prob: posteriorProbabilities[i],
                        contrib_fraction: credSetScaled[i],
                        is_member: credSetBool[i],
                    });
                }
            } catch (e) {
                // If the calculation cannot be completed, return the data without annotation fields
                console.error(e);
            }
            return Promise.resolve(credset_data);
        }

        combineChainBody(data, chain, fields, outnames, trans) {
            // At this point namespacing has been applied; add the calculated fields for this source to the chain
            if (chain.body.length && data.length) {
                for (let i = 0; i < data.length; i++) {
                    const src = data[i];
                    const dest = chain.body[i];
                    Object.keys(src).forEach(function (attr) {
                        dest[attr] = src[attr];
                    });
                }
            }
            return chain.body;
        }
    }


    LocusZoom.Adapters.add('CredibleSetLZ', CredibleSetLZ);

    // Add related layouts to the central global registry
    LocusZoom.Layouts.add('tooltip', 'association_credible_set', function () {
        // Extend a known tooltip with an extra row of info showing posterior probabilities
        const l = LocusZoom.Layouts.get('tooltip', 'standard_association', { unnamespaced: true });
        l.html += '{{#if {{namespace[credset]}}posterior_prob}}<br>Posterior probability: <strong>{{{{namespace[credset]}}posterior_prob|scinotation|htmlescape}}</strong>{{/if}}';
        return l;
    }());

    LocusZoom.Layouts.add('tooltip', 'annotation_credible_set', {
        namespace: { 'assoc': 'assoc', 'credset': 'credset' },
        closable: true,
        show: { or: ['highlighted', 'selected'] },
        hide: { and: ['unhighlighted', 'unselected'] },
        html: '<strong>{{{{namespace[assoc]}}variant|htmlescape}}</strong><br>'
            + 'P Value: <strong>{{{{namespace[assoc]}}log_pvalue|logtoscinotation|htmlescape}}</strong><br>' +
            '{{#if {{namespace[credset]}}posterior_prob}}<br>Posterior probability: <strong>{{{{namespace[credset]}}posterior_prob|scinotation|htmlescape}}</strong>{{/if}}',
    });

    LocusZoom.Layouts.add('data_layer', 'association_credible_set', function () {
        const base = LocusZoom.Layouts.get('data_layer', 'association_pvalues', {
            unnamespaced: true,
            id: 'associationcredibleset',
            namespace: { 'assoc': 'assoc', 'credset': 'credset', 'ld': 'ld' },
            fill_opacity: 0.7,
            tooltip: LocusZoom.Layouts.get('tooltip', 'association_credible_set', { unnamespaced: true }),
            fields: [
                '{{namespace[assoc]}}variant', '{{namespace[assoc]}}position',
                '{{namespace[assoc]}}log_pvalue', '{{namespace[assoc]}}log_pvalue|logtoscinotation',
                '{{namespace[assoc]}}ref_allele',
                '{{namespace[credset]}}posterior_prob', '{{namespace[credset]}}contrib_fraction',
                '{{namespace[credset]}}is_member',
                '{{namespace[ld]}}state', '{{namespace[ld]}}isrefvar',
            ],
            match: { send: '{{namespace[assoc]}}variant', receive: '{{namespace[assoc]}}variant' },
        });
        base.color.unshift({
            field: 'lz_is_match',  // Special field name whose presence triggers custom rendering
            scale_function: 'if',
            parameters: {
                field_value: true,
                then: '#FFf000',
            },
        });
        return base;
    }());

    LocusZoom.Layouts.add('data_layer', 'annotation_credible_set', {
        namespace: { 'assoc': 'assoc', 'credset': 'credset' },
        id: 'annotationcredibleset',
        type: 'annotation_track',
        id_field: '{{namespace[assoc]}}variant',
        x_axis: {
            field: '{{namespace[assoc]}}position',
        },
        color: [
            {
                field: 'lz_is_match',  // Special field name whose presence triggers custom rendering
                scale_function: 'if',
                parameters: {
                    field_value: true,
                    then: '#001cee',
                },
            },
            '#00CC00',
        ],
        fields: ['{{namespace[assoc]}}variant', '{{namespace[assoc]}}position', '{{namespace[assoc]}}log_pvalue', '{{namespace[credset]}}posterior_prob', '{{namespace[credset]}}contrib_fraction', '{{namespace[credset]}}is_member'],
        match: { send: '{{namespace[assoc]}}variant', receive: '{{namespace[assoc]}}variant' },
        filters: [
            // Specify which points to show on the track. Any selection must satisfy ALL filters
            { field: '{{namespace[credset]}}is_member', operator: '=', value: true },
        ],
        behaviors: {
            onmouseover: [
                { action: 'set', status: 'highlighted' },
            ],
            onmouseout: [
                { action: 'unset', status: 'highlighted' },
            ],
            onclick: [
                { action: 'toggle', status: 'selected', exclusive: true },
            ],
            onshiftclick: [
                { action: 'toggle', status: 'selected' },
            ],
        },
        tooltip: LocusZoom.Layouts.get('tooltip', 'annotation_credible_set', { unnamespaced: true }),
        tooltip_positioning: 'top',
    });

    LocusZoom.Layouts.add('panel', 'annotation_credible_set', {
        id: 'annotationcredibleset',
        title: { text: 'SNPs in 95% credible set', x: 50, style: { 'font-size': '14px' } },
        min_height: 45,
        height: 45,
        margin: { top: 25, right: 50, bottom: 0, left: 50 },
        inner_border: 'rgb(210, 210, 210)',
        toolbar: LocusZoom.Layouts.get('toolbar', 'standard_panel', { unnamespaced: true }),
        interaction: {
            drag_background_to_pan: true,
            scroll_to_zoom: true,
            x_linked: true,
        },
        data_layers: [
            LocusZoom.Layouts.get('data_layer', 'annotation_credible_set', { unnamespaced: true }),
        ],
    });

    LocusZoom.Layouts.add('panel', 'association_credible_set', function () {
        const l = LocusZoom.Layouts.get('panel', 'association', {
            unnamespaced: true,
            id: 'associationcrediblesets',
            namespace: { 'assoc': 'assoc', 'credset': 'credset' },
            data_layers: [
                LocusZoom.Layouts.get('data_layer', 'significance', { unnamespaced: true }),
                LocusZoom.Layouts.get('data_layer', 'recomb_rate', { unnamespaced: true }),
                LocusZoom.Layouts.get('data_layer', 'association_credible_set', { unnamespaced: true }),
            ],
        });
        // Add "display options" button to control how credible set coloring is overlaid on the standard association plot
        l.toolbar.widgets.push(
            {
                type: 'display_options',
                position: 'right',
                color: 'blue',
                // Below: special config specific to this widget
                button_html: 'Display options...',
                button_title: 'Control how plot items are displayed',
                layer_name: 'associationcredibleset',
                default_config_display_name: 'Linkage Disequilibrium (default)', // display name for the default plot color option (allow user to revert to plot defaults)

                options: [
                    {
                        // First dropdown menu item
                        display_name: '95% credible set (boolean)',  // Human readable representation of field name
                        display: {  // Specify layout directives that control display of the plot for this option
                            point_shape: 'circle',
                            point_size: 40,
                            color: {
                                field: '{{namespace[credset]}}is_member',
                                scale_function: 'if',
                                parameters: {
                                    field_value: true,
                                    then: '#00CC00',
                                    else: '#CCCCCC',
                                },
                            },
                            legend: [ // Tells the legend how to represent this display option
                                {
                                    shape: 'circle',
                                    color: '#00CC00',
                                    size: 40,
                                    label: 'In credible set',
                                    class: 'lz-data_layer-scatter',
                                },
                                {
                                    shape: 'circle',
                                    color: '#CCCCCC',
                                    size: 40,
                                    label: 'Not in credible set',
                                    class: 'lz-data_layer-scatter',
                                },
                            ],
                        },
                    },
                    {
                        // Second option. The same plot- or even the same field- can be colored in more than one way.
                        display_name: '95% credible set (gradient by contribution)',
                        display: {
                            point_shape: 'circle',
                            point_size: 40,
                            color: [
                                {
                                    field: '{{namespace[credset]}}contrib_fraction',
                                    scale_function: 'if',
                                    parameters: {
                                        field_value: 0,
                                        then: '#777777',
                                    },
                                },
                                {
                                    scale_function: 'interpolate',
                                    field: '{{namespace[credset]}}contrib_fraction',
                                    parameters: {
                                        breaks: [0, 1],
                                        values: ['#fafe87', '#9c0000'],
                                    },
                                },
                            ],
                            legend: [
                                {
                                    shape: 'circle',
                                    color: '#777777',
                                    size: 40,
                                    label: 'No contribution',
                                    class: 'lz-data_layer-scatter',
                                },
                                {
                                    shape: 'circle',
                                    color: '#fafe87',
                                    size: 40,
                                    label: 'Some contribution',
                                    class: 'lz-data_layer-scatter',
                                },
                                {
                                    shape: 'circle',
                                    color: '#9c0000',
                                    size: 40,
                                    label: 'Most contribution',
                                    class: 'lz-data_layer-scatter',
                                },
                            ],
                        },
                    },
                ],
            }
        );
        return l;
    }());

    LocusZoom.Layouts.add('plot', 'association_credible_set', {
        state: {},
        width: 800,
        height: 450,
        responsive_resize: true,
        min_region_scale: 20000,
        max_region_scale: 1000000,
        toolbar: LocusZoom.Layouts.get('toolbar', 'standard_association', { unnamespaced: true }),
        panels: [
            LocusZoom.Layouts.get('panel', 'association_credible_set', { unnamespaced: true }),
            LocusZoom.Layouts.get('panel', 'annotation_credible_set', { unnamespaced: true }),
            LocusZoom.Layouts.get('panel', 'genes', { unnamespaced: true }),
        ],
    });

}


if (typeof LocusZoom !== 'undefined') {
    // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()
    // eslint-disable-next-line no-undef
    LocusZoom.use(install);
}


/* harmony default export */ __webpack_exports__["default"] = (install);


/***/ }),

/***/ "gwas-credible-sets":
/*!***********************************!*\
  !*** external "gwasCredibleSets" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = gwasCredibleSets;

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2V4dC9sei1jcmVkaWJsZS1zZXRzLmpzIiwid2VicGFjazovL1tuYW1lXS9leHRlcm5hbCBcImd3YXNDcmVkaWJsZVNldHNcIiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFb0Q7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtB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aUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUscUJBQXFCO0FBQ2hHO0FBQ0Esd0VBQXdFLHFCQUFxQjtBQUM3Rix1RUFBdUUscUJBQXFCO0FBQzVGLHFEQUFxRCxxQkFBcUI7QUFDMUU7QUFDQSxLQUFLOztBQUVMOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHZSxzRUFBTyxFQUFDOzs7Ozs7Ozs7Ozs7QUMzV3ZCLGtDIiwiZmlsZSI6ImV4dC9sei1jcmVkaWJsZS1zZXRzLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vZXNtL2V4dC9sei1jcmVkaWJsZS1zZXRzLmpzXCIpO1xuIiwiLyoqXG4gICAgQ3VzdG9tIGNvZGUgdXNlZCB0byBwb3dlciBjcmVkaWJsZSBzZXRzIGRlbW9uc3RyYXRpb24gZXhhbXBsZS4gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgY29yZSBMb2N1c1pvb20gbGlicmFyeSxcbiAgICBidXQgY2FuIGJlIGluY2x1ZGVkIGFzIGEgc3RhbmRhbG9uZSBmaWxlLlxuXG4gICAgVGhlIHBhZ2UgbXVzdCBpbmNvcnBvcmF0ZSBhbmQgbG9hZCBhbGwgbGlicmFyaWVzIGJlZm9yZSB0aGlzIGZpbGUgY2FuIGJlIHVzZWQsIGluY2x1ZGluZzpcbiAgICAgLSBWZW5kb3IgYXNzZXRzXG4gICAgIC0gTG9jdXNab29tXG4gICAgIC0gZ3dhcy1jcmVkaWJsZS1zZXRzIChhdmFpbGFibGUgdmlhIE5QTSBvciBhIHJlbGF0ZWQgQ0ROKVxuIEBtb2R1bGVcbiovXG5cbmltcG9ydCB7bWFya2luZywgc2NvcmluZ30gZnJvbSAnZ3dhcy1jcmVkaWJsZS1zZXRzJztcblxuZnVuY3Rpb24gaW5zdGFsbCAoTG9jdXNab29tKSB7XG4gICAgY29uc3QgQmFzZUFkYXB0ZXIgPSBMb2N1c1pvb20uQWRhcHRlcnMuZ2V0KCdCYXNlQWRhcHRlcicpO1xuICAgIC8qKlxuICAgICAqIEN1c3RvbSBkYXRhIHNvdXJjZSB0aGF0IGNhbGN1bGF0ZXMgdGhlIDk1JSBjcmVkaWJsZSBzZXQgYmFzZWQgb24gcHJvdmlkZWQgZGF0YS5cbiAgICAgKiBUaGlzIHNvdXJjZSBtdXN0IGJlIHJlcXVlc3RlZCBhcyB0aGUgc2Vjb25kIHN0ZXAgaW4gYSBjaGFpbiwgYWZ0ZXIgYSBwcmV2aW91cyBzdGVwIHRoYXQgcmV0dXJucyBmaWVsZHMgcmVxdWlyZWRcbiAgICAgKiAgZm9yIHRoZSBjYWxjdWxhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbml0LnBhcmFtc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbml0LnBhcmFtcy5maWVsZHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaW5pdC5wYXJhbXMuZmllbGRzLmxvZ19wdmFsdWUgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIGNvbnRhaW5pbmcgLWxvZzEwIHB2YWx1ZSBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5pdC5wYXJhbXMudGhyZXNob2xkPTAuOTVdIFRoZSBjcmVkaWJsZSBzZXQgdGhyZXNob2xkIChlZyA5NSUpLiBXaWxsIGNvbnRpbnVlIHNlbGVjdGluZyBTTlBzXG4gICAgICogIHVudGlsIHRoZSBwb3N0ZXJpb3IgcHJvYmFiaWxpdGllcyBhZGQgdXAgdG8gYXQgbGVhc3QgdGhpcyBmcmFjdGlvbiBvZiB0aGUgdG90YWwuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbml0LnBhcmFtcy5zaWduaWZpY2FuY2VfdGhyZXNob2xkPTcuMzAxXSBEbyBub3QgcGVyZm9ybSBhIGNyZWRpYmxlIHNldCBjYWxjdWxhdGlvbiBmb3IgdGhpc1xuICAgICAqICByZWdpb24gdW5sZXNzIEFUIExFQVNUIE9ORSBTTlAgKGFzIC1sb2cxMHApIGV4Y2VlZHMgdGhlIGxpbmUgb2YgR1dBUyBzaWduZmljYW5jZS4gT3RoZXJ3aXNlIHdlIGFyZSBkZWNsYXJpbmcgYVxuICAgICAqICBjcmVkaWJsZSBzZXQgd2hlbiB0aGVyZSBpcyBubyBldmlkZW5jZSBvZiBhbnl0aGluZyBiZWluZyBzaWduaWZpY2FudCBhdCBhbGwuIElmIG9uZSBzbnAgaXMgc2lnbmlmaWNhbnQsIGl0IHdpbGxcbiAgICAgKiAgY3JlYXRlIGEgY3JlZGlibGUgc2V0IGZvciB0aGUgZW50aXJlIHJlZ2lvbjsgdGhlIHJlc3VsdGluZyBzZXQgbWF5IGluY2x1ZGUgdGhpbmdzIGJlbG93IHRoZSBsaW5lIG9mIHNpZ25pZmljYW5jZS5cbiAgICAgKi9cbiAgICBjbGFzcyBDcmVkaWJsZVNldExaIGV4dGVuZHMgQmFzZUFkYXB0ZXIge1xuICAgICAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVudFNvdXJjZSA9IHRydWU7IC8vIERvbid0IGRvIGNhbGNzIGZvciBhIHJlZ2lvbiB3aXRoIG5vIGFzc29jIGRhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnNlSW5pdChjb25maWcpIHtcbiAgICAgICAgICAgIHN1cGVyLnBhcnNlSW5pdCguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKCEodGhpcy5wYXJhbXMuZmllbGRzICYmIHRoaXMucGFyYW1zLmZpZWxkcy5sb2dfcHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU291cmNlIGNvbmZpZyBmb3IgJHt0aGlzLmNvbnN0cnVjdG9yLlNPVVJDRV9OQU1FfSBtdXN0IHNwZWNpZnkgaG93IHRvIGZpbmQgJ2ZpZWxkcy5sb2dfcHZhbHVlJ2ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXQgZGVmYXVsdHMuIERlZmF1bHQgc2lnIHRocmVzaG9sZCBpcyB0aGUgbGluZSBvZiBHV0FTIHNpZ25pZmljYW5jZS4gKGFzIC1sb2cxMHApXG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICAgICAgeyB0aHJlc2hvbGQ6IDAuOTUsIHNpZ25pZmljYW5jZV90aHJlc2hvbGQ6IDcuMzAxIH0sXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXNcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRDYWNoZUtleSAoc3RhdGUsIGNoYWluLCBmaWVsZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IHN0YXRlLmNyZWRpYmxlX3NldF90aHJlc2hvbGQgfHwgdGhpcy5wYXJhbXMudGhyZXNob2xkO1xuICAgICAgICAgICAgcmV0dXJuIFt0aHJlc2hvbGQsIHN0YXRlLmNociwgc3RhdGUuc3RhcnQsIHN0YXRlLmVuZF0uam9pbignXycpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmV0Y2hSZXF1ZXN0KHN0YXRlLCBjaGFpbikge1xuICAgICAgICAgICAgaWYgKCFjaGFpbi5ib2R5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIE5vIGNyZWRpYmxlIHNldCBjYW4gYmUgY2FsY3VsYXRlZCBiZWNhdXNlIHRoZXJlIGlzIG5vIGFzc29jaWF0aW9uIGRhdGEgZm9yIHRoaXMgcmVnaW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgLy8gVGhlIHRocmVzaG9sZCBjYW4gYmUgb3ZlcnJpZGRlbiBkeW5hbWljYWxseSB2aWEgYHBsb3Quc3RhdGVgLCBvciBzZXQgd2hlbiB0aGUgc291cmNlIGlzIGNyZWF0ZWRcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IHN0YXRlLmNyZWRpYmxlX3NldF90aHJlc2hvbGQgfHwgdGhpcy5wYXJhbXMudGhyZXNob2xkO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHJhdyBiYXllcyBmYWN0b3JzIGFuZCBwb3N0ZXJpb3IgcHJvYmFiaWxpdGllcyBiYXNlZCBvbiBpbmZvcm1hdGlvbiByZXR1cm5lZCBmcm9tIHRoZSBBUElcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hhaW4uYm9keVswXVtzZWxmLnBhcmFtcy5maWVsZHMubG9nX3B2YWx1ZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDcmVkaWJsZSBzZXQgc291cmNlIGNvdWxkIG5vdCBsb2NhdGUgdGhlIHJlcXVpcmVkIGZpZWxkcyBmcm9tIGEgcHJldmlvdXMgcmVxdWVzdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5sb2dwdmFscyA9IGNoYWluLmJvZHkubWFwKChpdGVtKSA9PiBpdGVtW3NlbGYucGFyYW1zLmZpZWxkcy5sb2dfcHZhbHVlXSk7XG5cbiAgICAgICAgICAgIGlmICghbmxvZ3B2YWxzLnNvbWUoKHZhbCkgPT4gdmFsID49IHNlbGYucGFyYW1zLnNpZ25pZmljYW5jZV90aHJlc2hvbGQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgTk8gcG9pbnRzIGhhdmUgZXZpZGVuY2Ugb2Ygc2lnbmlmaWNhbmNlLCBkZWZpbmUgdGhlIGNyZWRpYmxlIHNldCB0byBiZSBlbXB0eVxuICAgICAgICAgICAgICAgIC8vICAocmF0aGVyIHRoYW4gbWFrZSBhIGNyZWRpYmxlIHNldCB0aGF0IHdlIGRvbid0IHRoaW5rIGlzIG1lYW5pbmdmdWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNyZWRzZXRfZGF0YSA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY29yZXMgPSBzY29yaW5nLmJheWVzRmFjdG9ycyhubG9ncHZhbHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RlcmlvclByb2JhYmlsaXRpZXMgPSBzY29yaW5nLm5vcm1hbGl6ZVByb2JhYmlsaXRpZXMoc2NvcmVzKTtcblxuICAgICAgICAgICAgICAgIC8vIFVzZSBzY29yZXMgdG8gbWFyayB0aGUgY3JlZGlibGUgc2V0IGluIHZhcmlvdXMgd2F5cyAoZGVwZW5kaW5nIG9uIHlvdXIgdmlzdWFsaXphdGlvbiBwcmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICAvLyAgIHNvbWUgb2YgdGhlc2UgbWF5IG5vdCBiZSBuZWVkZWQpXG4gICAgICAgICAgICAgICAgY29uc3QgY3JlZGlibGVTZXQgPSBtYXJraW5nLmZpbmRDcmVkaWJsZVNldChwb3N0ZXJpb3JQcm9iYWJpbGl0aWVzLCB0aHJlc2hvbGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNyZWRTZXRTY2FsZWQgPSBtYXJraW5nLnJlc2NhbGVDcmVkaWJsZVNldChjcmVkaWJsZVNldCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JlZFNldEJvb2wgPSBtYXJraW5nLm1hcmtCb29sZWFuKGNyZWRpYmxlU2V0KTtcblxuICAgICAgICAgICAgICAgIC8vIEFubm90YXRlIGVhY2ggcmVzcG9uc2UgcmVjb3JkIGJhc2VkIG9uIGNyZWRpYmxlIHNldCBtZW1iZXJzaGlwXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFpbi5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWRzZXRfZGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3Rlcmlvcl9wcm9iOiBwb3N0ZXJpb3JQcm9iYWJpbGl0aWVzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJpYl9mcmFjdGlvbjogY3JlZFNldFNjYWxlZFtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzX21lbWJlcjogY3JlZFNldEJvb2xbaV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2FsY3VsYXRpb24gY2Fubm90IGJlIGNvbXBsZXRlZCwgcmV0dXJuIHRoZSBkYXRhIHdpdGhvdXQgYW5ub3RhdGlvbiBmaWVsZHNcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVkc2V0X2RhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tYmluZUNoYWluQm9keShkYXRhLCBjaGFpbiwgZmllbGRzLCBvdXRuYW1lcywgdHJhbnMpIHtcbiAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgbmFtZXNwYWNpbmcgaGFzIGJlZW4gYXBwbGllZDsgYWRkIHRoZSBjYWxjdWxhdGVkIGZpZWxkcyBmb3IgdGhpcyBzb3VyY2UgdG8gdGhlIGNoYWluXG4gICAgICAgICAgICBpZiAoY2hhaW4uYm9keS5sZW5ndGggJiYgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3JjID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdCA9IGNoYWluLmJvZHlbaV07XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHNyYykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdFthdHRyXSA9IHNyY1thdHRyXTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoYWluLmJvZHk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIExvY3VzWm9vbS5BZGFwdGVycy5hZGQoJ0NyZWRpYmxlU2V0TFonLCBDcmVkaWJsZVNldExaKTtcblxuICAgIC8vIEFkZCByZWxhdGVkIGxheW91dHMgdG8gdGhlIGNlbnRyYWwgZ2xvYmFsIHJlZ2lzdHJ5XG4gICAgTG9jdXNab29tLkxheW91dHMuYWRkKCd0b29sdGlwJywgJ2Fzc29jaWF0aW9uX2NyZWRpYmxlX3NldCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRXh0ZW5kIGEga25vd24gdG9vbHRpcCB3aXRoIGFuIGV4dHJhIHJvdyBvZiBpbmZvIHNob3dpbmcgcG9zdGVyaW9yIHByb2JhYmlsaXRpZXNcbiAgICAgICAgY29uc3QgbCA9IExvY3VzWm9vbS5MYXlvdXRzLmdldCgndG9vbHRpcCcsICdzdGFuZGFyZF9hc3NvY2lhdGlvbicsIHsgdW5uYW1lc3BhY2VkOiB0cnVlIH0pO1xuICAgICAgICBsLmh0bWwgKz0gJ3t7I2lmIHt7bmFtZXNwYWNlW2NyZWRzZXRdfX1wb3N0ZXJpb3JfcHJvYn19PGJyPlBvc3RlcmlvciBwcm9iYWJpbGl0eTogPHN0cm9uZz57e3t7bmFtZXNwYWNlW2NyZWRzZXRdfX1wb3N0ZXJpb3JfcHJvYnxzY2lub3RhdGlvbnxodG1sZXNjYXBlfX08L3N0cm9uZz57ey9pZn19JztcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgfSgpKTtcblxuICAgIExvY3VzWm9vbS5MYXlvdXRzLmFkZCgndG9vbHRpcCcsICdhbm5vdGF0aW9uX2NyZWRpYmxlX3NldCcsIHtcbiAgICAgICAgbmFtZXNwYWNlOiB7ICdhc3NvYyc6ICdhc3NvYycsICdjcmVkc2V0JzogJ2NyZWRzZXQnIH0sXG4gICAgICAgIGNsb3NhYmxlOiB0cnVlLFxuICAgICAgICBzaG93OiB7IG9yOiBbJ2hpZ2hsaWdodGVkJywgJ3NlbGVjdGVkJ10gfSxcbiAgICAgICAgaGlkZTogeyBhbmQ6IFsndW5oaWdobGlnaHRlZCcsICd1bnNlbGVjdGVkJ10gfSxcbiAgICAgICAgaHRtbDogJzxzdHJvbmc+e3t7e25hbWVzcGFjZVthc3NvY119fXZhcmlhbnR8aHRtbGVzY2FwZX19PC9zdHJvbmc+PGJyPidcbiAgICAgICAgICAgICsgJ1AgVmFsdWU6IDxzdHJvbmc+e3t7e25hbWVzcGFjZVthc3NvY119fWxvZ19wdmFsdWV8bG9ndG9zY2lub3RhdGlvbnxodG1sZXNjYXBlfX08L3N0cm9uZz48YnI+JyArXG4gICAgICAgICAgICAne3sjaWYge3tuYW1lc3BhY2VbY3JlZHNldF19fXBvc3Rlcmlvcl9wcm9ifX08YnI+UG9zdGVyaW9yIHByb2JhYmlsaXR5OiA8c3Ryb25nPnt7e3tuYW1lc3BhY2VbY3JlZHNldF19fXBvc3Rlcmlvcl9wcm9ifHNjaW5vdGF0aW9ufGh0bWxlc2NhcGV9fTwvc3Ryb25nPnt7L2lmfX0nLFxuICAgIH0pO1xuXG4gICAgTG9jdXNab29tLkxheW91dHMuYWRkKCdkYXRhX2xheWVyJywgJ2Fzc29jaWF0aW9uX2NyZWRpYmxlX3NldCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IExvY3VzWm9vbS5MYXlvdXRzLmdldCgnZGF0YV9sYXllcicsICdhc3NvY2lhdGlvbl9wdmFsdWVzJywge1xuICAgICAgICAgICAgdW5uYW1lc3BhY2VkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6ICdhc3NvY2lhdGlvbmNyZWRpYmxlc2V0JyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogeyAnYXNzb2MnOiAnYXNzb2MnLCAnY3JlZHNldCc6ICdjcmVkc2V0JywgJ2xkJzogJ2xkJyB9LFxuICAgICAgICAgICAgZmlsbF9vcGFjaXR5OiAwLjcsXG4gICAgICAgICAgICB0b29sdGlwOiBMb2N1c1pvb20uTGF5b3V0cy5nZXQoJ3Rvb2x0aXAnLCAnYXNzb2NpYXRpb25fY3JlZGlibGVfc2V0JywgeyB1bm5hbWVzcGFjZWQ6IHRydWUgfSksXG4gICAgICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICAne3tuYW1lc3BhY2VbYXNzb2NdfX12YXJpYW50JywgJ3t7bmFtZXNwYWNlW2Fzc29jXX19cG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICd7e25hbWVzcGFjZVthc3NvY119fWxvZ19wdmFsdWUnLCAne3tuYW1lc3BhY2VbYXNzb2NdfX1sb2dfcHZhbHVlfGxvZ3Rvc2Npbm90YXRpb24nLFxuICAgICAgICAgICAgICAgICd7e25hbWVzcGFjZVthc3NvY119fXJlZl9hbGxlbGUnLFxuICAgICAgICAgICAgICAgICd7e25hbWVzcGFjZVtjcmVkc2V0XX19cG9zdGVyaW9yX3Byb2InLCAne3tuYW1lc3BhY2VbY3JlZHNldF19fWNvbnRyaWJfZnJhY3Rpb24nLFxuICAgICAgICAgICAgICAgICd7e25hbWVzcGFjZVtjcmVkc2V0XX19aXNfbWVtYmVyJyxcbiAgICAgICAgICAgICAgICAne3tuYW1lc3BhY2VbbGRdfX1zdGF0ZScsICd7e25hbWVzcGFjZVtsZF19fWlzcmVmdmFyJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBtYXRjaDogeyBzZW5kOiAne3tuYW1lc3BhY2VbYXNzb2NdfX12YXJpYW50JywgcmVjZWl2ZTogJ3t7bmFtZXNwYWNlW2Fzc29jXX19dmFyaWFudCcgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGJhc2UuY29sb3IudW5zaGlmdCh7XG4gICAgICAgICAgICBmaWVsZDogJ2x6X2lzX21hdGNoJywgIC8vIFNwZWNpYWwgZmllbGQgbmFtZSB3aG9zZSBwcmVzZW5jZSB0cmlnZ2VycyBjdXN0b20gcmVuZGVyaW5nXG4gICAgICAgICAgICBzY2FsZV9mdW5jdGlvbjogJ2lmJyxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBmaWVsZF92YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aGVuOiAnI0ZGZjAwMCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfSgpKTtcblxuICAgIExvY3VzWm9vbS5MYXlvdXRzLmFkZCgnZGF0YV9sYXllcicsICdhbm5vdGF0aW9uX2NyZWRpYmxlX3NldCcsIHtcbiAgICAgICAgbmFtZXNwYWNlOiB7ICdhc3NvYyc6ICdhc3NvYycsICdjcmVkc2V0JzogJ2NyZWRzZXQnIH0sXG4gICAgICAgIGlkOiAnYW5ub3RhdGlvbmNyZWRpYmxlc2V0JyxcbiAgICAgICAgdHlwZTogJ2Fubm90YXRpb25fdHJhY2snLFxuICAgICAgICBpZF9maWVsZDogJ3t7bmFtZXNwYWNlW2Fzc29jXX19dmFyaWFudCcsXG4gICAgICAgIHhfYXhpczoge1xuICAgICAgICAgICAgZmllbGQ6ICd7e25hbWVzcGFjZVthc3NvY119fXBvc2l0aW9uJyxcbiAgICAgICAgfSxcbiAgICAgICAgY29sb3I6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBmaWVsZDogJ2x6X2lzX21hdGNoJywgIC8vIFNwZWNpYWwgZmllbGQgbmFtZSB3aG9zZSBwcmVzZW5jZSB0cmlnZ2VycyBjdXN0b20gcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgc2NhbGVfZnVuY3Rpb246ICdpZicsXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZF92YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGhlbjogJyMwMDFjZWUnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJyMwMENDMDAnLFxuICAgICAgICBdLFxuICAgICAgICBmaWVsZHM6IFsne3tuYW1lc3BhY2VbYXNzb2NdfX12YXJpYW50JywgJ3t7bmFtZXNwYWNlW2Fzc29jXX19cG9zaXRpb24nLCAne3tuYW1lc3BhY2VbYXNzb2NdfX1sb2dfcHZhbHVlJywgJ3t7bmFtZXNwYWNlW2NyZWRzZXRdfX1wb3N0ZXJpb3JfcHJvYicsICd7e25hbWVzcGFjZVtjcmVkc2V0XX19Y29udHJpYl9mcmFjdGlvbicsICd7e25hbWVzcGFjZVtjcmVkc2V0XX19aXNfbWVtYmVyJ10sXG4gICAgICAgIG1hdGNoOiB7IHNlbmQ6ICd7e25hbWVzcGFjZVthc3NvY119fXZhcmlhbnQnLCByZWNlaXZlOiAne3tuYW1lc3BhY2VbYXNzb2NdfX12YXJpYW50JyB9LFxuICAgICAgICBmaWx0ZXJzOiBbXG4gICAgICAgICAgICAvLyBTcGVjaWZ5IHdoaWNoIHBvaW50cyB0byBzaG93IG9uIHRoZSB0cmFjay4gQW55IHNlbGVjdGlvbiBtdXN0IHNhdGlzZnkgQUxMIGZpbHRlcnNcbiAgICAgICAgICAgIHsgZmllbGQ6ICd7e25hbWVzcGFjZVtjcmVkc2V0XX19aXNfbWVtYmVyJywgb3BlcmF0b3I6ICc9JywgdmFsdWU6IHRydWUgfSxcbiAgICAgICAgXSxcbiAgICAgICAgYmVoYXZpb3JzOiB7XG4gICAgICAgICAgICBvbm1vdXNlb3ZlcjogW1xuICAgICAgICAgICAgICAgIHsgYWN0aW9uOiAnc2V0Jywgc3RhdHVzOiAnaGlnaGxpZ2h0ZWQnIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgb25tb3VzZW91dDogW1xuICAgICAgICAgICAgICAgIHsgYWN0aW9uOiAndW5zZXQnLCBzdGF0dXM6ICdoaWdobGlnaHRlZCcgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBvbmNsaWNrOiBbXG4gICAgICAgICAgICAgICAgeyBhY3Rpb246ICd0b2dnbGUnLCBzdGF0dXM6ICdzZWxlY3RlZCcsIGV4Y2x1c2l2ZTogdHJ1ZSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG9uc2hpZnRjbGljazogW1xuICAgICAgICAgICAgICAgIHsgYWN0aW9uOiAndG9nZ2xlJywgc3RhdHVzOiAnc2VsZWN0ZWQnIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiBMb2N1c1pvb20uTGF5b3V0cy5nZXQoJ3Rvb2x0aXAnLCAnYW5ub3RhdGlvbl9jcmVkaWJsZV9zZXQnLCB7IHVubmFtZXNwYWNlZDogdHJ1ZSB9KSxcbiAgICAgICAgdG9vbHRpcF9wb3NpdGlvbmluZzogJ3RvcCcsXG4gICAgfSk7XG5cbiAgICBMb2N1c1pvb20uTGF5b3V0cy5hZGQoJ3BhbmVsJywgJ2Fubm90YXRpb25fY3JlZGlibGVfc2V0Jywge1xuICAgICAgICBpZDogJ2Fubm90YXRpb25jcmVkaWJsZXNldCcsXG4gICAgICAgIHRpdGxlOiB7IHRleHQ6ICdTTlBzIGluIDk1JSBjcmVkaWJsZSBzZXQnLCB4OiA1MCwgc3R5bGU6IHsgJ2ZvbnQtc2l6ZSc6ICcxNHB4JyB9IH0sXG4gICAgICAgIG1pbl9oZWlnaHQ6IDQ1LFxuICAgICAgICBoZWlnaHQ6IDQ1LFxuICAgICAgICBtYXJnaW46IHsgdG9wOiAyNSwgcmlnaHQ6IDUwLCBib3R0b206IDAsIGxlZnQ6IDUwIH0sXG4gICAgICAgIGlubmVyX2JvcmRlcjogJ3JnYigyMTAsIDIxMCwgMjEwKScsXG4gICAgICAgIHRvb2xiYXI6IExvY3VzWm9vbS5MYXlvdXRzLmdldCgndG9vbGJhcicsICdzdGFuZGFyZF9wYW5lbCcsIHsgdW5uYW1lc3BhY2VkOiB0cnVlIH0pLFxuICAgICAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgICAgICAgZHJhZ19iYWNrZ3JvdW5kX3RvX3BhbjogdHJ1ZSxcbiAgICAgICAgICAgIHNjcm9sbF90b196b29tOiB0cnVlLFxuICAgICAgICAgICAgeF9saW5rZWQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGFfbGF5ZXJzOiBbXG4gICAgICAgICAgICBMb2N1c1pvb20uTGF5b3V0cy5nZXQoJ2RhdGFfbGF5ZXInLCAnYW5ub3RhdGlvbl9jcmVkaWJsZV9zZXQnLCB7IHVubmFtZXNwYWNlZDogdHJ1ZSB9KSxcbiAgICAgICAgXSxcbiAgICB9KTtcblxuICAgIExvY3VzWm9vbS5MYXlvdXRzLmFkZCgncGFuZWwnLCAnYXNzb2NpYXRpb25fY3JlZGlibGVfc2V0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBsID0gTG9jdXNab29tLkxheW91dHMuZ2V0KCdwYW5lbCcsICdhc3NvY2lhdGlvbicsIHtcbiAgICAgICAgICAgIHVubmFtZXNwYWNlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiAnYXNzb2NpYXRpb25jcmVkaWJsZXNldHMnLFxuICAgICAgICAgICAgbmFtZXNwYWNlOiB7ICdhc3NvYyc6ICdhc3NvYycsICdjcmVkc2V0JzogJ2NyZWRzZXQnIH0sXG4gICAgICAgICAgICBkYXRhX2xheWVyczogW1xuICAgICAgICAgICAgICAgIExvY3VzWm9vbS5MYXlvdXRzLmdldCgnZGF0YV9sYXllcicsICdzaWduaWZpY2FuY2UnLCB7IHVubmFtZXNwYWNlZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICBMb2N1c1pvb20uTGF5b3V0cy5nZXQoJ2RhdGFfbGF5ZXInLCAncmVjb21iX3JhdGUnLCB7IHVubmFtZXNwYWNlZDogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICBMb2N1c1pvb20uTGF5b3V0cy5nZXQoJ2RhdGFfbGF5ZXInLCAnYXNzb2NpYXRpb25fY3JlZGlibGVfc2V0JywgeyB1bm5hbWVzcGFjZWQ6IHRydWUgfSksXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWRkIFwiZGlzcGxheSBvcHRpb25zXCIgYnV0dG9uIHRvIGNvbnRyb2wgaG93IGNyZWRpYmxlIHNldCBjb2xvcmluZyBpcyBvdmVybGFpZCBvbiB0aGUgc3RhbmRhcmQgYXNzb2NpYXRpb24gcGxvdFxuICAgICAgICBsLnRvb2xiYXIud2lkZ2V0cy5wdXNoKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdkaXNwbGF5X29wdGlvbnMnLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnYmx1ZScsXG4gICAgICAgICAgICAgICAgLy8gQmVsb3c6IHNwZWNpYWwgY29uZmlnIHNwZWNpZmljIHRvIHRoaXMgd2lkZ2V0XG4gICAgICAgICAgICAgICAgYnV0dG9uX2h0bWw6ICdEaXNwbGF5IG9wdGlvbnMuLi4nLFxuICAgICAgICAgICAgICAgIGJ1dHRvbl90aXRsZTogJ0NvbnRyb2wgaG93IHBsb3QgaXRlbXMgYXJlIGRpc3BsYXllZCcsXG4gICAgICAgICAgICAgICAgbGF5ZXJfbmFtZTogJ2Fzc29jaWF0aW9uY3JlZGlibGVzZXQnLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRfY29uZmlnX2Rpc3BsYXlfbmFtZTogJ0xpbmthZ2UgRGlzZXF1aWxpYnJpdW0gKGRlZmF1bHQpJywgLy8gZGlzcGxheSBuYW1lIGZvciB0aGUgZGVmYXVsdCBwbG90IGNvbG9yIG9wdGlvbiAoYWxsb3cgdXNlciB0byByZXZlcnQgdG8gcGxvdCBkZWZhdWx0cylcblxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyc3QgZHJvcGRvd24gbWVudSBpdGVtXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5X25hbWU6ICc5NSUgY3JlZGlibGUgc2V0IChib29sZWFuKScsICAvLyBIdW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBmaWVsZCBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiB7ICAvLyBTcGVjaWZ5IGxheW91dCBkaXJlY3RpdmVzIHRoYXQgY29udHJvbCBkaXNwbGF5IG9mIHRoZSBwbG90IGZvciB0aGlzIG9wdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50X3NoYXBlOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludF9zaXplOiA0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ3t7bmFtZXNwYWNlW2NyZWRzZXRdfX1pc19tZW1iZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZV9mdW5jdGlvbjogJ2lmJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRfdmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVuOiAnIzAwQ0MwMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlOiAnI0NDQ0NDQycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWdlbmQ6IFsgLy8gVGVsbHMgdGhlIGxlZ2VuZCBob3cgdG8gcmVwcmVzZW50IHRoaXMgZGlzcGxheSBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICcjMDBDQzAwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDQwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6ICdJbiBjcmVkaWJsZSBzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdsei1kYXRhX2xheWVyLXNjYXR0ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNDQ0NDQ0MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogNDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ05vdCBpbiBjcmVkaWJsZSBzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdsei1kYXRhX2xheWVyLXNjYXR0ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWNvbmQgb3B0aW9uLiBUaGUgc2FtZSBwbG90LSBvciBldmVuIHRoZSBzYW1lIGZpZWxkLSBjYW4gYmUgY29sb3JlZCBpbiBtb3JlIHRoYW4gb25lIHdheS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlfbmFtZTogJzk1JSBjcmVkaWJsZSBzZXQgKGdyYWRpZW50IGJ5IGNvbnRyaWJ1dGlvbiknLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50X3NoYXBlOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludF9zaXplOiA0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZDogJ3t7bmFtZXNwYWNlW2NyZWRzZXRdfX1jb250cmliX2ZyYWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlX2Z1bmN0aW9uOiAnaWYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkX3ZhbHVlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW46ICcjNzc3Nzc3JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlX2Z1bmN0aW9uOiAnaW50ZXJwb2xhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQ6ICd7e25hbWVzcGFjZVtjcmVkc2V0XX19Y29udHJpYl9mcmFjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtzOiBbMCwgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBbJyNmYWZlODcnLCAnIzljMDAwMCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZ2VuZDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyM3Nzc3NzcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogNDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ05vIGNvbnRyaWJ1dGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2x6LWRhdGFfbGF5ZXItc2NhdHRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZhZmU4NycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiA0MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiAnU29tZSBjb250cmlidXRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdsei1kYXRhX2xheWVyLXNjYXR0ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyM5YzAwMDAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogNDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogJ01vc3QgY29udHJpYnV0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnbHotZGF0YV9sYXllci1zY2F0dGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbDtcbiAgICB9KCkpO1xuXG4gICAgTG9jdXNab29tLkxheW91dHMuYWRkKCdwbG90JywgJ2Fzc29jaWF0aW9uX2NyZWRpYmxlX3NldCcsIHtcbiAgICAgICAgc3RhdGU6IHt9LFxuICAgICAgICB3aWR0aDogODAwLFxuICAgICAgICBoZWlnaHQ6IDQ1MCxcbiAgICAgICAgcmVzcG9uc2l2ZV9yZXNpemU6IHRydWUsXG4gICAgICAgIG1pbl9yZWdpb25fc2NhbGU6IDIwMDAwLFxuICAgICAgICBtYXhfcmVnaW9uX3NjYWxlOiAxMDAwMDAwLFxuICAgICAgICB0b29sYmFyOiBMb2N1c1pvb20uTGF5b3V0cy5nZXQoJ3Rvb2xiYXInLCAnc3RhbmRhcmRfYXNzb2NpYXRpb24nLCB7IHVubmFtZXNwYWNlZDogdHJ1ZSB9KSxcbiAgICAgICAgcGFuZWxzOiBbXG4gICAgICAgICAgICBMb2N1c1pvb20uTGF5b3V0cy5nZXQoJ3BhbmVsJywgJ2Fzc29jaWF0aW9uX2NyZWRpYmxlX3NldCcsIHsgdW5uYW1lc3BhY2VkOiB0cnVlIH0pLFxuICAgICAgICAgICAgTG9jdXNab29tLkxheW91dHMuZ2V0KCdwYW5lbCcsICdhbm5vdGF0aW9uX2NyZWRpYmxlX3NldCcsIHsgdW5uYW1lc3BhY2VkOiB0cnVlIH0pLFxuICAgICAgICAgICAgTG9jdXNab29tLkxheW91dHMuZ2V0KCdwYW5lbCcsICdnZW5lcycsIHsgdW5uYW1lc3BhY2VkOiB0cnVlIH0pLFxuICAgICAgICBdLFxuICAgIH0pO1xuXG59XG5cblxuaWYgKHR5cGVvZiBMb2N1c1pvb20gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gQXV0by1yZWdpc3RlciB0aGUgcGx1Z2luIHdoZW4gaW5jbHVkZWQgYXMgYSBzY3JpcHQgdGFnLiBFUzYgbW9kdWxlIHVzZXJzIG11c3QgcmVnaXN0ZXIgdmlhIExvY3VzWm9vbS51c2UoKVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgIExvY3VzWm9vbS51c2UoaW5zdGFsbCk7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgaW5zdGFsbDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZ3dhc0NyZWRpYmxlU2V0czsiXSwic291cmNlUm9vdCI6IiJ9