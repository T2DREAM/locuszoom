{"version":3,"sources":["lz-intervals-track.min.js"],"names":["root","factory","define","amd","LocusZoom","d3","module","exports","require","ext","Data","exported","IntervalLZ","this","l","IntervalSource","Source","extend","init","parseInit","prototype","getURL","state","chain","fields","source","header","bedtracksource","params","url","chr","end","start","Dashboard","Components","add","layout","Component","apply","arguments","data_layer_id","parent_panel","data_layers","Error","update","data_layer","html","split_tracks","button","setHtml","show","parent","position","Button","setColor","color","setTitle","setOnclick","toggleSplitTracks","scale_timeout","clearTimeout","setTimeout","scaleHeightToData","parent_plot","positionPanels","bind","ScaleFunctions","parameters","value","DataLayers","DefaultLayout","start_field","end_field","track_label_field","track_split_field","track_split_order","track_split_legend_to_y_axis","track_height","track_vertical_spacing","bounding_box_padding","always_hide_legend","fill_opacity","tooltip_positioning","Layouts","merge","DataLayer","getElementStatusNodeId","element","getBaseId","replace","getElementId","getTrackHeight","tracks","previous_tracks","interval_track_index","1","_applyLayoutOptions","self","base_layout","_base_layout","render_layout","base_color_scale","find","item","scale_function","color_scale","has_colors","categories","length","values","has_legend","legend","rgb_option","rgb_field","field","known_categories","_generateCategoriesFromData","data","colors","_makeColorScheme","map","pair","index","id","shape","width","label","assignTracks","track_split_field_index","forEach","d","Object","keys","reverse","val","i","display_range","x_scale","Math","max","min","display_domain","invert","track","push","potential_track","collision_on_potential_track","placed_interval","min_start","render","height","x","y","fill","svg","group","selectAll","remove","key","pseudoElement","sharedstatusnode_style","display","insert","attr","cliparea","style","selection","id_field","enter","append","each","interval","statusnode_style","statusnodes","select","exit","rects","resolveScalableParameter","clickareas","interval_name","on","element_data","emit","applyBehaviors","updateSplitTrackAxis","_getTooltipPosition","tooltip","interval_bbox","node","getBBox","x_min","x_max","y_min","y_max","legend_axis","track_spacing","target_height","hide","axes","ticks","range","abs","text","y_axis","axis","floor","ceiling","margin","bottom","category_info","n_categories","unique_ids","idx","hasOwnProperty","namespace","intervals","closable","or","and","type","null_value","behaviors","onmouseover","action","status","onmouseout","onclick","exclusive","onshiftclick","get","unnamespaced","min_width","min_height","top","right","left","dashboard","components","interaction","drag_background_to_pan","scroll_to_zoom","x_linked","hidden","orientation","origin","pad_from_bottom","responsive_resize","min_region_scale","max_region_scale","panels","proportional_height"],"mappings":"AAQA,cAMC,SAAUA,EAAMC,GACb,GAAsB,mBAAXC,QAAyBA,OAAOC,IACvCD,OAAO,CAAC,YAAa,MAAQ,SAASE,EAAWC,GAC7C,OAAOJ,EAAQG,EAAWC,UAE3B,GAAqB,iBAAXC,QAAuBA,OAAOC,QAC3CD,OAAOC,QAAUN,EAAQO,QAAQ,aAAcA,QAAQ,WACpD,CACER,EAAKI,UAAUK,IAAIC,OACpBV,EAAKI,UAAUK,IAAIC,KAAO,IAE9B,IAAIC,EAAWV,EAAQD,EAAKI,UAAWJ,EAAKK,IAC5CL,EAAKI,UAAUK,IAAIC,KAAKE,WAAaD,EAASC,YAZtD,CAcEC,KAAM,SAAST,EAAWC,GAOxB,IAioBYS,EAjoBRC,EAAiBX,EAAUM,KAAKM,OAAOC,OAAO,SAASC,GACvDL,KAAKM,UAAUD,IAChB,cA4qBH,OA1qBAH,EAAeK,UAAUC,OAAS,SAASC,EAAOC,EAAOC,GACrD,IAAIC,EAASF,EAAMG,OAAOC,gBAAkBd,KAAKe,OAAOH,OACxD,OAAOZ,KAAKgB,IAAM,iBAAmBJ,EACjC,uBAAyBH,EAAMQ,IAAM,kBAClBR,EAAMS,IACzB,eAAiBT,EAAMU,OAQ/B5B,EAAU6B,UAAUC,WAAWC,IAAI,sBAAuB,SAASC,GAG/D,GAFAhC,EAAU6B,UAAUI,UAAUC,MAAMzB,KAAM0B,WACrCH,EAAOI,gBAAiBJ,EAAOI,cAAgB,cAC/C3B,KAAK4B,aAAaC,YAAYN,EAAOI,eACtC,MAAM,IAAIG,MAAM,uEAEpB9B,KAAK+B,OAAS,WACV,IAAIC,EAAahC,KAAK4B,aAAaC,YAAYN,EAAOI,eAClDM,EAAOD,EAAWT,OAAOW,aAAe,eAAiB,eAC7D,OAAIlC,KAAKmC,QACLnC,KAAKmC,OAAOC,QAAQH,GACpBjC,KAAKmC,OAAOE,OACZrC,KAAKsC,OAAOC,WACLvC,OAEPA,KAAKmC,OAAS,IAAI5C,EAAU6B,UAAUI,UAAUgB,OAAOxC,MAClDyC,SAASlB,EAAOmB,OAChBN,QAAQH,GACRU,SAAS,4DACTC,WAAW,WACRZ,EAAWa,oBACP7C,KAAK8C,eAAiBC,aAAa/C,KAAK8C,eAC5C9C,KAAK8C,cAAgBE,WAAW,WAC5BhD,KAAK4B,aAAaqB,oBAClBjD,KAAKkD,YAAYC,kBACnBC,KAAKpD,MAAO,GACdA,KAAK+B,UACPqB,KAAKpD,OACJA,KAAK+B,aAYxBxC,EAAU8D,eAAe/B,IAAI,SAAU,SAASgC,EAAYC,GACxD,OAAIA,EACO,OAASA,EAAQ,IAErB,OASXhE,EAAUiE,WAAWlC,IAAI,YAAa,SAASC,GAwf3C,OAtfAvB,KAAKyD,cAAgB,CACjBC,YAAa,QACbC,UAAW,MACXC,kBAAmB,aAKnBC,kBAAmB,WACnBC,kBAAmB,OACnBC,6BAA8B,EAC9B7B,cAAc,EACd8B,aAAc,GACdC,uBAAwB,EACxBC,qBAAsB,EACtBC,oBAAoB,EACpBzB,MAAO,UACP0B,aAAc,EACdC,oBAAqB,YAEzB9C,EAAShC,EAAU+E,QAAQC,MAAMhD,EAAQvB,KAAKyD,eAG9ClE,EAAUiF,UAAU/C,MAAMzB,KAAM0B,WAQhC1B,KAAKyE,uBAAyB,SAASC,GACnC,OAAI1E,KAAKuB,OAAOW,cACJlC,KAAK2E,YAAc,eAAiBD,EAAQ1E,KAAKuB,OAAOsC,oBAAoBe,QAAQ,SAAU,KAEnG5E,KAAK6E,aAAaH,GAAW,eACtCtB,KAAKpD,MAGPA,KAAK8E,eAAiB,WAClB,OAAO9E,KAAKuB,OAAOyC,aACbhE,KAAKuB,OAAO0C,uBACX,EAAIjE,KAAKuB,OAAO2C,sBAG3BlE,KAAK+E,OAAS,EACd/E,KAAKgF,gBAAkB,EAGvBhF,KAAKiF,qBAAuB,CAAEC,EAAG,IAIjClF,KAAKmF,oBAAsB,WACvB,IAAIC,EAAOpF,KACPqF,EAAcrF,KAAKsF,aACnBC,EAAgBvF,KAAKuB,OACrBiE,EAAmBH,EAAY3C,MAAM+C,KAAK,SAAUC,GACpD,OAAOA,EAAKC,gBAA0C,oBAAxBD,EAAKC,iBAEnCC,EAAcL,EAAc7C,MAAM+C,KAAK,SAAUC,GACjD,OAAOA,EAAKC,gBAA0C,oBAAxBD,EAAKC,iBAEvC,IAAKH,EAED,MAAM,IAAI1D,MAAM,+DAGpB,IAAI+D,EAAaL,EAAiBlC,WAAWwC,WAAWC,QAAUP,EAAiBlC,WAAW0C,OAAOD,OACjGE,EAAaZ,EAAYa,QAAUb,EAAYa,OAAOH,OAE1D,KAAMF,IAAeI,EAEjB,MAAM,IAAInE,MAAM,wFAIpB,IAAIqE,EAAad,EAAY3C,MAAM+C,KAAK,SAAUC,GAC9C,OAAOA,EAAKC,gBAA0C,WAAxBD,EAAKC,iBAEnCS,EAAYD,GAAcA,EAAWE,MAGrCC,EAAmBtG,KAAKuG,4BAA4BvG,KAAKwG,KAAMJ,GAEnE,IAAKP,IAAeI,EAAY,CAI5B,IAAIQ,EAASzG,KAAK0G,iBAAiBJ,GACnCV,EAAYtC,WAAWwC,WAAaQ,EAAiBK,IAAI,SAAUjB,GAAQ,OAAOA,EAAK,KACvFE,EAAYtC,WAAW0C,OAASS,EAEhCzG,KAAKuB,OAAO2E,OAASI,EAAiBK,IAAI,SAAUC,EAAMC,GACtD,IAAIC,EAAKF,EAAK,GAGVlB,EAAO,CAAEqB,MAAO,OAAQC,MAAO,EAAGC,MAF1BL,EAAK,GAEmClE,MADnCkD,EAAYtC,WAAW0C,OAAOa,IAG/C,OADAnB,EAAKN,EAAK7D,OAAOsC,mBAAqBiD,EAC/BpB,MAGjBtC,KAAKpD,MAIPA,KAAKkH,aAAe,WAchB,GAZAlH,KAAKmF,sBAGLnF,KAAKgF,gBAAkBhF,KAAK+E,OAC5B/E,KAAK+E,OAAS,EACd/E,KAAKiF,qBAAuB,CAAEC,EAAG,IAEjClF,KAAKmH,wBAA0B,GAK3BnH,KAAKuB,OAAOsC,mBAAqB7D,KAAKuB,OAAOW,aAAc,CAC3DlC,KAAKwG,KAAKY,QAAQ,SAASC,GACvBrH,KAAKmH,wBAAwBE,EAAErH,KAAKuB,OAAOsC,oBAAsB,MACnET,KAAKpD,OACP,IAAI6G,EAAQS,OAAOC,KAAKvH,KAAKmH,yBACS,SAAlCnH,KAAKuB,OAAOuC,mBAAgC+C,EAAMW,UACtDX,EAAMO,QAAQ,SAASK,GACnBzH,KAAKmH,wBAAwBM,GAAOzH,KAAK+E,OAAS,EAClD/E,KAAKiF,qBAAqBjF,KAAK+E,OAAS,GAAK,GAC7C/E,KAAK+E,UACP3B,KAAKpD,OAiEX,OA9DAA,KAAKwG,KAAKY,QAAQ,SAASC,EAAGK,GAwB1B,IArBA1H,KAAKwG,KAAKkB,GAAGpF,OAAStC,MAIjBwG,KAAKkB,GAAGC,cAAgB,CACzBxG,MAAOnB,KAAKsC,OAAOsF,QAAQC,KAAKC,IAAIT,EAAErH,KAAKuB,OAAOmC,aAAc1D,KAAKS,MAAMU,QAC3ED,IAAOlB,KAAKsC,OAAOsF,QAAQC,KAAKE,IAAIV,EAAErH,KAAKuB,OAAOoC,WAAY3D,KAAKS,MAAMS,OAE7ElB,KAAKwG,KAAKkB,GAAGC,cAAcX,MAAQhH,KAAKwG,KAAKkB,GAAGC,cAAczG,IAAMlB,KAAKwG,KAAKkB,GAAGC,cAAcxG,MAI/FnB,KAAKwG,KAAKkB,GAAGM,eAAiB,CAC1B7G,MAAOnB,KAAKsC,OAAOsF,QAAQK,OAAOjI,KAAKwG,KAAKkB,GAAGC,cAAcxG,OAC7DD,IAAOlB,KAAKsC,OAAOsF,QAAQK,OAAOjI,KAAKwG,KAAKkB,GAAGC,cAAczG,MAEjElB,KAAKwG,KAAKkB,GAAGM,eAAehB,MAAQhH,KAAKwG,KAAKkB,GAAGM,eAAe9G,IAAMlB,KAAKwG,KAAKkB,GAAGM,eAAe7G,MAK9FnB,KAAKuB,OAAOsC,mBAAqB7D,KAAKuB,OAAOW,aAAc,CAC3D,IAAIuF,EAAMzH,KAAKwG,KAAKkB,GAAG1H,KAAKuB,OAAOsC,mBACnC7D,KAAKwG,KAAKkB,GAAGQ,MAAQlI,KAAKmH,wBAAwBM,GAClDzH,KAAKiF,qBAAqBjF,KAAKwG,KAAKkB,GAAGQ,OAAOC,KAAKT,OAChD,CAIH1H,KAAK+E,OAAS,EACd/E,KAAKwG,KAAKkB,GAAGQ,MAAQ,KAErB,IADA,IAAIE,EAAkB,EACQ,OAAvBpI,KAAKwG,KAAKkB,GAAGQ,OAAgB,CAChC,IAAIG,GAA+B,EACnCrI,KAAKiF,qBAAqBmD,GAAiBzB,IAAI,SAAS2B,GACpD,IAAKD,EAA8B,CAC/B,IAAIE,EAAYV,KAAKE,IAAIO,EAAgBX,cAAcxG,MAAOnB,KAAK2H,cAAcxG,OACnE0G,KAAKC,IAAIQ,EAAgBX,cAAczG,IAAKlB,KAAK2H,cAAczG,KAC9DqH,EAAcD,EAAgBX,cAAcX,MAAQhH,KAAK2H,cAAcX,QAClFqB,GAA+B,KAGzCjF,KAAKpD,KAAKwG,KAAKkB,KACZW,IAIDD,EACsBpI,KAAK+E,SACvB/E,KAAK+E,OAASqD,EACdpI,KAAKiF,qBAAqBmD,GAAmB,KANjDpI,KAAKwG,KAAKkB,GAAGQ,MAAQE,EACrBpI,KAAKiF,qBAAqBmD,GAAiBD,KAAKnI,KAAKwG,KAAKkB,QAYxEtE,KAAKpD,OAEAA,MAIXA,KAAKwI,OAAS,WAwBV,IAAIxB,EAAOyB,EAAQC,EAAGC,EAAGC,EAAMxE,EAvB/BpE,KAAKkH,eAKLlH,KAAK6I,IAAIC,MAAMC,UAAU,sEAAsEC,SAC/F1B,OAAOC,KAAKvH,KAAKmH,yBAAyBC,QAAQ,SAAS6B,GAEvD,IAAIC,EAAgB,GACpBA,EAAclJ,KAAKuB,OAAOsC,mBAAqBoF,EAE/C,IAAIE,EAAyB,CAACC,QAAUpJ,KAAKuB,OAAOW,aAAe,KAAO,QAC1ElC,KAAK6I,IAAIC,MAAMO,OAAO,OAAQ,gBACzBC,KAAK,KAAMtJ,KAAKyE,uBAAuByE,IACvCI,KAAK,QAAS,6FACdA,KAAK,KAAMtJ,KAAKuB,OAAO2C,sBAAsBoF,KAAK,KAAMtJ,KAAKuB,OAAO2C,sBACpEoF,KAAK,QAAStJ,KAAKsC,OAAOf,OAAOgI,SAASvC,OAC1CsC,KAAK,SAAUtJ,KAAK8E,iBAAmB9E,KAAKuB,OAAO0C,wBACnDqF,KAAK,IAAK,GACVA,KAAK,KAAMtJ,KAAKmH,wBAAwB8B,GAAO,GAAKjJ,KAAK8E,kBACzD0E,MAAML,IACb/F,KAAKpD,OAKP,IAAIyJ,EAAYzJ,KAAK6I,IAAIC,MAAMC,UAAU,6BACpCvC,KAAKxG,KAAKwG,KAAM,SAASa,GAAK,OAAOA,EAAErH,KAAKuB,OAAOmI,WAAatG,KAAKpD,OA4I1E,OA1IAyJ,EAAUE,QAAQC,OAAO,KACpBN,KAAK,QAAS,2BAEnBG,EAAUH,KAAK,KAAM,SAASjC,GAAK,OAAOrH,KAAK6E,aAAawC,IAAMjE,KAAKpD,OAClE6J,KAAK,SAASC,GAEX,IAAI9H,EAAa8H,EAASxH,OAItByH,EAAmB,CAACX,QAAUpH,EAAWT,OAAOW,aAAe,OAAS,MACxE8H,EAAcxK,EAAGyK,OAAOjK,MAAM+I,UAAU,+GACvCvC,KAAK,CAACsD,GAAW,SAASzC,GAAK,OAAOrF,EAAW6C,aAAawC,GAAK,gBACxE2C,EAAYL,QAAQN,OAAO,OAAQ,gBAC9BC,KAAK,QAAS,0GACnBU,EACKV,KAAK,KAAM,SAASjC,GACjB,OAAOrF,EAAW6C,aAAawC,GAAK,gBAEvCiC,KAAK,KAAM,WACR,OAAOtH,EAAWT,OAAO2C,uBAE5BoF,KAAK,KAAM,WACR,OAAOtH,EAAWT,OAAO2C,uBAE5BsF,MAAMO,GACX/C,EAAQ,SAASK,GACb,OAAOA,EAAEM,cAAcX,MAAS,EAAIhF,EAAWT,OAAO2C,sBAE1DuE,EAAS,WACL,OAAOzG,EAAW8C,iBAAmB9C,EAAWT,OAAO0C,wBAE3DyE,EAAI,SAASrB,GACT,OAAOA,EAAEM,cAAcxG,MAAQa,EAAWT,OAAO2C,sBAErDyE,EAAI,SAAStB,GACT,OAASA,EAAEa,MAAQ,GAAKlG,EAAW8C,kBAGvCkF,EACKV,KAAK,QAAStC,GAAOsC,KAAK,SAAUb,GAAQa,KAAK,IAAKZ,GAAGY,KAAK,IAAKX,GAExEqB,EAAYE,OAAOlB,SAGnB,IAAImB,EAAQ3K,EAAGyK,OAAOjK,MAAM+I,UAAU,iDACjCvC,KAAK,CAACsD,GAAW,SAASzC,GAAK,OAAOA,EAAErF,EAAWT,OAAOmI,UAAY,mBAE3ES,EAAMR,QAAQC,OAAO,QAChBN,KAAK,QAAS,4CAEnBb,EAASzG,EAAWT,OAAOyC,aAC3BgD,EAAQ,SAASK,GACb,OAAOA,EAAEM,cAAcX,OAE3B0B,EAAI,SAASrB,GACT,OAAOA,EAAEM,cAAcxG,OAE3BwH,EAAI,SAAStB,GACT,OAASA,EAAEa,MAAQ,GAAKlG,EAAW8C,iBAC7B9C,EAAWT,OAAO2C,sBAE5B0E,EAAO,SAASvB,EAAGK,GACf,OAAO1F,EAAWoI,yBAAyBpI,EAAWT,OAAOmB,MAAO2E,EAAGK,IAE3EtD,EAAe,SAASiD,EAAGK,GACvB,OAAO1F,EAAWoI,yBAAyBpI,EAAWT,OAAO6C,aAAciD,EAAGK,IAGlFyC,EACKb,KAAK,QAAStC,GAAOsC,KAAK,SAAUb,GACpCa,KAAK,IAAKZ,GAAGY,KAAK,IAAKX,GACvBW,KAAK,OAAQV,GACbU,KAAK,eAAgBlF,GAE1B+F,EAAMD,OAAOlB,SAGb,IAAIqB,EAAa7K,EAAGyK,OAAOjK,MAAM+I,UAAU,6CACtCvC,KAAK,CAACsD,GAAW,SAASzC,GAAK,OAAOA,EAAEiD,cAAgB,eAE7DD,EAAWV,QAAQC,OAAO,QACrBN,KAAK,QAAS,wCAEnBe,EACKf,KAAK,KAAM,SAASjC,GACjB,OAAOrF,EAAW6C,aAAawC,GAAK,eAEvCiC,KAAK,KAAM,WACR,OAAOtH,EAAWT,OAAO2C,uBAE5BoF,KAAK,KAAM,WACR,OAAOtH,EAAWT,OAAO2C,uBAGjC8C,EAAQ,SAASK,GACb,OAAOA,EAAEM,cAAcX,OAE3ByB,EAAS,WACL,OAAOzG,EAAW8C,iBAAmB9C,EAAWT,OAAO0C,wBAE3DyE,EAAI,SAASrB,GACT,OAAOA,EAAEM,cAAcxG,OAE3BwH,EAAI,SAAStB,GACT,OAASA,EAAEa,MAAQ,GAAKlG,EAAW8C,kBAGvCuF,EACKf,KAAK,QAAStC,GAAOsC,KAAK,SAAUb,GAAQa,KAAK,IAAKZ,GAAGY,KAAK,IAAKX,GAGxE0B,EAAWH,OAAOlB,SAGlBqB,EAAWE,GAAG,QAAS,SAASC,GAC5BA,EAAalI,OAAOA,OAAOmI,KAAK,kBAAmBD,GAAc,IACnEpH,KAAKpD,OAGPgC,EAAW0I,eAAeL,KAKlCZ,EAAUS,OAAOlB,SAGbhJ,KAAKgF,kBAAoBhF,KAAK+E,QAC9B/E,KAAK2K,uBAKL3K,KAAKsC,QAAUtC,KAAKsC,OAAO4D,QAC3BlG,KAAKsC,OAAO4D,OAAOsC,SAGhBxI,MAGXA,KAAK4K,oBAAsB,SAAUC,GACjC,IAAIC,EAAgBtL,EAAGyK,OAAO,IAAMjK,KAAKyE,uBAAuBoG,EAAQrE,OAAOuE,OAAOC,UACtF,MAAO,CACHC,MAAOJ,EAAQrE,KAAKmB,cAAcxG,MAClC+J,MAAOL,EAAQrE,KAAKmB,cAAczG,IAClCiK,MAAOL,EAAcnC,EACrByC,MAAON,EAAcnC,EAAImC,EAAcrC,SAM/CzI,KAAK2K,qBAAuB,WACxB,IAAIU,IAAcrL,KAAKuB,OAAOwC,8BAA+B,IAAM/D,KAAKuB,OAAOwC,6BAC/E,GAAI/D,KAAKuB,OAAOW,aAAc,CAC1B,IAAI6C,GAAU/E,KAAK+E,QAAU,EACzBf,GAAgBhE,KAAKuB,OAAOyC,cAAgB,EAC5CsH,EAAiB,IAAMtL,KAAKuB,OAAO2C,sBAAwB,KAAOlE,KAAKuB,OAAO0C,wBAA0B,GACxGsH,EAAiBxG,EAASf,GAAkBe,EAAS,GAAKuG,EAC9DtL,KAAKsC,OAAOW,kBAAkBsI,GAC1BF,GAAerL,KAAKsC,OAAO4D,SAC3BlG,KAAKsC,OAAO4D,OAAOsF,OACnBxL,KAAKsC,OAAOf,OAAOkK,KAAKJ,GAAe,CACnC7C,QAAQ,EACRkD,MAAO,GACPC,MAAO,CACHxK,MAAQoK,EAAiBvL,KAAKuB,OAAOyC,aAAe,EACpD9C,IAAMlB,KAAKuB,OAAOyC,aAAe,IAMzChE,KAAKuB,OAAO2E,OAAOkB,QAAQ,SAAS1C,GAChC,IAAIuE,EAAMvE,EAAQ1E,KAAKuB,OAAOsC,mBAC1BqE,EAAQlI,KAAKmH,wBAAwB8B,GACrCf,IACsC,SAAlClI,KAAKuB,OAAOuC,oBACZoE,EAAQL,KAAK+D,IAAI1D,EAAQnD,EAAS,IAEtC/E,KAAKsC,OAAOf,OAAOkK,KAAKJ,GAAaK,MAAMvD,KAAK,CAC5CQ,EAAGT,EACH2D,KAAMnH,EAAQuC,UAGxB7D,KAAKpD,OACPA,KAAKuB,OAAOuK,OAAS,CACjBC,KAAM/L,KAAKuB,OAAOwC,6BAClBiI,MAAO,EACPC,QAASlH,GAEb/E,KAAKsC,OAAOkG,UAEhBxI,KAAKkD,YAAYC,sBAEbkI,GAAerL,KAAKsC,OAAO4D,SACtBlG,KAAKuB,OAAO4C,oBAAsBnE,KAAKsC,OAAO4D,OAAO7D,OAC1DrC,KAAKsC,OAAOf,OAAOkK,KAAKJ,GAAe,CAAE7C,QAAQ,GACjDxI,KAAKsC,OAAOkG,UAGpB,OAAOxI,MAKXA,KAAK6C,kBAAoB,WAOrB,OANA7C,KAAKuB,OAAOW,cAAgBlC,KAAKuB,OAAOW,aACpClC,KAAKsC,OAAO4D,SAAWlG,KAAKuB,OAAO4C,qBACnCnE,KAAKsC,OAAOf,OAAO2K,OAAOC,OAAS,GAAKnM,KAAKuB,OAAOW,aAAe,EAAIlC,KAAKsC,OAAO4D,OAAO3E,OAAOkH,OAAS,IAE9GzI,KAAKwI,SACLxI,KAAK2K,uBACE3K,MAKXA,KAAK0G,iBAAmB,SAAS0F,GAG7B,GAD0BA,EAAc3G,KAAK,SAAUC,GAAQ,OAAOA,EAAK,KAEvE,OAAO0G,EAAczF,IAAI,SAAUjB,GAAQ,OAAOA,EAAK,KAO3D,IAAI2G,EAAeD,EAAcrG,OACjC,OAAIsG,GAAgB,GACT,CAAC,mBAAoB,mBAAoB,mBAAoB,mBAAoB,mBAAoB,iBAAkB,mBAAoB,mBAAoB,iBAAkB,iBAAkB,eAAgB,eAAgB,iBAAkB,gBAAiB,gBACtQA,GAAgB,GAChB,CAAC,mBAAoB,mBAAoB,mBAAoB,mBAAoB,iBAAkB,mBAAoB,mBAAoB,iBAAkB,kBAAmB,kBAAmB,iBAAkB,iBAAkB,eAAgB,eAAgB,gBAAiB,gBAAiB,gBAAiB,gBAG1T,CAAC,mBAAoB,mBAAoB,kBAAmB,mBAAoB,mBAAoB,mBAAoB,mBAAoB,iBAAkB,iBAAkB,iBAAkB,kBAAmB,kBAAmB,kBAAmB,iBAAkB,iBAAkB,iBAAkB,iBAAkB,eAAgB,eAAgB,eAAgB,eAAgB,gBAAiB,gBAAiB,gBAAiB,iBAWrcrM,KAAKuG,4BAA8B,SAAUC,EAAMJ,GAC/C,IAAIhB,EAAOpF,KAEPkG,EAASlG,KAAKsF,aAAaY,OAC/B,GAAIA,GAAUA,EAAOH,OACjB,OAAOG,EAAOS,IAAI,SAAUjB,GACxB,MAAO,CAACA,EAAKN,EAAK7D,OAAOsC,mBAAoB6B,EAAKuB,MAAOvB,EAAKhD,SAKtE,IAAI4J,EAAa,GACbxG,EAAa,GAUjB,OARAU,EAAKY,QAAQ,SAAU1B,EAAM6G,GACzB,IAAIzF,EAAKpB,EAAKN,EAAK7D,OAAOsC,mBACrByI,EAAWE,eAAe1F,KAC3BwF,EAAWxF,GAAM,KAEjBhB,EAAWqC,KAAK,CAACrB,EAAIpB,EAAKN,EAAK7D,OAAOqC,mBAAoB8B,EAAKU,QAGhEN,GACT1C,KAAKpD,MAEAA,OAIXT,EAAU+E,QAAQhD,IAAI,UAAW,qBAAsB,CACnDmL,UAAW,CAAEC,UAAa,aAC1BC,UAAU,EACVtK,KAAM,CAAEuK,GAAI,CAAC,cAAe,aAC5BpB,KAAM,CAAEqB,IAAK,CAAC,gBAAiB,eAC/B5K,KAAM,iJAGV1C,EAAU+E,QAAQhD,IAAI,aAAc,YAAa,CAC7CmL,UAAW,CAAEC,UAAa,aAC1B5F,GAAI,YACJgG,KAAM,YACNnM,OAAQ,CAAC,gCAAiC,8BAA+B,mCAAoC,qCAAsC,mCACnJ+I,SAAU,gCACVhG,YAAa,gCACbC,UAAW,8BACXE,kBAAmB,qCACnBD,kBAAmB,qCACnB1B,cAAc,EACdiC,oBAAoB,EACpBzB,MAAO,CACH,CAEI2D,MAAO,kCACPV,eAAgB,UAEpB,CACIU,MAAO,qCACPV,eAAgB,kBAChBrC,WAAY,CAERwC,WAAY,GACZE,OAAQ,GACR+G,WAAY,aAIxB7G,OAAQ,GACR8G,UAAW,CACPC,YAAa,CACT,CAAEC,OAAQ,MAAOC,OAAQ,gBAE7BC,WAAY,CACR,CAAEF,OAAQ,QAASC,OAAQ,gBAE/BE,QAAS,CACL,CAAEH,OAAQ,SAAUC,OAAQ,WAAYG,WAAW,IAEvDC,aAAc,CACV,CAAEL,OAAQ,SAAUC,OAAQ,cAGpCtC,QAAStL,EAAU+E,QAAQkJ,IAAI,UAAW,qBAAsB,CAAEC,cAAc,MAGpFlO,EAAU+E,QAAQhD,IAAI,QAAS,YAAa,CACxCwF,GAAI,YACJE,MAAO,IACPyB,OAAQ,GACRiF,UAAW,IACXC,WAAY,GACZzB,OAAQ,CAAE0B,IAAK,GAAIC,MAAO,IAAK1B,OAAQ,EAAG2B,KAAM,IAChDC,WACQ9N,EAAIV,EAAU+E,QAAQkJ,IAAI,YAAa,iBAAkB,CAAEC,cAAc,IAC7ExN,EAAE+N,WAAW7F,KAAK,CACd2E,KAAM,sBACNnL,cAAe,YACfY,SAAU,UAEPtC,GAEXwL,KAAM,GACNwC,YAAa,CACTC,wBAAwB,EACxBC,gBAAgB,EAChBC,UAAU,GAEdlI,OAAQ,CACJmI,QAAQ,EACRC,YAAa,aACbC,OAAQ,CAAE7F,EAAG,GAAIC,EAAG,GACpB6F,gBAAiB,GAErB3M,YAAa,CACTtC,EAAU+E,QAAQkJ,IAAI,aAAc,YAAa,CAAEC,cAAc,OAIzElO,EAAU+E,QAAQhD,IAAI,OAAQ,uBAAwB,CAClDb,MAAO,GACPuG,MAAO,IACPyB,OAAQ,IACRgG,kBAAmB,OACnBC,iBAAkB,IAClBC,iBAAkB,IAClBZ,UAAWxO,EAAU+E,QAAQkJ,IAAI,YAAa,gBAAiB,CAAEC,cAAc,IAC/EmB,OAAQ,CACJrP,EAAU+E,QAAQkJ,IAAI,QAAS,cAAe,CAC1CC,cAAc,EACdzG,MAAO,IACP6H,oBAAsB,IAAM,MAEhCtP,EAAU+E,QAAQkJ,IAAI,QAAS,YAAa,CAAEC,cAAc,EAAMoB,oBAAsB,IAAM,MAC9FtP,EAAU+E,QAAQkJ,IAAI,QAAS,QAAS,CAAEC,cAAc,EAAMzG,MAAO,IAAK6H,oBAAsB,IAAM,SAKvG,CAAE9O,WAAYG","file":"lz-intervals-track.min.js","sourcesContent":["/*\n    Interval annotation track (for chromatin state, etc). Useful for BED file data with non-overlapping intervals.\n    This is not part of the core LocusZoom library, but can be included as a standalone file.\n\n    The page must incorporate and load all libraries before this file can be used, including:\n     - Vendor assets\n     - LocusZoom\n*/\n'use strict';\n\n// This is defined as a UMD module, to work with multiple different module systems / bundlers\n// Arcane build note: everything defined here gets registered globally. This is not a \"pure\" module, and some build\n//  systems may require being told that this file has side effects.\n/* global define, module, require */\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(['locuszoom', 'd3'] , function(LocusZoom, d3) {  // amd\n            return factory(LocusZoom, d3);\n        });\n    } else if(typeof module === 'object' && module.exports) {  // commonJS\n        module.exports = factory(require('locuszoom'), require('d3'));\n    } else {  // globals\n        if (!root.LocusZoom.ext.Data) {\n            root.LocusZoom.ext.Data = {};\n        }\n        var exported = factory(root.LocusZoom, root.d3);\n        root.LocusZoom.ext.Data.IntervalLZ = exported.IntervalLZ;\n    }\n}(this, function(LocusZoom, d3) {\n    /**\n     * Data Source for Interval Annotation Data (e.g. BED Tracks), as fetched from the LocusZoom API server (or compatible)\n     * @public\n     * @class\n     * @augments LocusZoom.Data.Source\n     */\n    var IntervalSource = LocusZoom.Data.Source.extend(function(init) {\n        this.parseInit(init);\n    }, 'IntervalLZ');\n\n    IntervalSource.prototype.getURL = function(state, chain, fields) {\n        var source = chain.header.bedtracksource || this.params.source;\n        return this.url + '?filter=id in ' + source +\n            \" and chromosome eq '\" + state.chr + \"'\" +\n            ' and start le ' + state.end +\n            ' and end ge ' + state.start;\n    };\n\n    /**\n     * Button to toggle split tracks\n     * @class LocusZoom.Dashboard.Components.toggle_split_tracks\n     * @augments LocusZoom.Dashboard.Component\n     */\n    LocusZoom.Dashboard.Components.add('toggle_split_tracks', function(layout) {\n        LocusZoom.Dashboard.Component.apply(this, arguments);\n        if (!layout.data_layer_id) { layout.data_layer_id = 'intervals'; }\n        if (!this.parent_panel.data_layers[layout.data_layer_id]) {\n            throw new Error('Dashboard toggle split tracks component missing valid data layer ID');\n        }\n        this.update = function() {\n            var data_layer = this.parent_panel.data_layers[layout.data_layer_id];\n            var html = data_layer.layout.split_tracks ? 'Merge Tracks' : 'Split Tracks';\n            if (this.button) {\n                this.button.setHtml(html);\n                this.button.show();\n                this.parent.position();\n                return this;\n            } else {\n                this.button = new LocusZoom.Dashboard.Component.Button(this)\n                    .setColor(layout.color)\n                    .setHtml(html)\n                    .setTitle('Toggle whether tracks are split apart or merged together')\n                    .setOnclick(function() {\n                        data_layer.toggleSplitTracks();\n                        if (this.scale_timeout) { clearTimeout(this.scale_timeout); }\n                        this.scale_timeout = setTimeout(function() {\n                            this.parent_panel.scaleHeightToData();\n                            this.parent_plot.positionPanels();\n                        }.bind(this), 0);\n                        this.update();\n                    }.bind(this));\n                return this.update();\n            }\n        };\n    });\n\n    /**\n     * Convert a value \"\"rr,gg,bb\" (if given) to a css-friendly color string: \"rgb(rr,gg,bb)\".\n     * This is tailored specifically to the color specification format embraced by the BED file standard.\n     * @function to_rgb\n     * @param {Object} parameters This function has no defined configuration options\n     * @param {String|null} value The value to convert to rgb\n     */\n    LocusZoom.ScaleFunctions.add('to_rgb', function(parameters, value) {\n        if (value) {\n            return 'rgb(' + value + ')';\n        }\n        return null;\n    });\n\n    /**\n     * Intervals Data Layer\n     * Implements a data layer that will render interval annotation tracks (intervals must provide start and end values)\n     * @class LocusZoom.DataLayers.intervals\n     * @augments LocusZoom.DataLayer\n     */\n    LocusZoom.DataLayers.add('intervals', function(layout) {\n        // Define a default layout for this DataLayer type and merge it with the passed argument\n        this.DefaultLayout = {\n            start_field: 'start',\n            end_field: 'end',\n            track_label_field: 'state_name', // Used to label items on the y-axis\n            // Used to uniquely identify tracks for coloring. This tends to lead to more stable coloring/sorting\n            //  than using the label field- eg, state_ids allow us to set global colors across the entire dataset,\n            //  not just choose unique colors within a particular narrow region. (where changing region might lead to more\n            //  categories and different colors)\n            track_split_field: 'state_id',\n            track_split_order: 'DESC',\n            track_split_legend_to_y_axis: 2,\n            split_tracks: true,\n            track_height: 15,\n            track_vertical_spacing: 3,\n            bounding_box_padding: 2,\n            always_hide_legend: false,\n            color: '#B8B8B8',\n            fill_opacity: 1,\n            tooltip_positioning: 'vertical',\n        };\n        layout = LocusZoom.Layouts.merge(layout, this.DefaultLayout);\n\n        // Apply the arguments to set LocusZoom.DataLayer as the prototype\n        LocusZoom.DataLayer.apply(this, arguments);\n\n        /**\n         * To define shared highlighting on the track split field define the status node id override\n         * to generate an ID common to the track when we're actively splitting data out to separate tracks\n         * @override\n         * @returns {String}\n         */\n        this.getElementStatusNodeId = function(element) {\n            if (this.layout.split_tracks) {\n                return (this.getBaseId() + '-statusnode-' + element[this.layout.track_split_field]).replace(/[^\\w]/g, '_');\n            }\n            return this.getElementId(element) + '-statusnode';\n        }.bind(this);\n\n        // Helper function to sum layout values to derive total height for a single interval track\n        this.getTrackHeight = function() {\n            return this.layout.track_height\n                + this.layout.track_vertical_spacing\n                + (2 * this.layout.bounding_box_padding);\n        };\n\n        this.tracks = 1;\n        this.previous_tracks = 1;\n\n        // track-number-indexed object with arrays of interval indexes in the dataset\n        this.interval_track_index = { 1: [] };\n\n        // Modify the layout as necessary to ensure that appropriate color, label, and legend options are available\n        // Even when not displayed, the legend is used to generate the y-axis ticks\n        this._applyLayoutOptions = function () {\n            var self = this;\n            var base_layout = this._base_layout;\n            var render_layout = this.layout;\n            var base_color_scale = base_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'categorical_bin';\n            });\n            var color_scale = render_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'categorical_bin';\n            });\n            if (!base_color_scale) {\n                // This can be a placeholder (empty categories & values), but it needs to be there\n                throw new Error('Interval tracks must define a `categorical_bin` color scale');\n            }\n\n            var has_colors = base_color_scale.parameters.categories.length && base_color_scale.parameters.values.length;\n            var has_legend = base_layout.legend && base_layout.legend.length;\n\n            if (!!has_colors ^ !!has_legend) {\n                // Don't allow color OR legend to be set manually. It must be both, or neither.\n                throw new Error('To use a manually specified color scheme, both color and legend options must be set.');\n            }\n\n            // Harvest any information about an explicit color field that should be considered when generating colors\n            var rgb_option = base_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'to_rgb';\n            });\n            var rgb_field = rgb_option && rgb_option.field;\n\n            // Auto-generate legend based on data\n            var known_categories = this._generateCategoriesFromData(this.data, rgb_field); // [id, label, itemRgb] items\n\n            if (!has_colors && !has_legend) {\n                // If no color scheme pre-defined, then make a color scheme that is appropriate and apply to the plot\n                // The legend must match the color scheme. If we generate one, then we must generate both.\n\n                var colors = this._makeColorScheme(known_categories);\n                color_scale.parameters.categories = known_categories.map(function (item) { return item[0]; });\n                color_scale.parameters.values = colors;\n\n                this.layout.legend = known_categories.map(function (pair, index) {\n                    var id = pair[0];\n                    var label = pair[1];\n                    var item_color = color_scale.parameters.values[index];\n                    var item = { shape: 'rect', width: 9, label: label, color:  item_color };\n                    item[self.layout.track_split_field] = id;\n                    return item;\n                });\n            }\n        }.bind(this);\n\n        // After we've loaded interval data interpret it to assign\n        // each to a track so that they do not overlap in the view\n        this.assignTracks = function() {\n            // Autogenerate layout options if not provided\n            this._applyLayoutOptions();\n\n            // Reinitialize some metadata\n            this.previous_tracks = this.tracks;\n            this.tracks = 0;\n            this.interval_track_index = { 1: [] };\n            // This maps unique values of track_split_field to unique y indices. It controls the ordering of separate tracks.\n            this.track_split_field_index = {};\n\n            // If splitting tracks by a field's value then determine how to order them. There are two options here:\n            // a) numeric IDs get sorted in numeric order (JS quirk: int object keys act like array indices), or\n            // b) text labels get sorted based on order in the source data (hash preserves insertion order)\n            if (this.layout.track_split_field && this.layout.split_tracks) {\n                this.data.forEach(function(d) {\n                    this.track_split_field_index[d[this.layout.track_split_field]] = null;\n                }.bind(this));\n                var index = Object.keys(this.track_split_field_index);\n                if (this.layout.track_split_order === 'DESC') { index.reverse(); }\n                index.forEach(function(val) {\n                    this.track_split_field_index[val] = this.tracks + 1;\n                    this.interval_track_index[this.tracks + 1] = [];\n                    this.tracks++;\n                }.bind(this));\n            }\n\n            this.data.forEach(function(d, i) {\n\n                // Stash a parent reference on the interval\n                this.data[i].parent = this;\n\n                // Determine display range start and end, based on minimum allowable interval display width,\n                // bounded by what we can see (range: values in terms of pixels on the screen)\n                this.data[i].display_range = {\n                    start: this.parent.x_scale(Math.max(d[this.layout.start_field], this.state.start)),\n                    end:   this.parent.x_scale(Math.min(d[this.layout.end_field], this.state.end))\n                };\n                this.data[i].display_range.width = this.data[i].display_range.end - this.data[i].display_range.start;\n\n                // Convert and stash display range values into domain values\n                // (domain: values in terms of the data set, e.g. megabases)\n                this.data[i].display_domain = {\n                    start: this.parent.x_scale.invert(this.data[i].display_range.start),\n                    end:   this.parent.x_scale.invert(this.data[i].display_range.end)\n                };\n                this.data[i].display_domain.width = this.data[i].display_domain.end - this.data[i].display_domain.start;\n\n                // If splitting to tracks based on the value of the designated track split field\n                // then don't bother with collision detection (intervals will be grouped on tracks\n                // solely by the value of track_split_field)\n                if (this.layout.track_split_field && this.layout.split_tracks) {\n                    var val = this.data[i][this.layout.track_split_field];\n                    this.data[i].track = this.track_split_field_index[val];\n                    this.interval_track_index[this.data[i].track].push(i);\n                } else {\n                    // If not splitting to tracks based on a field value then do so based on collision\n                    // detection (as how it's done for genes). Use display range/domain data generated\n                    // above and cast each interval to tracks such that none overlap\n                    this.tracks = 1;\n                    this.data[i].track = null;\n                    var potential_track = 1;\n                    while (this.data[i].track === null) {\n                        var collision_on_potential_track = false;\n                        this.interval_track_index[potential_track].map(function(placed_interval) {\n                            if (!collision_on_potential_track) {\n                                var min_start = Math.min(placed_interval.display_range.start, this.display_range.start);\n                                var max_end = Math.max(placed_interval.display_range.end, this.display_range.end);\n                                if ((max_end - min_start) < (placed_interval.display_range.width + this.display_range.width)) {\n                                    collision_on_potential_track = true;\n                                }\n                            }\n                        }.bind(this.data[i]));\n                        if (!collision_on_potential_track) {\n                            this.data[i].track = potential_track;\n                            this.interval_track_index[potential_track].push(this.data[i]);\n                        } else {\n                            potential_track++;\n                            if (potential_track > this.tracks) {\n                                this.tracks = potential_track;\n                                this.interval_track_index[potential_track] = [];\n                            }\n                        }\n                    }\n\n                }\n\n            }.bind(this));\n\n            return this;\n        };\n\n        // Implement the main render function\n        this.render = function() {\n            this.assignTracks();\n\n            // Remove any shared highlight nodes and re-render them if we're splitting on tracks\n            // At most there will only be dozen or so nodes here (one per track) and each time\n            // we render data we may have new tracks, so wiping/redrawing all is reasonable.\n            this.svg.group.selectAll('.lz-data_layer-intervals-statusnode.lz-data_layer-intervals-shared').remove();\n            Object.keys(this.track_split_field_index).forEach(function(key) {\n                // Make a psuedo-element so that we can generate an id for the shared node\n                var pseudoElement = {};\n                pseudoElement[this.layout.track_split_field] = key;\n                // Insert the shared node\n                var sharedstatusnode_style = {display: (this.layout.split_tracks ? null : 'none')};\n                this.svg.group.insert('rect', ':first-child')\n                    .attr('id', this.getElementStatusNodeId(pseudoElement))\n                    .attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-shared')\n                    .attr('rx', this.layout.bounding_box_padding).attr('ry', this.layout.bounding_box_padding)\n                    .attr('width', this.parent.layout.cliparea.width)\n                    .attr('height', this.getTrackHeight() - this.layout.track_vertical_spacing)\n                    .attr('x', 0)\n                    .attr('y', (this.track_split_field_index[key] - 1) * this.getTrackHeight())\n                    .style(sharedstatusnode_style);\n            }.bind(this));\n\n            var width, height, x, y, fill, fill_opacity;\n\n            // Render interval groups\n            var selection = this.svg.group.selectAll('g.lz-data_layer-intervals')\n                .data(this.data, function(d) { return d[this.layout.id_field]; }.bind(this));\n\n            selection.enter().append('g')\n                .attr('class', 'lz-data_layer-intervals');\n\n            selection.attr('id', function(d) { return this.getElementId(d); }.bind(this))\n                .each(function(interval) {\n\n                    var data_layer = interval.parent;\n\n                    // Render interval status nodes (displayed behind intervals to show highlight\n                    // without needing to modify interval display element(s))\n                    var statusnode_style = {display: (data_layer.layout.split_tracks ? 'none' : null)};\n                    var statusnodes = d3.select(this).selectAll('rect.lz-data_layer-intervals.lz-data_layer-intervals-statusnode.lz-data_layer-intervals-statusnode-discrete')\n                        .data([interval], function(d) { return data_layer.getElementId(d) + '-statusnode'; });\n                    statusnodes.enter().insert('rect', ':first-child')\n                        .attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-statusnode-discrete');\n                    statusnodes\n                        .attr('id', function(d) {\n                            return data_layer.getElementId(d) + '-statusnode';\n                        })\n                        .attr('rx', function() {\n                            return data_layer.layout.bounding_box_padding;\n                        })\n                        .attr('ry', function() {\n                            return data_layer.layout.bounding_box_padding;\n                        })\n                        .style(statusnode_style);\n                    width = function(d) {\n                        return d.display_range.width + (2 * data_layer.layout.bounding_box_padding);\n                    };\n                    height = function() {\n                        return data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing;\n                    };\n                    x = function(d) {\n                        return d.display_range.start - data_layer.layout.bounding_box_padding;\n                    };\n                    y = function(d) {\n                        return ((d.track - 1) * data_layer.getTrackHeight());\n                    };\n\n                    statusnodes\n                        .attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n\n                    statusnodes.exit().remove();\n\n                    // Render primary interval rects\n                    var rects = d3.select(this).selectAll('rect.lz-data_layer-intervals.lz-interval_rect')\n                        .data([interval], function(d) { return d[data_layer.layout.id_field] + '_interval_rect'; });\n\n                    rects.enter().append('rect')\n                        .attr('class', 'lz-data_layer-intervals lz-interval_rect');\n\n                    height = data_layer.layout.track_height;\n                    width = function(d) {\n                        return d.display_range.width;\n                    };\n                    x = function(d) {\n                        return d.display_range.start;\n                    };\n                    y = function(d) {\n                        return ((d.track - 1) * data_layer.getTrackHeight())\n                            + data_layer.layout.bounding_box_padding;\n                    };\n                    fill = function(d, i) {\n                        return data_layer.resolveScalableParameter(data_layer.layout.color, d, i);\n                    };\n                    fill_opacity = function(d, i) {\n                        return data_layer.resolveScalableParameter(data_layer.layout.fill_opacity, d, i);\n                    };\n\n                    rects\n                        .attr('width', width).attr('height', height)\n                        .attr('x', x).attr('y', y)\n                        .attr('fill', fill)\n                        .attr('fill-opacity', fill_opacity);\n\n                    rects.exit().remove();\n\n                    // Render interval click areas\n                    var clickareas = d3.select(this).selectAll('rect.lz-data_layer-intervals.lz-clickarea')\n                        .data([interval], function(d) { return d.interval_name + '_clickarea'; });\n\n                    clickareas.enter().append('rect')\n                        .attr('class', 'lz-data_layer-intervals lz-clickarea');\n\n                    clickareas\n                        .attr('id', function(d) {\n                            return data_layer.getElementId(d) + '_clickarea';\n                        })\n                        .attr('rx', function() {\n                            return data_layer.layout.bounding_box_padding;\n                        })\n                        .attr('ry', function() {\n                            return data_layer.layout.bounding_box_padding;\n                        });\n\n                    width = function(d) {\n                        return d.display_range.width;\n                    };\n                    height = function() {\n                        return data_layer.getTrackHeight() - data_layer.layout.track_vertical_spacing;\n                    };\n                    x = function(d) {\n                        return d.display_range.start;\n                    };\n                    y = function(d) {\n                        return ((d.track - 1) * data_layer.getTrackHeight());\n                    };\n\n                    clickareas\n                        .attr('width', width).attr('height', height).attr('x', x).attr('y', y);\n\n                    // Remove old clickareas as needed\n                    clickareas.exit().remove();\n\n                    // Apply default event emitters to clickareas\n                    clickareas.on('click', function(element_data) {\n                        element_data.parent.parent.emit('element_clicked', element_data, true);\n                    }.bind(this));\n\n                    // Apply mouse behaviors to clickareas\n                    data_layer.applyBehaviors(clickareas);\n\n                });\n\n            // Remove old elements as needed\n            selection.exit().remove();\n\n            // Update the legend axis if the number of ticks changed\n            if (this.previous_tracks !== this.tracks) {\n                this.updateSplitTrackAxis();\n            }\n\n            // The intervals track allows legends to be dynamically generated, in which case space can only be\n            //  allocated after the panel has been rendered.\n            if (this.parent && this.parent.legend) {\n                this.parent.legend.render();\n            }\n\n            return this;\n        };\n\n        this._getTooltipPosition = function (tooltip) {\n            var interval_bbox = d3.select('#' + this.getElementStatusNodeId(tooltip.data)).node().getBBox();\n            return {\n                x_min: tooltip.data.display_range.start,\n                x_max: tooltip.data.display_range.end,\n                y_min: interval_bbox.y,\n                y_max: interval_bbox.y + interval_bbox.height\n            };\n        };\n\n        // Redraw split track axis or hide it, and show/hide the legend, as determined\n        // by current layout parameters and data\n        this.updateSplitTrackAxis = function() {\n            var legend_axis = this.layout.track_split_legend_to_y_axis ? 'y' + this.layout.track_split_legend_to_y_axis : false;\n            if (this.layout.split_tracks) {\n                var tracks = +this.tracks || 0;\n                var track_height = +this.layout.track_height || 0;\n                var track_spacing =  2 * (+this.layout.bounding_box_padding || 0) + (+this.layout.track_vertical_spacing || 0);\n                var target_height = (tracks * track_height) + ((tracks - 1) * track_spacing);\n                this.parent.scaleHeightToData(target_height);\n                if (legend_axis && this.parent.legend) {\n                    this.parent.legend.hide();\n                    this.parent.layout.axes[legend_axis] = {\n                        render: true,\n                        ticks: [],\n                        range: {\n                            start: (target_height - (this.layout.track_height / 2)),\n                            end: (this.layout.track_height / 2)\n                        }\n                    };\n                    // There is a very tight coupling between the display directives: each legend item must identify a key\n                    //  field for unique tracks. (Typically this is `state_id`, the same key field used to assign unique colors)\n                    // The list of unique keys corresponds to the order along the y-axis\n                    this.layout.legend.forEach(function(element) {\n                        var key = element[this.layout.track_split_field];\n                        var track = this.track_split_field_index[key];\n                        if (track) {\n                            if (this.layout.track_split_order === 'DESC') {\n                                track = Math.abs(track - tracks - 1);\n                            }\n                            this.parent.layout.axes[legend_axis].ticks.push({\n                                y: track,\n                                text: element.label\n                            });\n                        }\n                    }.bind(this));\n                    this.layout.y_axis = {\n                        axis: this.layout.track_split_legend_to_y_axis,\n                        floor: 1,\n                        ceiling: tracks\n                    };\n                    this.parent.render();\n                }\n                this.parent_plot.positionPanels();\n            } else {\n                if (legend_axis && this.parent.legend) {\n                    if (!this.layout.always_hide_legend) { this.parent.legend.show(); }\n                    this.parent.layout.axes[legend_axis] = { render: false };\n                    this.parent.render();\n                }\n            }\n            return this;\n        };\n\n        // Method to not only toggle the split tracks boolean but also update\n        // necessary display values to animate a complete merge/split\n        this.toggleSplitTracks = function() {\n            this.layout.split_tracks = !this.layout.split_tracks;\n            if (this.parent.legend && !this.layout.always_hide_legend) {\n                this.parent.layout.margin.bottom = 5 + (this.layout.split_tracks ? 0 : this.parent.legend.layout.height + 5);\n            }\n            this.render();\n            this.updateSplitTrackAxis();\n            return this;\n        };\n\n        // Choose an appropriate color scheme based on the number of items in the track, and whether or not we are\n        //  using explicitly provided itemRgb information\n        this._makeColorScheme = function(category_info) {\n            // If at least one element has an explicit itemRgb, assume the entire dataset has colors\n            var has_explicit_colors = category_info.find(function (item) { return item[2]; });\n            if (has_explicit_colors) {\n                return category_info.map(function (item) { return item[2]; });\n            }\n\n            // Use a set of color schemes for common 15, 18, or 25 state models, as specified from:\n            //  https://egg2.wustl.edu/roadmap/web_portal/chr_state_learning.html\n            // These are actually reversed so that dim colors come first, on the premise that usually these are the\n            //  most common states\n            var n_categories = category_info.length;\n            if (n_categories <= 15) {\n                return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(233,150,122)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(50,205,50)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            } else if (n_categories <= 18) {\n                return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            } else {\n                // If there are more than 25 categories, the interval layer will fall back to the 'null value' option\n                return ['rgb(212,212,212)', 'rgb(128,128,128)', 'rgb(112,48,160)', 'rgb(230,184,183)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,102)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,150,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            }\n        };\n\n        /**\n         * Find all of the unique tracks (a combination of name and ID information)\n         * @param data\n         * @private\n         * @returns {Array} All [unique_id, label, color] pairs in data. The unique_id is the thing used to define groupings\n         *  most unambiguously.\n         */\n        this._generateCategoriesFromData = function (data, rgb_field) {\n            var self = this;\n            // Use the hard-coded legend if available (ignoring any mods on re-render)\n            var legend = this._base_layout.legend;\n            if (legend && legend.length) {\n                return legend.map(function (item) {\n                    return [item[self.layout.track_split_field], item.label, item.color];\n                });\n            }\n\n            // Generate options from data, if no preset legend exists\n            var unique_ids = {}; // make categories unique\n            var categories = [];\n\n            data.forEach(function (item, idx) {\n                var id = item[self.layout.track_split_field];\n                if (!unique_ids.hasOwnProperty(id)) {\n                    unique_ids[id] = null;\n                    // If rgbfield is null, then the last entry is undefined/null as well\n                    categories.push([id, item[self.layout.track_label_field], item[rgb_field]]);\n                }\n            });\n            return categories;\n        }.bind(this);\n\n        return this;\n\n    });\n\n    LocusZoom.Layouts.add('tooltip', 'standard_intervals', {\n        namespace: { 'intervals': 'intervals' },\n        closable: false,\n        show: { or: ['highlighted', 'selected'] },\n        hide: { and: ['unhighlighted', 'unselected'] },\n        html: '{{{{namespace[intervals]}}state_name|htmlescape}}<br>{{{{namespace[intervals]}}start|htmlescape}}-{{{{namespace[intervals]}}end|htmlescape}}'\n    });\n\n    LocusZoom.Layouts.add('data_layer', 'intervals', {\n        namespace: { 'intervals': 'intervals' },\n        id: 'intervals',\n        type: 'intervals',\n        fields: ['{{namespace[intervals]}}start', '{{namespace[intervals]}}end', '{{namespace[intervals]}}state_id', '{{namespace[intervals]}}state_name', '{{namespace[intervals]}}itemRgb'],\n        id_field: '{{namespace[intervals]}}start',\n        start_field: '{{namespace[intervals]}}start',\n        end_field: '{{namespace[intervals]}}end',\n        track_split_field: '{{namespace[intervals]}}state_name',\n        track_label_field: '{{namespace[intervals]}}state_name',\n        split_tracks: false,\n        always_hide_legend: true,\n        color: [\n            {\n                // If present, an explicit color field will override any other option (and be used to auto-generate legend)\n                field: '{{namespace[intervals]}}itemRgb',\n                scale_function: 'to_rgb'\n            },\n            {\n                field: '{{namespace[intervals]}}state_name',\n                scale_function: 'categorical_bin',\n                parameters: {\n                    // Placeholder. Empty categories and values will automatically be filled in when new data loads.\n                    categories: [],\n                    values: [],\n                    null_value: '#B8B8B8'\n                }\n            }\n        ],\n        legend: [], // Placeholder; auto-filled when data loads.\n        behaviors: {\n            onmouseover: [\n                { action: 'set', status: 'highlighted' }\n            ],\n            onmouseout: [\n                { action: 'unset', status: 'highlighted' }\n            ],\n            onclick: [\n                { action: 'toggle', status: 'selected', exclusive: true }\n            ],\n            onshiftclick: [\n                { action: 'toggle', status: 'selected' }\n            ]\n        },\n        tooltip: LocusZoom.Layouts.get('tooltip', 'standard_intervals', { unnamespaced: true })\n    });\n\n    LocusZoom.Layouts.add('panel', 'intervals', {\n        id: 'intervals',\n        width: 1000,\n        height: 50,\n        min_width: 500,\n        min_height: 50,\n        margin: { top: 25, right: 150, bottom: 5, left: 50 },\n        dashboard: (function () {\n            var l = LocusZoom.Layouts.get('dashboard', 'standard_panel', { unnamespaced: true });\n            l.components.push({\n                type: 'toggle_split_tracks',\n                data_layer_id: 'intervals',\n                position: 'right'\n            });\n            return l;\n        })(),\n        axes: {},\n        interaction: {\n            drag_background_to_pan: true,\n            scroll_to_zoom: true,\n            x_linked: true\n        },\n        legend: {\n            hidden: true,\n            orientation: 'horizontal',\n            origin: { x: 50, y: 0 },\n            pad_from_bottom: 5\n        },\n        data_layers: [\n            LocusZoom.Layouts.get('data_layer', 'intervals', { unnamespaced: true })\n        ]\n    });\n\n    LocusZoom.Layouts.add('plot', 'interval_association', {\n        state: {},\n        width: 800,\n        height: 550,\n        responsive_resize: 'both',\n        min_region_scale: 20000,\n        max_region_scale: 1000000,\n        dashboard: LocusZoom.Layouts.get('dashboard', 'standard_plot', { unnamespaced: true }),\n        panels: [\n            LocusZoom.Layouts.get('panel', 'association', {\n                unnamespaced: true,\n                width: 800,\n                proportional_height: (225 / 570)\n            }),\n            LocusZoom.Layouts.get('panel', 'intervals', { unnamespaced: true, proportional_height: (120 / 570) }),\n            LocusZoom.Layouts.get('panel', 'genes', { unnamespaced: true, width: 800, proportional_height: (225 / 570) })\n        ]\n    });\n\n    // Public interface for this extension; since everything is registered w/LocusZoom, this is rarely used directly.\n    return { IntervalLZ: IntervalSource };\n}));\n"]}