{"version":3,"sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/external \"d3\"","webpack://[name]/./esm/ext/lz-intervals-track.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","d3","XCS","for","YCS","XCE","YCE","install","LocusZoom","BaseApiAdapter","Adapters","_Button","Widgets","_BaseWidget","default_layout","start_field","end_field","track_label_field","track_split_field","track_split_order","track_split_legend_to_y_axis","split_tracks","track_height","track_vertical_spacing","bounding_box_padding","always_hide_legend","color","fill_opacity","tooltip_positioning","BaseLayer","DataLayers","intervals_tooltip_layout","namespace","closable","show","or","hide","and","html","intervals_layer_layout","id","type","fields","id_field","field","scale_function","parameters","categories","values","null_value","legend","behaviors","onmouseover","action","status","onmouseout","onclick","exclusive","onshiftclick","tooltip","intervals_panel_layout","width","height","min_width","min_height","margin","top","right","bottom","left","toolbar","Layouts","unnamespaced","widgets","push","data_layer_id","position","axes","interaction","drag_background_to_pan","scroll_to_zoom","x_linked","hidden","orientation","origin","x","y","pad_from_bottom","data_layers","intervals_plot_layout","state","responsive_resize","min_region_scale","max_region_scale","panels","proportional_height","assign","add","chain","query","header","bedtracksource","this","params","source","chr","end","start","url","layout","merge","super","arguments","_previous_categories","_categories","initialize","_statusnodes_group","svg","group","append","attr","_datanodes_group","data","result","forEach","item","item_key","allow_overlap","grouped_data","index","length","row_to_test","last_item","x_scale","parent","_arrangeTrackSplit","_arrangeTracksLinear","keys","reverse","row_index","getTrackHeight","track","reduce","acc","val","concat","element","getBaseId","replace","self","base_layout","_base_layout","render_layout","base_color_scale","find","color_scale","Error","has_colors","has_legend","rgb_option","rgb_field","known_categories","_generateCategoriesFromData","colors","_makeColorScheme","map","pair","shape","label","_applyLayoutOptions","assigned_data","_assignTracks","every","updateSplitTrackAxis","track_data","_applyFilters","selectAll","remove","status_nodes","enter","getElementStatusNodeId","cliparea","exit","data_nodes","getElementId","resolveScalableParameter","applyBehaviors","render","x_min","x_max","y_min","y_max","legend_axis","tracks","track_spacing","target_height","scaleHeightToData","ticks","range","findIndex","Math","abs","text","y_axis","axis","floor","ceiling","parent_plot","positionPanels","category_info","n_categories","unique_ids","ScaleFunctions","parent_panel","data_layer","button","setHtml","setColor","setTitle","setOnclick","toggleSplitTracks","scale_timeout","clearTimeout","setTimeout","update","use"],"mappings":"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","file":"ext/lz-intervals-track.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 9);\n","module.exports = d3;","/**\nInterval annotation track (for chromatin state, etc). Useful for BED file data with non-overlapping intervals.\nThis is not part of the core LocusZoom library, but can be included as a standalone file.\n\nThe page must incorporate and load all libraries before this file can be used, including:\n - Vendor assets\n - LocusZoom\n @module\n*/\n\nimport * as d3 from 'd3';\n\n\n// Coordinates (start, end) are cached to facilitate rendering\nconst XCS = Symbol.for('lzXCS');\nconst YCS = Symbol.for('lzYCS');\nconst XCE = Symbol.for('lzXCE');\nconst YCE = Symbol.for('lzYCE');\n\n\nfunction install (LocusZoom) {\n    const BaseApiAdapter = LocusZoom.Adapters.get('BaseApiAdapter');\n    const _Button = LocusZoom.Widgets.get('_Button');\n    const _BaseWidget = LocusZoom.Widgets.get('BaseWidget');\n\n    /**\n     * Data Source for Interval Annotation Data (e.g. BED Tracks), as fetched from the LocusZoom API server (or compatible)\n     * @public\n     */\n    class IntervalLZ extends BaseApiAdapter {\n        getURL(state, chain, fields) {\n            const source = chain.header.bedtracksource || this.params.source;\n            const query = `?filter=id in ${source} and chromosome eq '${state.chr}' and start le ${state.end} and end ge ${state.start}`;\n            return `${this.url}${query}`;\n        }\n    }\n\n    /**\n     * Button to toggle split tracks\n     */\n    class ToggleSplitTracks extends _BaseWidget {\n        constructor(layout) {\n            super(...arguments);\n            if (!layout.data_layer_id) {\n                layout.data_layer_id = 'intervals';\n            }\n            if (!this.parent_panel.data_layers[layout.data_layer_id]) {\n                throw new Error('Toggle split tracks widget specifies an invalid data layer ID');\n            }\n        }\n\n        update() {\n            const data_layer = this.parent_panel.data_layers[this.layout.data_layer_id];\n            const html = data_layer.layout.split_tracks ? 'Merge Tracks' : 'Split Tracks';\n            if (this.button) {\n                this.button.setHtml(html);\n                this.button.show();\n                this.parent.position();\n                return this;\n            } else {\n                this.button = new _Button(this)\n                    .setColor(this.layout.color)\n                    .setHtml(html)\n                    .setTitle('Toggle whether tracks are split apart or merged together')\n                    .setOnclick(() => {\n                        data_layer.toggleSplitTracks();\n                        // FIXME: the timeout calls to scale and position (below) cause full ~5 additional re-renders\n                        //  If we can remove these it will greatly speed up re-rendering.\n                        // The key problem here is that the height is apparently not known in advance and is determined after re-render.\n                        if (this.scale_timeout) {\n                            clearTimeout(this.scale_timeout);\n                        }\n                        this.scale_timeout = setTimeout(() => {\n                            this.parent_panel.scaleHeightToData();\n                            this.parent_plot.positionPanels();\n                        }, 0);\n                        this.update();\n                    });\n                return this.update();\n            }\n        }\n    }\n\n\n    /**\n     * Convert a value \"\"rr,gg,bb\" (if given) to a css-friendly color string: \"rgb(rr,gg,bb)\".\n     * This is tailored specifically to the color specification format embraced by the BED file standard.\n     * @function to_rgb\n     * @param {Object} parameters This function has no defined configuration options\n     * @param {String|null} value The value to convert to rgb\n     */\n    function to_rgb(parameters, value) {\n        return value ? `rgb(${value})` : null;\n    }\n\n    const default_layout = {\n        start_field: 'start',\n        end_field: 'end',\n        track_label_field: 'state_name', // Used to label items on the y-axis\n        // Used to uniquely identify tracks for coloring. This tends to lead to more stable coloring/sorting\n        //  than using the label field- eg, state_ids allow us to set global colors across the entire dataset,\n        //  not just choose unique colors within a particular narrow region. (where changing region might lead to more\n        //  categories and different colors)\n        track_split_field: 'state_id',\n        track_split_order: 'DESC',\n        track_split_legend_to_y_axis: 2,\n        split_tracks: true,\n        track_height: 15,\n        track_vertical_spacing: 3,\n        bounding_box_padding: 2,\n        always_hide_legend: false,\n        color: '#B8B8B8',\n        fill_opacity: 1,\n        tooltip_positioning: 'vertical',\n    };\n\n\n    /**\n     * Intervals Data Layer\n     * Implements a data layer that will render interval annotation tracks (intervals must provide start and end values)\n     */\n    const BaseLayer = LocusZoom.DataLayers.get('BaseDataLayer');\n    class LzIntervalsTrack extends BaseLayer {\n        constructor(layout) {\n            LocusZoom.Layouts.merge(layout, default_layout);\n            super(...arguments);\n            this._previous_categories = [];\n            this._categories = [];\n        }\n\n        initialize() {\n            super.initialize();\n            this._statusnodes_group = this.svg.group.append('g')\n                .attr('class', 'lz-data-layer-intervals lz-data-layer-intervals-statusnode');\n            this._datanodes_group = this.svg.group.append('g')\n                .attr('class', 'lz-data_layer-intervals');\n        }\n\n        /**\n         * Split data into tracks such that anything with a common grouping field is in the same track\n         * @param data\n         * @return {unknown[]}\n         * @private\n         */\n        _arrangeTrackSplit(data) {\n            const {track_split_field} = this.layout;\n            const result = {};\n            data.forEach((item) => {\n                const item_key = item[track_split_field];\n                if (!Object.prototype.hasOwnProperty.call(result, item_key)) {\n                    result[item_key] = [];\n                }\n                result[item_key].push(item);\n            });\n            return result;\n        }\n\n        /**\n         * Split data into rows using a simple greedy algorithm such that no two items overlap (share same interval)\n         * Assumes that the data are sorted so item1.start always <= item2.start.\n         *\n         * This function can also simply return all data on a single row. This functionality may become configurable\n         *  in the future but for now reflects a lack of clarity in the requirements/spec. The code to split\n         *  overlapping items is present but may not see direct use.\n         */\n        _arrangeTracksLinear(data, allow_overlap = true) {\n            if (allow_overlap) {\n                // If overlap is allowed, then all the data can live on a single row\n                return [data];\n            }\n\n            // ASSUMPTION: Data is given to us already sorted by start position to facilitate grouping.\n            // We do not sort here because JS \"sort\" is not stable- if there are many intervals that overlap, then we\n            //   can get different layouts (number/order of rows) on each call to \"render\".\n            //\n            // At present, we decide how to update the y-axis based on whether current and former number of rows are\n            //  the same. An unstable sort leads to layout thrashing/too many re-renders. FIXME: don't rely on counts\n            const {start_field, end_field} = this.layout;\n\n            const grouped_data = [[]]; // Prevent two items from colliding by rendering them to different rows, like genes\n            data.forEach((item, index) => {\n                for (let i = 0; i < grouped_data.length; i++) {\n                    // Iterate over all rows of the\n                    const row_to_test = grouped_data[i];\n                    const last_item = row_to_test[row_to_test.length - 1];\n                    // Some programs report open intervals, eg 0-1,1-2,2-3; these points are not considered to overlap (hence the test isn't \"<=\")\n                    const has_overlap = last_item && (item[start_field] < last_item[end_field]) && (last_item[start_field] < item[end_field]);\n                    if (!has_overlap) {\n                        // If there is no overlap, add item to current row, and move on to the next item\n                        row_to_test.push(item);\n                        return;\n                    }\n                }\n                // If this item would collide on all existing rows, create a new row\n                grouped_data.push([item]);\n            });\n            return grouped_data;\n        }\n\n        /**\n         * Annotate each item with the track number, and return.\n         * @param {Object[]}data\n         * @private\n         * @return [String[], Object[]] Return the categories and the data array\n         */\n        _assignTracks(data) {\n            // Flatten the grouped data.\n            const {x_scale} = this.parent;\n            const {start_field, end_field, bounding_box_padding, track_height} = this.layout;\n\n            const grouped_data = this.layout.split_tracks ? this._arrangeTrackSplit(data) : this._arrangeTracksLinear(data, true);\n            const categories = Object.keys(grouped_data);\n            if (this.layout.track_split_order === 'DESC') {\n                categories.reverse();\n            }\n\n            categories.forEach((key, row_index) => {\n                const row = grouped_data[key];\n                row.forEach((item) => {\n                    item[XCS] = x_scale(item[start_field]);\n                    item[XCE] = x_scale(item[end_field]);\n                    item[YCS] = row_index * this.getTrackHeight() + bounding_box_padding;\n                    item[YCE] = item[YCS] + track_height;\n                    // Store the row ID, so that clicking on a point can find the right status node (big highlight box)\n                    item.track = row_index;\n                });\n            });\n            // We're mutating elements of the original data array as a side effect: the return value here is\n            //  interchangeable with `this.data` for subsequent usages\n            // TODO: Can replace this with array.flat once polyfill support improves\n            return [categories, Object.values(grouped_data).reduce((acc, val) => acc.concat(val), [])];\n        }\n\n        /**\n         * When we are in \"split tracks mode\", it's convenient to wrap all individual annotations with a shared\n         *  highlight box that wraps everything on that row.\n         *\n         * This is done automatically by the \"setElementStatus\" code, if this function returns a non-null value\n         *\n         * To define shared highlighting on the track split field define the status node id override\n         * to generate an ID common to the track when we're actively splitting data out to separate tracks\n         * @override\n         * @returns {String}\n         */\n        getElementStatusNodeId(element) {\n            if (this.layout.split_tracks) {\n                // Data nodes are bound to data objects, but the \"status_nodes\" selection is bound to numeric row IDs\n                const track = typeof element === 'object' ? element.track : element;\n                const base = `${this.getBaseId()}-statusnode-${track}`;\n                return base.replace(/[^\\w]/g, '_');\n            }\n            // In merged tracks mode, there is no separate status node\n            return null;\n        }\n\n        // Helper function to sum layout values to derive total height for a single interval track\n        getTrackHeight() {\n            return this.layout.track_height\n                + this.layout.track_vertical_spacing\n                + (2 * this.layout.bounding_box_padding);\n        }\n\n        // Modify the layout as necessary to ensure that appropriate color, label, and legend options are available\n        // Even when not displayed, the legend is used to generate the y-axis ticks\n        _applyLayoutOptions() {\n            const self = this;\n            const base_layout = this._base_layout;\n            const render_layout = this.layout;\n            const base_color_scale = base_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'categorical_bin';\n            });\n            const color_scale = render_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'categorical_bin';\n            });\n            if (!base_color_scale) {\n                // This can be a placeholder (empty categories & values), but it needs to be there\n                throw new Error('Interval tracks must define a `categorical_bin` color scale');\n            }\n\n            const has_colors = base_color_scale.parameters.categories.length && base_color_scale.parameters.values.length;\n            const has_legend = base_layout.legend && base_layout.legend.length;\n\n            if (!!has_colors ^ !!has_legend) {\n                // Don't allow color OR legend to be set manually. It must be both, or neither.\n                throw new Error('To use a manually specified color scheme, both color and legend options must be set.');\n            }\n\n            // Harvest any information about an explicit color field that should be considered when generating colors\n            const rgb_option = base_layout.color.find(function (item) {\n                return item.scale_function && item.scale_function === 'to_rgb';\n            });\n            const rgb_field = rgb_option && rgb_option.field;\n\n            // Auto-generate legend based on data\n            const known_categories = this._generateCategoriesFromData(this.data, rgb_field); // [id, label, itemRgb] items\n\n            if (!has_colors && !has_legend) {\n                // If no color scheme pre-defined, then make a color scheme that is appropriate and apply to the plot\n                // The legend must match the color scheme. If we generate one, then we must generate both.\n\n                const colors = this._makeColorScheme(known_categories);\n                color_scale.parameters.categories = known_categories.map(function (item) {\n                    return item[0];\n                });\n                color_scale.parameters.values = colors;\n\n                this.layout.legend = known_categories.map(function (pair, index) {\n                    const id = pair[0];\n                    const label = pair[1];\n                    const item_color = color_scale.parameters.values[index];\n                    const item = { shape: 'rect', width: 9, label: label, color: item_color };\n                    item[self.layout.track_split_field] = id;\n                    return item;\n                });\n            }\n        }\n\n        // Implement the main render function\n        render() {\n            //// Autogenerate layout options if not provided\n            this._applyLayoutOptions();\n\n            // Determine the appropriate layout for tracks. Store the previous categories (y axis ticks) to decide\n            //   whether the axis needs to be re-rendered.\n            this._previous_categories = this._categories;\n            const [categories, assigned_data] = this._assignTracks(this.data);\n            this._categories = categories;\n            // Update the legend axis if the number of ticks changed\n            const labels_changed = !categories.every( (item, index) => item === this._previous_categories[index]);\n            if (labels_changed) {\n                this.updateSplitTrackAxis(categories);\n                return;\n            }\n\n            // Apply filters to only render a specified set of points. Hidden fields will still be given space to render, but not shown.\n            const track_data = this._applyFilters(assigned_data);\n\n            // Clear before every render so that, eg, highlighting doesn't persist if we load a region with different\n            //  categories (row 2 might be a different category and it's confusing if the row stays highlighted but changes meaning)\n            // Highlighting will automatically get added back if it actually makes sense, courtesy of setElementStatus,\n            //  if a selected item is still in view after the new region loads.\n            this._statusnodes_group.selectAll('rect')\n                .remove();\n\n            // Reselect in order to add new data\n            const status_nodes = this._statusnodes_group.selectAll('rect')\n                .data(d3.range(categories.length));\n\n            if (this.layout.split_tracks) {\n                // Status nodes: a big highlight box around all items of the same type. Used in split tracks mode,\n                //  because everything on the same row is the same category and a group makes sense\n                // There are no status nodes in merged mode, because the same row contains many kinds of things\n\n                // Status nodes are 1 per row, so \"data\" can just be a dummy list of possible row IDs\n                // Each status node is a box that runs the length of the panel and receives a special \"colored box\" css\n                //  style when selected\n                const height = this.getTrackHeight();\n                status_nodes.enter()\n                    .append('rect')\n                    .attr('class', 'lz-data_layer-intervals lz-data_layer-intervals-statusnode lz-data_layer-intervals-shared')\n                    .attr('rx', this.layout.bounding_box_padding)\n                    .attr('ry', this.layout.bounding_box_padding)\n                    .merge(status_nodes)\n                    .attr('id', (d) => this.getElementStatusNodeId(d))\n                    .attr('x', 0)\n                    .attr('y', (d) => (d * height))\n                    .attr('width', this.parent.layout.cliparea.width)\n                    .attr('height', height - this.layout.track_vertical_spacing);\n            }\n            status_nodes.exit()\n                .remove();\n\n            // Draw rectangles for the data (intervals)\n            const data_nodes = this._datanodes_group.selectAll('rect')\n                .data(track_data, (d) => d[this.layout.id_field]);\n\n            data_nodes.enter()\n                .append('rect')\n                .merge(data_nodes)\n                .attr('id', (d) => this.getElementId(d))\n                .attr('x', (d) => d[XCS])\n                .attr('y', (d) => d[YCS])\n                .attr('width', (d) => d[XCE] - d[XCS])\n                .attr('height', this.layout.track_height)\n                .attr('fill', (d, i) => this.resolveScalableParameter(this.layout.color, d, i))\n                .attr('fill-opacity', (d, i) => this.resolveScalableParameter(this.layout.fill_opacity, d, i));\n\n            data_nodes.exit()\n                .remove();\n\n            this._datanodes_group\n                .call(this.applyBehaviors.bind(this));\n\n            // The intervals track allows legends to be dynamically generated, in which case space can only be\n            //  allocated after the panel has been rendered.\n            if (this.parent && this.parent.legend) {\n                this.parent.legend.render();\n            }\n        }\n\n        _getTooltipPosition(tooltip) {\n            return {\n                x_min: tooltip.data[XCS],\n                x_max: tooltip.data[XCE],\n                y_min: tooltip.data[YCS],\n                y_max: tooltip.data[YCE],\n            };\n        }\n\n        // Redraw split track axis or hide it, and show/hide the legend, as determined\n        // by current layout parameters and data\n        updateSplitTrackAxis(categories) {\n            const legend_axis = this.layout.track_split_legend_to_y_axis ? `y${this.layout.track_split_legend_to_y_axis}` : false;\n            if (this.layout.split_tracks) {\n                const tracks = +categories.length || 0;\n                const track_height = +this.layout.track_height || 0;\n                const track_spacing = 2 * (+this.layout.bounding_box_padding || 0) + (+this.layout.track_vertical_spacing || 0);\n                const target_height = (tracks * track_height) + ((tracks - 1) * track_spacing);\n                this.parent.scaleHeightToData(target_height);\n                if (legend_axis && this.parent.legend) {\n                    this.parent.legend.hide();\n                    this.parent.layout.axes[legend_axis] = {\n                        render: true,\n                        ticks: [],\n                        range: {\n                            start: (target_height - (this.layout.track_height / 2)),\n                            end: (this.layout.track_height / 2),\n                        },\n                    };\n                    // There is a very tight coupling between the display directives: each legend item must identify a key\n                    //  field for unique tracks. (Typically this is `state_id`, the same key field used to assign unique colors)\n                    // The list of unique keys corresponds to the order along the y-axis\n                    this.layout.legend.forEach((element) => {\n                        const key = element[this.layout.track_split_field];\n                        let track = categories.findIndex((item) => item === key);\n                        if (track !== -1) {\n                            if (this.layout.track_split_order === 'DESC') {\n                                track = Math.abs(track - tracks - 1);\n                            }\n                            this.parent.layout.axes[legend_axis].ticks.push({\n                                y: track - 1,\n                                text: element.label,\n                            });\n                        }\n                    });\n                    this.layout.y_axis = {\n                        axis: this.layout.track_split_legend_to_y_axis,\n                        floor: 1,\n                        ceiling: tracks,\n                    };\n                }\n                // This will trigger a re-render\n                this.parent_plot.positionPanels();\n            } else {\n                if (legend_axis && this.parent.legend) {\n                    if (!this.layout.always_hide_legend) {\n                        this.parent.legend.show();\n                    }\n                    this.parent.layout.axes[legend_axis] = { render: false };\n                    this.parent.render();\n                }\n            }\n            return this;\n        }\n\n        // Method to not only toggle the split tracks boolean but also update\n        // necessary display values to animate a complete merge/split\n        toggleSplitTracks() {\n            this.layout.split_tracks = !this.layout.split_tracks;\n            if (this.parent.legend && !this.layout.always_hide_legend) {\n                this.parent.layout.margin.bottom = 5 + (this.layout.split_tracks ? 0 : this.parent.legend.layout.height + 5);\n            }\n            this.render();\n            return this;\n        }\n\n        // Choose an appropriate color scheme based on the number of items in the track, and whether or not we are\n        //  using explicitly provided itemRgb information\n        _makeColorScheme(category_info) {\n            // If at least one element has an explicit itemRgb, assume the entire dataset has colors\n            const has_explicit_colors = category_info.find((item) => item[2]);\n            if (has_explicit_colors) {\n                return category_info.map((item) => item[2]);\n            }\n\n            // Use a set of color schemes for common 15, 18, or 25 state models, as specified from:\n            //  https://egg2.wustl.edu/roadmap/web_portal/chr_state_learning.html\n            // These are actually reversed so that dim colors come first, on the premise that usually these are the\n            //  most common states\n            const n_categories = category_info.length;\n            if (n_categories <= 15) {\n                return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(233,150,122)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(50,205,50)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            } else if (n_categories <= 18) {\n                return ['rgb(212,212,212)', 'rgb(192,192,192)', 'rgb(128,128,128)', 'rgb(189,183,107)', 'rgb(205,92,92)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,100,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            } else {\n                // If there are more than 25 categories, the interval layer will fall back to the 'null value' option\n                return ['rgb(212,212,212)', 'rgb(128,128,128)', 'rgb(112,48,160)', 'rgb(230,184,183)', 'rgb(138,145,208)', 'rgb(102,205,170)', 'rgb(255,255,102)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,255,0)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(255,195,77)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(194,225,5)', 'rgb(0,150,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(0,128,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,69,0)', 'rgb(255,0,0)'];\n            }\n        }\n\n        /**\n         * Find all of the unique tracks (a combination of name and ID information)\n         * @param {Object} data\n         * @param {String} [rgb_field] A field that contains an RGB value. Aimed at BED files with an itemRgb column\n         * @private\n         * @returns {Array} All [unique_id, label, color] pairs in data. The unique_id is the thing used to define groupings\n         *  most unambiguously.\n         */\n        _generateCategoriesFromData(data, rgb_field) {\n            const self = this;\n            // Use the hard-coded legend if available (ignoring any mods on re-render)\n            const legend = this._base_layout.legend;\n            if (legend && legend.length) {\n                return legend.map((item) => [item[this.layout.track_split_field], item.label, item.color]);\n            }\n\n            // Generate options from data, if no preset legend exists\n            const unique_ids = {}; // make categories unique\n            const categories = [];\n\n            data.forEach((item) => {\n                const id = item[self.layout.track_split_field];\n                if (!Object.prototype.hasOwnProperty.call(unique_ids, id)) {\n                    unique_ids[id] = null;\n                    // If rgbfield is null, then the last entry is undefined/null as well\n                    categories.push([id, item[this.layout.track_label_field], item[rgb_field]]);\n                }\n            });\n            return categories;\n        }\n    }\n\n    const intervals_tooltip_layout = {\n        namespace: { 'intervals': 'intervals' },\n        closable: false,\n        show: { or: ['highlighted', 'selected'] },\n        hide: { and: ['unhighlighted', 'unselected'] },\n        html: '{{{{namespace[intervals]}}state_name|htmlescape}}<br>{{{{namespace[intervals]}}start|htmlescape}}-{{{{namespace[intervals]}}end|htmlescape}}',\n    };\n\n    const intervals_layer_layout =  {\n        namespace: { 'intervals': 'intervals' },\n        id: 'intervals',\n        type: 'intervals',\n        fields: ['{{namespace[intervals]}}start', '{{namespace[intervals]}}end', '{{namespace[intervals]}}state_id', '{{namespace[intervals]}}state_name', '{{namespace[intervals]}}itemRgb'],\n        id_field: '{{namespace[intervals]}}start',  // FIXME: This is not a good D3 \"are these datums redundant\" ID for datasets with multiple intervals heavily overlapping\n        start_field: '{{namespace[intervals]}}start',\n        end_field: '{{namespace[intervals]}}end',\n        track_split_field: '{{namespace[intervals]}}state_name',\n        track_label_field: '{{namespace[intervals]}}state_name',\n        split_tracks: false,\n        always_hide_legend: true,\n        color: [\n            {\n                // If present, an explicit color field will override any other option (and be used to auto-generate legend)\n                field: '{{namespace[intervals]}}itemRgb',\n                scale_function: 'to_rgb',\n            },\n            {\n                field: '{{namespace[intervals]}}state_name',\n                scale_function: 'categorical_bin',\n                parameters: {\n                    // Placeholder. Empty categories and values will automatically be filled in when new data loads.\n                    categories: [],\n                    values: [],\n                    null_value: '#B8B8B8',\n                },\n            },\n        ],\n        legend: [], // Placeholder; auto-filled when data loads.\n        behaviors: {\n            onmouseover: [\n                { action: 'set', status: 'highlighted' },\n            ],\n            onmouseout: [\n                { action: 'unset', status: 'highlighted' },\n            ],\n            onclick: [\n                { action: 'toggle', status: 'selected', exclusive: true },\n            ],\n            onshiftclick: [\n                { action: 'toggle', status: 'selected' },\n            ],\n        },\n        tooltip: intervals_tooltip_layout,\n    };\n\n    const intervals_panel_layout = {\n        id: 'intervals',\n        width: 1000,\n        height: 50,\n        min_width: 500,\n        min_height: 50,\n        margin: { top: 25, right: 150, bottom: 5, left: 50 },\n        toolbar: (function () {\n            const l = LocusZoom.Layouts.get('toolbar', 'standard_panel', { unnamespaced: true });\n            l.widgets.push({\n                type: 'toggle_split_tracks',\n                data_layer_id: 'intervals',\n                position: 'right',\n            });\n            return l;\n        })(),\n        axes: {},\n        interaction: {\n            drag_background_to_pan: true,\n            scroll_to_zoom: true,\n            x_linked: true,\n        },\n        legend: {\n            hidden: true,\n            orientation: 'horizontal',\n            origin: { x: 50, y: 0 },\n            pad_from_bottom: 5,\n        },\n        data_layers: [intervals_layer_layout],\n    };\n\n    const intervals_plot_layout = {\n        state: {},\n        width: 800,\n        height: 550,\n        responsive_resize: true,\n        min_region_scale: 20000,\n        max_region_scale: 1000000,\n        toolbar: LocusZoom.Layouts.get('toolbar', 'standard_association', { unnamespaced: true }),\n        panels: [\n            LocusZoom.Layouts.get('panel', 'association', {\n                unnamespaced: true,\n                width: 800,\n                proportional_height: (225 / 570),\n            }),\n            Object.assign(\n                { unnamespaced: true, proportional_height: (120 / 570) },\n                intervals_panel_layout\n            ),\n            LocusZoom.Layouts.get('panel', 'genes', { unnamespaced: true, width: 800, proportional_height: (225 / 570) }),\n        ],\n    };\n\n    LocusZoom.Adapters.add('IntervalLZ', IntervalLZ);\n    LocusZoom.DataLayers.add('intervals', LzIntervalsTrack);\n\n    LocusZoom.Layouts.add('tooltip', 'standard_intervals', intervals_tooltip_layout);\n    LocusZoom.Layouts.add('data_layer', 'intervals', intervals_layer_layout);\n    LocusZoom.Layouts.add('panel', 'intervals', intervals_panel_layout);\n    LocusZoom.Layouts.add('plot', 'interval_association', intervals_plot_layout);\n\n    LocusZoom.ScaleFunctions.add('to_rgb', to_rgb);\n\n    LocusZoom.Widgets.add('toggle_split_tracks', ToggleSplitTracks);\n}\n\nif (typeof LocusZoom !== 'undefined') {\n    // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()\n    // eslint-disable-next-line no-undef\n    LocusZoom.use(install);\n}\n\n\nexport default install;\n"],"sourceRoot":""}