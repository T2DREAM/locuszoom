/*! Locuszoom 0.13.0-beta.3 */
var LzForestTrack =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./esm/ext/lz-forest-track.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./esm/ext/lz-forest-track.js":
/*!************************************!*\
  !*** ./esm/ext/lz-forest-track.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ "d3");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Forest plot track, designed for use with PheWAS style datasets.
 *   This is not part of the core LocusZoom library, but can be included as a standalone file.
 *
 * The page must incorporate and load all libraries before this file can be used, including:
 * - Vendor assets
 * - LocusZoom
 * @module
 */



function install (LocusZoom) {
    const BaseDataLayer = LocusZoom.DataLayers.get('BaseDataLayer');
    const default_layout = {
        point_size: 40,
        point_shape: 'square',
        color: '#888888',
        fill_opacity: 1,
        y_axis: {
            axis: 2,
        },
        id_field: 'id',
        confidence_intervals: {
            start_field: 'ci_start',
            end_field: 'ci_end',
        },
        show_no_significance_line: true,
    };

    /**
     * Forest Data Layer
     * Implements a standard forest plot. In order to space out points, any layout using this must specify axis ticks
     *  and extent in advance.
     *
     * If you are using dynamically fetched data, consider using `category_forest` instead.
     *
     */
    class Forest extends BaseDataLayer {
        constructor(layout) {
            layout = LocusZoom.Layouts.merge(layout, default_layout);
            super(...arguments);
        }

        _getTooltipPosition(tooltip) {
            const x_center = this.parent.x_scale(tooltip.data[this.layout.x_axis.field]);
            const y_scale = `y${this.layout.y_axis.axis}_scale`;
            const y_center = this.parent[y_scale](tooltip.data[this.layout.y_axis.field]);

            const point_size = this.resolveScalableParameter(this.layout.point_size, tooltip.data);
            const offset = Math.sqrt(point_size / Math.PI);
            return {
                x_min: x_center - offset,
                x_max: x_center + offset,
                y_min: y_center - offset,
                y_max: y_center + offset,
            };
        }

        // Implement the main render function
        render() {
            // Apply filters to only render a specified set of points
            const track_data = this._applyFilters();

            const x_scale = 'x_scale';
            const y_scale = `y${this.layout.y_axis.axis}_scale`;

            // Generate confidence interval paths if fields are defined
            if (this.layout.confidence_intervals
                && this.layout.fields.includes(this.layout.confidence_intervals.start_field)
                && this.layout.fields.includes(this.layout.confidence_intervals.end_field)) {
                // Generate a selection for all forest plot confidence intervals
                const ci_selection = this.svg.group
                    .selectAll('rect.lz-data_layer-forest.lz-data_layer-forest-ci')
                    .data(track_data, (d) => {
                        return d[this.layout.id_field];
                    });

                const ci_transform = (d) => {
                    let x = this.parent[x_scale](d[this.layout.confidence_intervals.start_field]);
                    let y = this.parent[y_scale](d[this.layout.y_axis.field]);
                    if (isNaN(x)) {
                        x = -1000;
                    }
                    if (isNaN(y)) {
                        y = -1000;
                    }
                    return `translate(${x}, ${y})`;
                };
                const ci_width = (d) => {
                    return this.parent[x_scale](d[this.layout.confidence_intervals.end_field])
                        - this.parent[x_scale](d[this.layout.confidence_intervals.start_field]);
                };
                const ci_height = 1;
                // Create confidence interval rect elements
                ci_selection.enter()
                    .append('rect')
                    .attr('class', 'lz-data_layer-forest lz-data_layer-forest-ci')
                    .attr('id', (d) => `${this.getElementId(d)}_ci`)
                    .attr('transform', `translate(0, ${isNaN(this.parent.layout.height) ? 0 : this.parent.layout.height})`)
                    .merge(ci_selection)
                    .attr('transform', ci_transform)
                    .attr('width', ci_width)
                    .attr('height', ci_height);

                // Remove old elements as needed
                ci_selection.exit()
                    .remove();
            }

            // Generate a selection for all forest plot points
            const points_selection = this.svg.group
                .selectAll('path.lz-data_layer-forest.lz-data_layer-forest-point')
                .data(track_data, (d) => {
                    return d[this.layout.id_field];
                });

            // Create elements, apply class, ID, and initial position
            const initial_y = isNaN(this.parent.layout.height) ? 0 : this.parent.layout.height;

            // Generate new values (or functions for them) for position, color, size, and shape
            const transform = (d) => {
                let x = this.parent[x_scale](d[this.layout.x_axis.field]);
                let y = this.parent[y_scale](d[this.layout.y_axis.field]);
                if (isNaN(x)) {
                    x = -1000;
                }
                if (isNaN(y)) {
                    y = -1000;
                }
                return `translate(${x}, ${y})`;
            };

            const fill = (d, i) => this.resolveScalableParameter(this.layout.color, d, i);
            const fill_opacity = (d, i) => this.resolveScalableParameter(this.layout.fill_opacity, d, i);

            const shape = d3__WEBPACK_IMPORTED_MODULE_0__["symbol"]()
                .size((d, i) => this.resolveScalableParameter(this.layout.point_size, d, i))
                .type((d, i) => {
                    // Legend shape names are strings; need to connect this to factory. Eg circle --> d3.symbolCircle
                    const shape_name = this.resolveScalableParameter(this.layout.point_shape, d, i);
                    const factory_name = `symbol${shape_name.charAt(0).toUpperCase() + shape_name.slice(1)}`;
                    return d3__WEBPACK_IMPORTED_MODULE_0__[factory_name] || null;
                });

            points_selection.enter()
                .append('path')
                .attr('class', 'lz-data_layer-forest lz-data_layer-forest-point')
                .attr('id', (d) => this.getElementId(d))
                .attr('transform', `translate(0, ${initial_y})`)
                .merge(points_selection)
                .attr('transform', transform)
                .attr('fill', fill)
                .attr('fill-opacity', fill_opacity)
                .attr('d', shape);

            // Remove old elements as needed
            points_selection.exit()
                .remove();

            // Apply behaviors to points
            this.svg.group
                .on('click.event_emitter', (element_data) => {
                    this.parent.emit('element_clicked', element_data, true);
                }).call(this.applyBehaviors.bind(this));
        }
    }

    /**
     * A y-aligned forest plot in which the y-axis represents item labels, which are dynamically chosen when data is loaded.
     *   Each item is assumed to include both data and confidence intervals.
     *   This allows generating forest plots without defining the layout in advance.
     *
     */
    class CategoryForest extends Forest {
        _getDataExtent(data, axis_config) {
            // In a forest plot, the data range is determined by *three* fields (beta + CI start/end)
            const ci_config = this.layout.confidence_intervals;
            if (ci_config
                && this.layout.fields.includes(ci_config.start_field)
                && this.layout.fields.includes(ci_config.end_field)) {
                const min = (d) => +d[ci_config.start_field];
                const max = (d) => +d[ci_config.end_field];
                return [d3__WEBPACK_IMPORTED_MODULE_0__["min"](data, min), d3__WEBPACK_IMPORTED_MODULE_0__["max"](data, max)];
            }

            // If there are no confidence intervals set, then range must depend only on a single field
            return super._getDataExtent(data, axis_config);
        }

        getTicks(dimension, config) { // Overrides parent method
            if (!['x', 'y1', 'y2'].includes(dimension)) {
                throw new Error(`Invalid dimension identifier ${dimension}`);
            }

            // Design assumption: one axis (y1 or y2) has the ticks, and the layout says which to use
            // Also assumes that every tick gets assigned a unique matching label
            const axis_num = this.layout.y_axis.axis;
            if (dimension === (`y${axis_num}`)) {
                const category_field = this.layout.y_axis.category_field;
                if (!category_field) {
                    throw new Error(`Layout for ${this.layout.id} must specify category_field`);
                }

                return this.data.map((item, index) => ({ y: index + 1, text: item[category_field] }));
            } else {
                return [];
            }
        }

        applyCustomDataMethods () {
            // Add a synthetic yaxis field to ensure data is spread out on plot. Then, set axis floor and ceiling to
            //  correct extents.
            const field_to_add = this.layout.y_axis.field;
            if (!field_to_add) {
                throw new Error(`Layout for ${this.layout.id} must specify yaxis.field`);
            }

            this.data = this.data.map((item, index) => {
                item[field_to_add] = index + 1;
                return item;
            });
            // Update axis extents based on one label for every point (with a bit of padding above and below)
            this.layout.y_axis.floor = 0;
            this.layout.y_axis.ceiling = this.data.length + 1;
            return this;
        }
    }

    LocusZoom.DataLayers.add('forest', Forest);
    LocusZoom.DataLayers.add('category_forest', CategoryForest);
}

if (typeof LocusZoom !== 'undefined') {
    // Auto-register the plugin when included as a script tag. ES6 module users must register via LocusZoom.use()
    // eslint-disable-next-line no-undef
    LocusZoom.use(install);
}

/* harmony default export */ __webpack_exports__["default"] = (install);


/***/ }),

/***/ "d3":
/*!*********************!*\
  !*** external "d3" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = d3;

/***/ })

/******/ })["default"];
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9bbmFtZV0vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vW25hbWVdLy4vZXNtL2V4dC9sei1mb3Jlc3QtdHJhY2suanMiLCJ3ZWJwYWNrOi8vW25hbWVdL2V4dGVybmFsIFwiZDNcIiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7UUFBQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLHlDQUF5QyxpQ0FBaUM7UUFDMUUsZ0hBQWdILG1CQUFtQixFQUFFO1FBQ3JJO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMkJBQTJCLDBCQUEwQixFQUFFO1FBQ3ZELGlDQUFpQyxlQUFlO1FBQ2hEO1FBQ0E7UUFDQTs7UUFFQTtRQUNBLHNEQUFzRCwrREFBK0Q7O1FBRXJIO1FBQ0E7OztRQUdBO1FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lCOzs7QUFHekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0I7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLHdCQUF3Qjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsRUFBRSxJQUFJLEVBQUU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9ELHVEQUF1RCxpRUFBaUU7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxFQUFFLElBQUksRUFBRTtBQUM1Qzs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQix5Q0FBUztBQUNuQztBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0Esa0RBQWtELHlEQUF5RDtBQUMzRywyQkFBMkIsK0JBQUU7QUFDN0IsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFNLGFBQWEsc0NBQU07QUFDakQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBLGdFQUFnRSxVQUFVO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTs7QUFFQSx3REFBd0QsMkNBQTJDO0FBQ25HLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxlQUFlO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsc0VBQU8sRUFBQzs7Ozs7Ozs7Ozs7O0FDL092QixvQiIsImZpbGUiOiJleHQvbHotZm9yZXN0LXRyYWNrLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vZXNtL2V4dC9sei1mb3Jlc3QtdHJhY2suanNcIik7XG4iLCIvKipcbiAqIEZvcmVzdCBwbG90IHRyYWNrLCBkZXNpZ25lZCBmb3IgdXNlIHdpdGggUGhlV0FTIHN0eWxlIGRhdGFzZXRzLlxuICogICBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBjb3JlIExvY3VzWm9vbSBsaWJyYXJ5LCBidXQgY2FuIGJlIGluY2x1ZGVkIGFzIGEgc3RhbmRhbG9uZSBmaWxlLlxuICpcbiAqIFRoZSBwYWdlIG11c3QgaW5jb3Jwb3JhdGUgYW5kIGxvYWQgYWxsIGxpYnJhcmllcyBiZWZvcmUgdGhpcyBmaWxlIGNhbiBiZSB1c2VkLCBpbmNsdWRpbmc6XG4gKiAtIFZlbmRvciBhc3NldHNcbiAqIC0gTG9jdXNab29tXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCAqIGFzIGQzIGZyb20gJ2QzJztcblxuXG5mdW5jdGlvbiBpbnN0YWxsIChMb2N1c1pvb20pIHtcbiAgICBjb25zdCBCYXNlRGF0YUxheWVyID0gTG9jdXNab29tLkRhdGFMYXllcnMuZ2V0KCdCYXNlRGF0YUxheWVyJyk7XG4gICAgY29uc3QgZGVmYXVsdF9sYXlvdXQgPSB7XG4gICAgICAgIHBvaW50X3NpemU6IDQwLFxuICAgICAgICBwb2ludF9zaGFwZTogJ3NxdWFyZScsXG4gICAgICAgIGNvbG9yOiAnIzg4ODg4OCcsXG4gICAgICAgIGZpbGxfb3BhY2l0eTogMSxcbiAgICAgICAgeV9heGlzOiB7XG4gICAgICAgICAgICBheGlzOiAyLFxuICAgICAgICB9LFxuICAgICAgICBpZF9maWVsZDogJ2lkJyxcbiAgICAgICAgY29uZmlkZW5jZV9pbnRlcnZhbHM6IHtcbiAgICAgICAgICAgIHN0YXJ0X2ZpZWxkOiAnY2lfc3RhcnQnLFxuICAgICAgICAgICAgZW5kX2ZpZWxkOiAnY2lfZW5kJyxcbiAgICAgICAgfSxcbiAgICAgICAgc2hvd19ub19zaWduaWZpY2FuY2VfbGluZTogdHJ1ZSxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRm9yZXN0IERhdGEgTGF5ZXJcbiAgICAgKiBJbXBsZW1lbnRzIGEgc3RhbmRhcmQgZm9yZXN0IHBsb3QuIEluIG9yZGVyIHRvIHNwYWNlIG91dCBwb2ludHMsIGFueSBsYXlvdXQgdXNpbmcgdGhpcyBtdXN0IHNwZWNpZnkgYXhpcyB0aWNrc1xuICAgICAqICBhbmQgZXh0ZW50IGluIGFkdmFuY2UuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgYXJlIHVzaW5nIGR5bmFtaWNhbGx5IGZldGNoZWQgZGF0YSwgY29uc2lkZXIgdXNpbmcgYGNhdGVnb3J5X2ZvcmVzdGAgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqL1xuICAgIGNsYXNzIEZvcmVzdCBleHRlbmRzIEJhc2VEYXRhTGF5ZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihsYXlvdXQpIHtcbiAgICAgICAgICAgIGxheW91dCA9IExvY3VzWm9vbS5MYXlvdXRzLm1lcmdlKGxheW91dCwgZGVmYXVsdF9sYXlvdXQpO1xuICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9nZXRUb29sdGlwUG9zaXRpb24odG9vbHRpcCkge1xuICAgICAgICAgICAgY29uc3QgeF9jZW50ZXIgPSB0aGlzLnBhcmVudC54X3NjYWxlKHRvb2x0aXAuZGF0YVt0aGlzLmxheW91dC54X2F4aXMuZmllbGRdKTtcbiAgICAgICAgICAgIGNvbnN0IHlfc2NhbGUgPSBgeSR7dGhpcy5sYXlvdXQueV9heGlzLmF4aXN9X3NjYWxlYDtcbiAgICAgICAgICAgIGNvbnN0IHlfY2VudGVyID0gdGhpcy5wYXJlbnRbeV9zY2FsZV0odG9vbHRpcC5kYXRhW3RoaXMubGF5b3V0LnlfYXhpcy5maWVsZF0pO1xuXG4gICAgICAgICAgICBjb25zdCBwb2ludF9zaXplID0gdGhpcy5yZXNvbHZlU2NhbGFibGVQYXJhbWV0ZXIodGhpcy5sYXlvdXQucG9pbnRfc2l6ZSwgdG9vbHRpcC5kYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IE1hdGguc3FydChwb2ludF9zaXplIC8gTWF0aC5QSSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHhfbWluOiB4X2NlbnRlciAtIG9mZnNldCxcbiAgICAgICAgICAgICAgICB4X21heDogeF9jZW50ZXIgKyBvZmZzZXQsXG4gICAgICAgICAgICAgICAgeV9taW46IHlfY2VudGVyIC0gb2Zmc2V0LFxuICAgICAgICAgICAgICAgIHlfbWF4OiB5X2NlbnRlciArIG9mZnNldCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbXBsZW1lbnQgdGhlIG1haW4gcmVuZGVyIGZ1bmN0aW9uXG4gICAgICAgIHJlbmRlcigpIHtcbiAgICAgICAgICAgIC8vIEFwcGx5IGZpbHRlcnMgdG8gb25seSByZW5kZXIgYSBzcGVjaWZpZWQgc2V0IG9mIHBvaW50c1xuICAgICAgICAgICAgY29uc3QgdHJhY2tfZGF0YSA9IHRoaXMuX2FwcGx5RmlsdGVycygpO1xuXG4gICAgICAgICAgICBjb25zdCB4X3NjYWxlID0gJ3hfc2NhbGUnO1xuICAgICAgICAgICAgY29uc3QgeV9zY2FsZSA9IGB5JHt0aGlzLmxheW91dC55X2F4aXMuYXhpc31fc2NhbGVgO1xuXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBjb25maWRlbmNlIGludGVydmFsIHBhdGhzIGlmIGZpZWxkcyBhcmUgZGVmaW5lZFxuICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0LmNvbmZpZGVuY2VfaW50ZXJ2YWxzXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5sYXlvdXQuZmllbGRzLmluY2x1ZGVzKHRoaXMubGF5b3V0LmNvbmZpZGVuY2VfaW50ZXJ2YWxzLnN0YXJ0X2ZpZWxkKVxuICAgICAgICAgICAgICAgICYmIHRoaXMubGF5b3V0LmZpZWxkcy5pbmNsdWRlcyh0aGlzLmxheW91dC5jb25maWRlbmNlX2ludGVydmFscy5lbmRfZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBzZWxlY3Rpb24gZm9yIGFsbCBmb3Jlc3QgcGxvdCBjb25maWRlbmNlIGludGVydmFsc1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpX3NlbGVjdGlvbiA9IHRoaXMuc3ZnLmdyb3VwXG4gICAgICAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3JlY3QubHotZGF0YV9sYXllci1mb3Jlc3QubHotZGF0YV9sYXllci1mb3Jlc3QtY2knKVxuICAgICAgICAgICAgICAgICAgICAuZGF0YSh0cmFja19kYXRhLCAoZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRbdGhpcy5sYXlvdXQuaWRfZmllbGRdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNpX3RyYW5zZm9ybSA9IChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB4ID0gdGhpcy5wYXJlbnRbeF9zY2FsZV0oZFt0aGlzLmxheW91dC5jb25maWRlbmNlX2ludGVydmFscy5zdGFydF9maWVsZF0pO1xuICAgICAgICAgICAgICAgICAgICBsZXQgeSA9IHRoaXMucGFyZW50W3lfc2NhbGVdKGRbdGhpcy5sYXlvdXQueV9heGlzLmZpZWxkXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTih4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IC0xMDAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05hTih5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IC0xMDAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgdHJhbnNsYXRlKCR7eH0sICR7eX0pYDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpX3dpZHRoID0gKGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50W3hfc2NhbGVdKGRbdGhpcy5sYXlvdXQuY29uZmlkZW5jZV9pbnRlcnZhbHMuZW5kX2ZpZWxkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gdGhpcy5wYXJlbnRbeF9zY2FsZV0oZFt0aGlzLmxheW91dC5jb25maWRlbmNlX2ludGVydmFscy5zdGFydF9maWVsZF0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgY2lfaGVpZ2h0ID0gMTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgY29uZmlkZW5jZSBpbnRlcnZhbCByZWN0IGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgY2lfc2VsZWN0aW9uLmVudGVyKClcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgncmVjdCcpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdsei1kYXRhX2xheWVyLWZvcmVzdCBsei1kYXRhX2xheWVyLWZvcmVzdC1jaScpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdpZCcsIChkKSA9PiBgJHt0aGlzLmdldEVsZW1lbnRJZChkKX1fY2lgKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAke2lzTmFOKHRoaXMucGFyZW50LmxheW91dC5oZWlnaHQpID8gMCA6IHRoaXMucGFyZW50LmxheW91dC5oZWlnaHR9KWApXG4gICAgICAgICAgICAgICAgICAgIC5tZXJnZShjaV9zZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBjaV90cmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIGNpX3dpZHRoKVxuICAgICAgICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgY2lfaGVpZ2h0KTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQgZWxlbWVudHMgYXMgbmVlZGVkXG4gICAgICAgICAgICAgICAgY2lfc2VsZWN0aW9uLmV4aXQoKVxuICAgICAgICAgICAgICAgICAgICAucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgc2VsZWN0aW9uIGZvciBhbGwgZm9yZXN0IHBsb3QgcG9pbnRzXG4gICAgICAgICAgICBjb25zdCBwb2ludHNfc2VsZWN0aW9uID0gdGhpcy5zdmcuZ3JvdXBcbiAgICAgICAgICAgICAgICAuc2VsZWN0QWxsKCdwYXRoLmx6LWRhdGFfbGF5ZXItZm9yZXN0Lmx6LWRhdGFfbGF5ZXItZm9yZXN0LXBvaW50JylcbiAgICAgICAgICAgICAgICAuZGF0YSh0cmFja19kYXRhLCAoZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZFt0aGlzLmxheW91dC5pZF9maWVsZF07XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENyZWF0ZSBlbGVtZW50cywgYXBwbHkgY2xhc3MsIElELCBhbmQgaW5pdGlhbCBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgaW5pdGlhbF95ID0gaXNOYU4odGhpcy5wYXJlbnQubGF5b3V0LmhlaWdodCkgPyAwIDogdGhpcy5wYXJlbnQubGF5b3V0LmhlaWdodDtcblxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgbmV3IHZhbHVlcyAob3IgZnVuY3Rpb25zIGZvciB0aGVtKSBmb3IgcG9zaXRpb24sIGNvbG9yLCBzaXplLCBhbmQgc2hhcGVcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IChkKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHggPSB0aGlzLnBhcmVudFt4X3NjYWxlXShkW3RoaXMubGF5b3V0LnhfYXhpcy5maWVsZF0pO1xuICAgICAgICAgICAgICAgIGxldCB5ID0gdGhpcy5wYXJlbnRbeV9zY2FsZV0oZFt0aGlzLmxheW91dC55X2F4aXMuZmllbGRdKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IC0xMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IC0xMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYHRyYW5zbGF0ZSgke3h9LCAke3l9KWA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjb25zdCBmaWxsID0gKGQsIGkpID0+IHRoaXMucmVzb2x2ZVNjYWxhYmxlUGFyYW1ldGVyKHRoaXMubGF5b3V0LmNvbG9yLCBkLCBpKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGxfb3BhY2l0eSA9IChkLCBpKSA9PiB0aGlzLnJlc29sdmVTY2FsYWJsZVBhcmFtZXRlcih0aGlzLmxheW91dC5maWxsX29wYWNpdHksIGQsIGkpO1xuXG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IGQzLnN5bWJvbCgpXG4gICAgICAgICAgICAgICAgLnNpemUoKGQsIGkpID0+IHRoaXMucmVzb2x2ZVNjYWxhYmxlUGFyYW1ldGVyKHRoaXMubGF5b3V0LnBvaW50X3NpemUsIGQsIGkpKVxuICAgICAgICAgICAgICAgIC50eXBlKChkLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExlZ2VuZCBzaGFwZSBuYW1lcyBhcmUgc3RyaW5nczsgbmVlZCB0byBjb25uZWN0IHRoaXMgdG8gZmFjdG9yeS4gRWcgY2lyY2xlIC0tPiBkMy5zeW1ib2xDaXJjbGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhcGVfbmFtZSA9IHRoaXMucmVzb2x2ZVNjYWxhYmxlUGFyYW1ldGVyKHRoaXMubGF5b3V0LnBvaW50X3NoYXBlLCBkLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmFjdG9yeV9uYW1lID0gYHN5bWJvbCR7c2hhcGVfbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHNoYXBlX25hbWUuc2xpY2UoMSl9YDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQzW2ZhY3RvcnlfbmFtZV0gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcG9pbnRzX3NlbGVjdGlvbi5lbnRlcigpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgncGF0aCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2x6LWRhdGFfbGF5ZXItZm9yZXN0IGx6LWRhdGFfbGF5ZXItZm9yZXN0LXBvaW50JylcbiAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAoZCkgPT4gdGhpcy5nZXRFbGVtZW50SWQoZCkpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoMCwgJHtpbml0aWFsX3l9KWApXG4gICAgICAgICAgICAgICAgLm1lcmdlKHBvaW50c19zZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIHRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICAuYXR0cignZmlsbCcsIGZpbGwpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2ZpbGwtb3BhY2l0eScsIGZpbGxfb3BhY2l0eSlcbiAgICAgICAgICAgICAgICAuYXR0cignZCcsIHNoYXBlKTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBlbGVtZW50cyBhcyBuZWVkZWRcbiAgICAgICAgICAgIHBvaW50c19zZWxlY3Rpb24uZXhpdCgpXG4gICAgICAgICAgICAgICAgLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAvLyBBcHBseSBiZWhhdmlvcnMgdG8gcG9pbnRzXG4gICAgICAgICAgICB0aGlzLnN2Zy5ncm91cFxuICAgICAgICAgICAgICAgIC5vbignY2xpY2suZXZlbnRfZW1pdHRlcicsIChlbGVtZW50X2RhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuZW1pdCgnZWxlbWVudF9jbGlja2VkJywgZWxlbWVudF9kYXRhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9KS5jYWxsKHRoaXMuYXBwbHlCZWhhdmlvcnMuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHktYWxpZ25lZCBmb3Jlc3QgcGxvdCBpbiB3aGljaCB0aGUgeS1heGlzIHJlcHJlc2VudHMgaXRlbSBsYWJlbHMsIHdoaWNoIGFyZSBkeW5hbWljYWxseSBjaG9zZW4gd2hlbiBkYXRhIGlzIGxvYWRlZC5cbiAgICAgKiAgIEVhY2ggaXRlbSBpcyBhc3N1bWVkIHRvIGluY2x1ZGUgYm90aCBkYXRhIGFuZCBjb25maWRlbmNlIGludGVydmFscy5cbiAgICAgKiAgIFRoaXMgYWxsb3dzIGdlbmVyYXRpbmcgZm9yZXN0IHBsb3RzIHdpdGhvdXQgZGVmaW5pbmcgdGhlIGxheW91dCBpbiBhZHZhbmNlLlxuICAgICAqXG4gICAgICovXG4gICAgY2xhc3MgQ2F0ZWdvcnlGb3Jlc3QgZXh0ZW5kcyBGb3Jlc3Qge1xuICAgICAgICBfZ2V0RGF0YUV4dGVudChkYXRhLCBheGlzX2NvbmZpZykge1xuICAgICAgICAgICAgLy8gSW4gYSBmb3Jlc3QgcGxvdCwgdGhlIGRhdGEgcmFuZ2UgaXMgZGV0ZXJtaW5lZCBieSAqdGhyZWUqIGZpZWxkcyAoYmV0YSArIENJIHN0YXJ0L2VuZClcbiAgICAgICAgICAgIGNvbnN0IGNpX2NvbmZpZyA9IHRoaXMubGF5b3V0LmNvbmZpZGVuY2VfaW50ZXJ2YWxzO1xuICAgICAgICAgICAgaWYgKGNpX2NvbmZpZ1xuICAgICAgICAgICAgICAgICYmIHRoaXMubGF5b3V0LmZpZWxkcy5pbmNsdWRlcyhjaV9jb25maWcuc3RhcnRfZmllbGQpXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5sYXlvdXQuZmllbGRzLmluY2x1ZGVzKGNpX2NvbmZpZy5lbmRfZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWluID0gKGQpID0+ICtkW2NpX2NvbmZpZy5zdGFydF9maWVsZF07XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4ID0gKGQpID0+ICtkW2NpX2NvbmZpZy5lbmRfZmllbGRdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbZDMubWluKGRhdGEsIG1pbiksIGQzLm1heChkYXRhLCBtYXgpXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGNvbmZpZGVuY2UgaW50ZXJ2YWxzIHNldCwgdGhlbiByYW5nZSBtdXN0IGRlcGVuZCBvbmx5IG9uIGEgc2luZ2xlIGZpZWxkXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuX2dldERhdGFFeHRlbnQoZGF0YSwgYXhpc19jb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0VGlja3MoZGltZW5zaW9uLCBjb25maWcpIHsgLy8gT3ZlcnJpZGVzIHBhcmVudCBtZXRob2RcbiAgICAgICAgICAgIGlmICghWyd4JywgJ3kxJywgJ3kyJ10uaW5jbHVkZXMoZGltZW5zaW9uKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkaW1lbnNpb24gaWRlbnRpZmllciAke2RpbWVuc2lvbn1gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVzaWduIGFzc3VtcHRpb246IG9uZSBheGlzICh5MSBvciB5MikgaGFzIHRoZSB0aWNrcywgYW5kIHRoZSBsYXlvdXQgc2F5cyB3aGljaCB0byB1c2VcbiAgICAgICAgICAgIC8vIEFsc28gYXNzdW1lcyB0aGF0IGV2ZXJ5IHRpY2sgZ2V0cyBhc3NpZ25lZCBhIHVuaXF1ZSBtYXRjaGluZyBsYWJlbFxuICAgICAgICAgICAgY29uc3QgYXhpc19udW0gPSB0aGlzLmxheW91dC55X2F4aXMuYXhpcztcbiAgICAgICAgICAgIGlmIChkaW1lbnNpb24gPT09IChgeSR7YXhpc19udW19YCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXRlZ29yeV9maWVsZCA9IHRoaXMubGF5b3V0LnlfYXhpcy5jYXRlZ29yeV9maWVsZDtcbiAgICAgICAgICAgICAgICBpZiAoIWNhdGVnb3J5X2ZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGF5b3V0IGZvciAke3RoaXMubGF5b3V0LmlkfSBtdXN0IHNwZWNpZnkgY2F0ZWdvcnlfZmllbGRgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcCgoaXRlbSwgaW5kZXgpID0+ICh7IHk6IGluZGV4ICsgMSwgdGV4dDogaXRlbVtjYXRlZ29yeV9maWVsZF0gfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcHBseUN1c3RvbURhdGFNZXRob2RzICgpIHtcbiAgICAgICAgICAgIC8vIEFkZCBhIHN5bnRoZXRpYyB5YXhpcyBmaWVsZCB0byBlbnN1cmUgZGF0YSBpcyBzcHJlYWQgb3V0IG9uIHBsb3QuIFRoZW4sIHNldCBheGlzIGZsb29yIGFuZCBjZWlsaW5nIHRvXG4gICAgICAgICAgICAvLyAgY29ycmVjdCBleHRlbnRzLlxuICAgICAgICAgICAgY29uc3QgZmllbGRfdG9fYWRkID0gdGhpcy5sYXlvdXQueV9heGlzLmZpZWxkO1xuICAgICAgICAgICAgaWYgKCFmaWVsZF90b19hZGQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExheW91dCBmb3IgJHt0aGlzLmxheW91dC5pZH0gbXVzdCBzcGVjaWZ5IHlheGlzLmZpZWxkYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuZGF0YS5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbVtmaWVsZF90b19hZGRdID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgYXhpcyBleHRlbnRzIGJhc2VkIG9uIG9uZSBsYWJlbCBmb3IgZXZlcnkgcG9pbnQgKHdpdGggYSBiaXQgb2YgcGFkZGluZyBhYm92ZSBhbmQgYmVsb3cpXG4gICAgICAgICAgICB0aGlzLmxheW91dC55X2F4aXMuZmxvb3IgPSAwO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQueV9heGlzLmNlaWxpbmcgPSB0aGlzLmRhdGEubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgTG9jdXNab29tLkRhdGFMYXllcnMuYWRkKCdmb3Jlc3QnLCBGb3Jlc3QpO1xuICAgIExvY3VzWm9vbS5EYXRhTGF5ZXJzLmFkZCgnY2F0ZWdvcnlfZm9yZXN0JywgQ2F0ZWdvcnlGb3Jlc3QpO1xufVxuXG5pZiAodHlwZW9mIExvY3VzWm9vbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBBdXRvLXJlZ2lzdGVyIHRoZSBwbHVnaW4gd2hlbiBpbmNsdWRlZCBhcyBhIHNjcmlwdCB0YWcuIEVTNiBtb2R1bGUgdXNlcnMgbXVzdCByZWdpc3RlciB2aWEgTG9jdXNab29tLnVzZSgpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgTG9jdXNab29tLnVzZShpbnN0YWxsKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5zdGFsbDtcbiIsIm1vZHVsZS5leHBvcnRzID0gZDM7Il0sInNvdXJjZVJvb3QiOiIifQ==